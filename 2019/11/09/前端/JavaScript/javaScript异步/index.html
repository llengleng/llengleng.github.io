<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>JavaScript异步 - 冷冷</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="异步编程定义：异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。"><meta property="og:type" content="blog"><meta property="og:title" content="JavaScript异步"><meta property="og:url" content="http://example.com/2019/11/09/%E5%89%8D%E7%AB%AF/JavaScript/javaScript%E5%BC%82%E6%AD%A5/"><meta property="og:site_name" content="冷冷"><meta property="og:description" content="异步编程定义：异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/%E5%89%8D%E7%AB%AF/js.png"><meta property="article:published_time" content="2019-11-09T13:10:43.000Z"><meta property="article:modified_time" content="2021-01-10T04:04:00.000Z"><meta property="article:author" content="冷冷"><meta property="article:tag" content="前端"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/%E5%89%8D%E7%AB%AF/js.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2019/11/09/%E5%89%8D%E7%AB%AF/JavaScript/javaScript%E5%BC%82%E6%AD%A5/"},"headline":"JavaScript异步","image":["http://example.com/img/%E5%89%8D%E7%AB%AF/js.png"],"datePublished":"2019-11-09T13:10:43.000Z","dateModified":"2021-01-10T04:04:00.000Z","author":{"@type":"Person","name":"冷冷"},"publisher":{"@type":"Organization","name":"冷冷","logo":{"@type":"ImageObject","url":"https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"}},"description":"异步编程定义：异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。"}</script><link rel="canonical" href="http://example.com/2019/11/09/%E5%89%8D%E7%AB%AF/JavaScript/javaScript%E5%BC%82%E6%AD%A5/"><link rel="icon" href="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72437521-5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72437521-5');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="冷冷" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/./img/%E5%89%8D%E7%AB%AF/js.png" alt="JavaScript异步"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-11-09T13:10:43.000Z" title="2019/11/9 21:10:43">2019-11-09</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span><span class="level-item">1 小时读完 (大约8349个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">JavaScript异步</h1><div class="content"><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p><strong>定义：异步</strong>指两个或两个以上的对象或事件<strong>不</strong>同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。</p>
<span id="more"></span>

<p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的<strong>同时</strong>继续对其他事件做出反应而<strong>不必等待</strong>任务完成。与此同时，你的程序也将在任务完成后显示结果。</p>
<p>浏览器提供的许多功能（尤其是最有趣的那一部分）可能需要很长的时间来完成，因此需要异步完成，例如：</p>
<ul>
<li>使用 fetch() 发起 HTTP 请求</li>
<li>使用 getUserMedia() 访问用户的摄像头和麦克风</li>
<li>使用 showOpenFilePicker() 请求用户选择文件以供访问</li>
</ul>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><ul>
<li>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。</li>
<li>回调函数<strong>曾经</strong>是 JavaScript 中实现<strong>异步函数</strong>的主要方式。但是存在<strong>「回调地狱」</strong>使代码更难阅读和调试，所以现在大多数现代异步 API 都<strong>不使用回调</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="title function_">doSomethingElse</span>(result, <span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">    <span class="title function_">doThirdThing</span>(newResult, <span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>

<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li>本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;音频文件创建成功：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 失败的回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">failureCallback</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;音频文件创建失败：&quot;</span> + error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createAudioFileAsync</span>(audioSettings, successCallback, failureCallback)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//现代写法：</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="title function_">createAudioFileAsync</span>(audioSettings);</span><br><span class="line">promise.<span class="title function_">then</span>(successCallback, failureCallback);</span><br><span class="line"><span class="comment">//简写为:</span></span><br><span class="line"><span class="title function_">createAudioFileAsync</span>(audioSettings).<span class="title function_">then</span>(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>

<ul>
<li>在本轮 事件循环 运行完成之前，回调函数是不会被调用的。</li>
<li>即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。</li>
<li>过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序进行执行。</li>
<li><strong>链式调用：</strong>then() 函数会返回一个和原来不同的<strong>新的 Promise</strong>。</li>
<li>之前多重的异步操作导致经典的<strong>「回调地狱」，</strong>现在就可以把回调绑定到返回的 Promise 上，形成一个 Promise 链。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">doSomething</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">newResult</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">finalResult</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got the final result: &#x27;</span> + finalResult);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback);</span><br><span class="line"><span class="comment">//then 里的参数是可选的，</span></span><br><span class="line"><span class="comment">//catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数表示法：</span></span><br><span class="line"><span class="title function_">doSomething</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> <span class="title function_">doSomethingElse</span>(result))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">newResult</span> =&gt;</span> <span class="title function_">doThirdThing</span>(newResult))</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(failureCallback);</span><br><span class="line"></span><br><span class="line"><span class="comment">//async/await 语法糖表示法:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>();</span><br><span class="line">    <span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">    <span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="title function_">failureCallback</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用一个 catch 对于在链式操作中抛出一个失败之后，再次进行新的操作会很有用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;初始化&#x27;</span>);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;有哪里不对了&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行「这个」”&#x27;</span>);<span class="comment">//不执行，因为抛出了错误</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行「那个」&#x27;</span>);<span class="comment">//执行“那个”</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行「这个」，无论前面发生了什么&#x27;</span>);<span class="comment">//执行“这个”，无论前面发生了什么</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="async-await-语法糖"><a href="#async-await-语法糖" class="headerlink" title="async&#x2F;await 语法糖"></a>async&#x2F;await 语法糖</h3><p><strong>async 函数</strong>是使用async关键字声明的函数。async 函数是 AsyncFunction 构造函数的实例，并且其中允许使用 <strong>await</strong> <strong>关键字</strong>。</p>
<p><strong>async</strong> <strong>和</strong> <strong>await</strong> <strong>关键字</strong>让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise。</p>
<p><strong>语法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">param0</span>) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">param0, param1</span>) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">param0, param1, <span class="comment">/* … ,*/</span> paramN</span>) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>返回值：一个</strong> <strong>Promise</strong>，这个 promise 要么会通过一个由 async 函数返回的值<strong>被解决</strong>，要么会通过一个从 async 函数中抛出的（或其中没有被捕获到的）异常<strong>被拒绝</strong>。</p>
</li>
<li><ul>
<li>一个 Promise 必然处于以下几种状态之一：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><em>待定（pending）</em>：初始状态，既没有被兑现，也没有被拒绝。</li>
<li><em>已兑现（fulfilled）</em>：意味着操作成功完成。</li>
<li><em>已拒绝（rejected）</em>：意味着操作失败。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Promise</strong> 对象用于表示一个<strong>异步</strong>操作的最终完成（或失败）及其结果<strong>值</strong>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">doSomething</span>();</span><br><span class="line">    <span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">doSomethingElse</span>(result);</span><br><span class="line">    <span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">doThirdThing</span>(newResult);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Got the final result: <span class="subst">$&#123;finalResult&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="title function_">failureCallback</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>async 函数可能包含 0 个或者多个 await 表达式。</li>
<li>await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。</li>
<li>promise 的解决值会被当作该 await 表达式的返回值。使用 async&#x2F;await 关键字就可以在异步代码中使用普通的 try&#x2F;catch 代码块。</li>
<li>await 关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 SyntaxError 。</li>
<li>async 函数<strong>一定</strong>会返回一个 promise 对象。如果一个 async 函数的返回值看起来不是 promise，那么它将会被<strong>隐式</strong>地包装在一个 promise 中。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>async 函数的函数体可以被看作是由 0 个或者多个 await 表达式分割开来的。</li>
<li>从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。这样的话，一个<strong>不含 await</strong> 表达式的 async 函数是会<strong>同步运行</strong>的。然而，如果函数体内<strong>有一个 await</strong> 表达式，async 函数就一定会<strong>异步执行</strong>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="宏任务、微任务"><a href="#宏任务、微任务" class="headerlink" title="宏任务、微任务"></a>宏任务、微任务</h1><p>script是一个宏任务</p>
<p>在一个宏任务中，先执行同步代码，再执行微任务，再执行下一个宏任务。</p>
<h1 id="同步编程"><a href="#同步编程" class="headerlink" title="同步编程"></a>同步编程</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Miriam&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line"><span class="comment">// &quot;Hello, my name is Miriam!&quot;</span></span><br></pre></td></tr></table></figure>

<p>这段代码：</p>
<ol>
<li>声明了一个叫做 name 的字符串常量</li>
<li>声明了另一个叫做 greeting 的字符串常量（并使用了 name 常量的值）</li>
<li>将 greeting 常量输出到 JavaScript 控制台中。</li>
</ol>
<p>我们应该注意的是，实际上浏览器是按照我们书写代码的顺序一行一行地执行程序的。浏览器会等待代码的解析和工作，在上一行完成后才会执行下一行。这样做是很有必要的，因为每一行新的代码都是建立在前面代码的基础之上的。</p>
<p>这也使得它成为一个<strong>同步程序</strong>。</p>
<p>事实上，<strong>调用函数</strong>的时候也是<strong>同步</strong>的，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeGreeting</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Miriam&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="title function_">makeGreeting</span>(name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line"><span class="comment">// &quot;Hello, my name is Miriam!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这里 makeGreeting() 就是一个<strong>同步函数</strong>，因为在函数返回之前，调用者必须等待函数完成其工作。</p>
<p><strong>耗时同步函数的问题：</strong>当调用函数时长过久时，程序完全没有反应，用户不能输入任何东西，也不能点击任何东西，或做任何其他事情。</p>
<p>这就是耗时的同步函数的基本问题。在这里我们想要的是一种方法，以让的程序可以：</p>
<ul>
<li>通过调用一个函数来<strong>启动</strong>一个<strong>长期</strong>运行的操作</li>
<li>让函数开始操作并<strong>立即返回</strong>，这样我们的程序就可以保持对其他事件做出反应的能力</li>
<li>当操作最终完成时，<strong>通知</strong>我们操作的<strong>结果</strong>。</li>
</ul>
<p>这就是<strong>异步函数</strong>为我们提供的能力。</p>
<h1 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h1><p>我们刚才看到的对异步函数的描述可能会让你想起事件处理程序，这么想是对的。<strong>事件</strong>处理程序实际上就是<strong>异步编程</strong>的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。</p>
<p>一些早期的<strong>异步 API</strong> 正是以这种方式来使用<strong>事件</strong>的。<strong>XMLHttpRequest</strong> <strong>API</strong> 可以让你用 JavaScript 向远程服务器发起 HTTP 请求。由于这样的操作可能需要很长的时间，所以它被设计成异步 API，你可以通过给 XMLHttpRequest 对象附加<strong>事件监听器</strong>来让程序在请求进展和最终完成时获得通知。</p>
<p>下面的例子展示了这样的操作。点击“点击发起请求”按钮来发送一个请求。我们将创建一个新的 XMLHttpRequest 并监听它的 loadend 事件。而我们的事件处理程序则会在控制台中输出一个“完成！”的消息和请求的状态代码。</p>
<p>我们在添加了事件监听器后发送请求。注意，在这之后，我们仍然可以在控制台中输出“请求已发起”，也就是说，我们的<strong>程序</strong>可以在<strong>请求进行</strong>的<strong>同时继续运行</strong>，而我们的事件处理程序将在请求完成时被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;xhr&quot;</span>&gt;点击发起请求&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reload&quot;</span>&gt;</span>重载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">readonly</span> <span class="attr">class</span>=<span class="string">&quot;event-log&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.event-log&quot;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#xhr&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="title function_">addEventListener</span>(<span class="string">&quot;loadend&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span>完成！状态码：<span class="subst">$&#123;xhr.status&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  xhr.<span class="title function_">open</span>(</span><br><span class="line">    <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&quot;</span>,</span><br><span class="line">  );</span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span>请求已发起\n`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#reload&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  log.<span class="property">textContent</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.png"></p>
<p>这就像我们在以前的模块中遇到的<strong>事件处理程序</strong>，只是这次的事件不是像点击按钮那样的用户行为，而是某个对象的状态变化。</p>
<h1 id="回调-1"><a href="#回调-1" class="headerlink" title="回调"></a>回调</h1><p>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。</p>
<p>然而，当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。当你需要执行一些分解成一系列异步函数的操作时，这将变得十分常见。例如下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStep1</span>(<span class="params">init</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> init + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep2</span>(<span class="params">init</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> init + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep3</span>(<span class="params">init</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> init + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  result = <span class="title function_">doStep1</span>(result);</span><br><span class="line">  result = <span class="title function_">doStep2</span>(result);</span><br><span class="line">  result = <span class="title function_">doStep3</span>(result);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`结果：<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doOperation</span>();</span><br></pre></td></tr></table></figure>

<p>现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStep1</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">1</span>;</span><br><span class="line">  <span class="title function_">callback</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep2</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">2</span>;</span><br><span class="line">  <span class="title function_">callback</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doStep3</span>(<span class="params">init, callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">callback</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">doStep1</span>(<span class="number">0</span>, <span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doStep2</span>(result1, <span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">doStep3</span>(result2, <span class="function">(<span class="params">result3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`结果：<span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doOperation</span>();</span><br></pre></td></tr></table></figure>

<p>因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 doOperation() 函数，这就更难阅读和调试了。在一些地方这被称为“<strong>回调地狱</strong>”或“<strong>厄运金字塔</strong>”（因为缩进看起来像一个金字塔的侧面）。</p>
<p>面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。</p>
<p>由于以上这些原因，<strong>大多数现代异步 API 都不使用回调</strong>。事实上，JavaScript 中<strong>异步编程</strong>的基础是 <strong>Promise</strong>。</p>
<h1 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h1><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p>
<h2 id="使用-fetch-API"><a href="#使用-fetch-API" class="headerlink" title="使用 fetch() API"></a>使用 fetch() API</h2><p>fetch() API，一个现代的、基于 Promise 的、用于替代 XMLHttpRequest 的方法。</p>
<p>一个处理函数传递给 Promise 的 <strong>then()</strong> 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 Response 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fetchPromise);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`已收到响应：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;已发送请求……&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</span></span><br><span class="line"><span class="comment">//已发送请求……</span></span><br><span class="line"><span class="comment">//已收到响应：200</span></span><br></pre></td></tr></table></figure>

<p>请注意，已发送请求…… 的消息在我们收到响应之前就被输出了。与同步函数不同，fetch() 在请求仍在进行时返回，这使我们的程序能够保持响应性。响应显示了 200（OK）的状态码，意味着我们的请求成功了。</p>
<h2 id="链式使用-Promise"><a href="#链式使用-Promise" class="headerlink" title="链式使用 Promise"></a>链式使用 Promise</h2><p>在你通过 fetch() API 得到一个 Response 对象的时候，你需要调用另一个函数来获取响应数据。这次，我们想获得 JSON 格式的响应数据，所以我们会调用 Response 对象的 json() 方法。事实上，json() 也是异步的，因此我们必须连续调用两个异步函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jsonPromise = response.<span class="title function_">json</span>();</span><br><span class="line">  jsonPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，就像我们之前做的那样，我们给 fetch() 返回的 Promise 对象添加了一个 then() 处理程序。但这次我们的处理程序调用 response.json() 方法，然后将一个新的 then() 处理程序传递到 response.json() 返回的 Promise 中。</p>
<p>但 Promise 的优雅之处在于 <em>then() 本身也会返回一个 Promise，这个 Promise 将指示 then() 中调用的异步函数的完成状态</em>。这意味着我们可以（当然也应该）把上面的代码改写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>不必在第一个 then() 的处理程序中调用第二个 then()，我们可以直接<em>返回</em> json() 返回的 Promise，并在该返回值上调用第二个 “then()”。这被称为 <strong>Promise 链</strong>，意味着当我们需要<strong>连续进行异步函数调用</strong>时，我们就可以避免不断嵌套带来的缩进增加。</p>
<h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><p>Promise 对象提供了一个 <strong>catch()</strong> <strong>方法</strong>来支持错误处理。这很像 then()：你调用它并传入一个处理函数。然后，当异步<strong>操作</strong><em><strong>成功*<strong>时，传递给 <strong>then()</strong> 的处理函数被调用，而当异步</strong>操作</strong></em>**失败***时，传递给 <strong>catch()</strong> 的处理函数被调用。</p>
<p>使用 catch() 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//无法获取产品列表：TypeError: Failed to fetch</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h2><p>Promise 有三种状态：</p>
<ul>
<li><strong>待定（pending）</strong>：初始状态，既没有被兑现，也没有被拒绝。这是调用 fetch() 返回 Promise 时的状态，此时请求还在进行中。</li>
<li><strong>已兑现（fulfilled）</strong>：意味着操作成功完成。当 Promise 完成时，它的 then() 处理函数被调用。</li>
<li><strong>已拒绝（rejected）</strong>：意味着操作失败。当一个 Promise 失败时，它的 catch() 处理函数被调用。</li>
</ul>
<p>有时用 <strong>已敲定（settled）</strong> 这个词来同时表示 <strong>已兑现（fulfilled）</strong> 和 <strong>已拒绝（rejected）</strong> 两种情况。</p>
<p>如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 <strong>已兑现（fulfilled）</strong>。</p>
<h2 id="合并使用多个-Promise"><a href="#合并使用多个-Promise" class="headerlink" title="合并使用多个 Promise"></a>合并使用多个 Promise</h2><p>有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，将它们一起启动然后在它们全部被兑现后得到通知会更有效率。这里需要 <strong>Promise.all()</strong> <strong>方法</strong>。它接收一个 Promise <strong>数组</strong>，并返回一个<strong>单一</strong>的 Promise。</p>
<p>由Promise.all()返回的 Promise：</p>
<ul>
<li>当且仅当数组中<em>所有</em>的 Promise 都被兑现时，才会通知 then() 处理函数并提供一个包含所有响应的数组，数组中<strong>响应的顺序</strong>与<strong>被传入</strong> all() 的 Promise 的<strong>顺序相同</strong>。</li>
<li>会被拒绝——如果数组中有*<strong>任何一个*</strong> Promise 被拒绝。此时，catch() 处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise1 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise2 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise3 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">responses</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这里我们向三个不同的 URL 发出三个 fetch() 请求。如果它们都被兑现了，我们将输出每个请求的响应状态。如果其中任何一个被拒绝了，我们将输出失败的情况。</p>
<p>根据我们提供的 URL，应该所有的请求<strong>都会被兑现</strong>，尽管因为第二个请求中请求的文件不存在，服务器将返回 404（Not Found）而不是 200（OK）。所以输出应该是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">https</span>:<span class="comment">//mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json：200</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found：404</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//mdn.github.io/learning-area/javascript/oojs/json/superheroes.json：200</span></span><br></pre></td></tr></table></figure>

<p>如果我们用一个<strong>错误编码的 URL 尝试</strong>同样的代码，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise1 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise2 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise3 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">responses</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> response <span class="keyword">of</span> responses) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>……然后 catch() 处理程序将被运行，我们应该看到像这样的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获取失败：<span class="title class_">TypeError</span>: <span class="title class_">Failed</span> to fetch</span><br></pre></td></tr></table></figure>

<p>有时，你可能需要等待一组 Promise 中的<strong>某一个</strong> Promise 的执行，而<strong>不关心是哪一个</strong>。在这种情况下，你需要 <strong>Promise.any()<strong>。这就像 Promise.all()，不过在 Promise 数组中的</strong>任何一个</strong>被兑现时它就会<strong>被兑现</strong>，如果<strong>所有</strong>的 Promise 都被拒绝，它也会<strong>被拒绝</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise1 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise2 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;</span>,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> fetchPromise3 = <span class="title function_">fetch</span>(</span><br><span class="line">  <span class="string">&quot;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([fetchPromise1, fetchPromise2, fetchPromise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;response.url&#125;</span>：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`获取失败：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在这种情况下，我们无法预测哪个获取请求会先被兑现。</p>
<p>这两个用于<strong>组合多个承诺的函数</strong>只是额外的 Promise 函数中的两个。</p>
<h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><p><strong>async</strong> <strong>关键字</strong>为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 async，就可以使其成为一个异步函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 这是一个异步函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在异步函数中，你可以在<strong>调用</strong>一个返回 Promise 的<strong>函数之前</strong>使用 <strong>await 关键字</strong>。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。</p>
<p>这使你能够编写像同步代码一样的异步函数。例如，我们可以用它来重写我们的 fetch 示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchProducts</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span></span><br><span class="line">    <span class="comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">      <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span></span><br><span class="line">    <span class="comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchProducts</span>();</span><br></pre></td></tr></table></figure>

<p>这里我们<strong>调用 await fetch()<strong>，我们的</strong>调用者</strong>得到的并不是 Promise，而<strong>是一个完整的 Response 对象</strong>，就好像 fetch() 是一个同步函数一样。</p>
<p>我们甚至可以使用 try…catch 块来处理错误，就像我们在写同步代码时一样。</p>
<p>但请<strong>注意</strong>，<strong>这个写法只在异步函数中起作用</strong>。</p>
<p>异步函数总是<strong>返回一个 Pomise</strong>，所以你<strong>不能</strong>做这样的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchProducts</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">      <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="title function_">fetchProducts</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// json 是一个 Promise 对象，因此这句代码无法正常工作</span></span><br></pre></td></tr></table></figure>

<p>相反，你需要做一些事情，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchProducts</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(</span><br><span class="line">      <span class="string">&quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonPromise = <span class="title function_">fetchProducts</span>();</span><br><span class="line">jsonPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">json</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json[<span class="number">0</span>].<span class="property">name</span>));</span><br></pre></td></tr></table></figure>

<p>你可能会在需要使用 Promise 链地方使用 async 函数，这也使得 Promise 的工作更加直观。</p>
<p>请记住，就像一个 Promise 链一样，<strong>await 强制</strong>异步操作以<strong>串联</strong>的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 Promise.all() 这样的操作会有更好的性能。</p>
<h1 id="实现基于-Promise-的-API"><a href="#实现基于-Promise-的-API" class="headerlink" title="实现基于 Promise 的 API"></a>实现基于 Promise 的 API</h1><p>讨论了如何<strong>使用返回</strong> promises 的 APIs。在本文中，我们将研究另一方面——<strong>如何实现</strong>返回 promises 的 APIs。跟使用基于 promise 的 APIs 相比，这是一个不太常见的任务，但它仍然值得了解。</p>
<p>通常情况下，当你实现一个基于 promise 的 API 时，你会<strong>使用事件、普通回调，或者消息传递模型</strong>来<strong>包裹</strong>一个异步操作。你将会使用一个 Promise <strong>对象</strong>来合理的处理操作的成功或者失败。</p>
<h2 id="实现-alarm-API"><a href="#实现-alarm-API" class="headerlink" title="实现 alarm() API"></a>实现 alarm() API</h2><p>在这个示例中我们将会实现一个基于 promise 的 alarm API，叫做 alarm() 。它将以被唤醒人的名字和一个在人被唤醒前以毫秒为单位的延迟作为参数。在延迟之后，本函数将会发送一个包含需要被唤醒人名字的 “Wake up!” 消息。</p>
<h3 id="用-setTimeout-包裹"><a href="#用-setTimeout-包裹" class="headerlink" title="用 setTimeout() 包裹"></a>用 setTimeout() 包裹</h3><p>我们将会使用 setTimeout() 来实现 alarm() 函数。setTimeout() 以一个<strong>回调函数</strong>和一个以<strong>毫秒为单位的延迟</strong>作为参数。当调用 setTimeout() 时，它将启动一个设置为给定延迟的<strong>计时器</strong>，当时间过期时，它就会调用给定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;set-alarm&quot;</span>&gt;<span class="title class_">Set</span> alarm&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#set-alarm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setAlarm</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    output.<span class="property">textContent</span> = <span class="string">&quot;Wake up!&quot;</span>;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, setAlarm);</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5CsetTimeout.png"></p>
<h3 id="Promise-构造器"><a href="#Promise-构造器" class="headerlink" title="Promise() 构造器"></a>Promise() 构造器</h3><p>alarm() 函数<strong>返回</strong>一个在<strong>定时器过期时</strong>才会被兑现的 Promise。它将会传递一个 “Wake up!” 消息到 then() 处理器中，也会在当调用者提供一个<strong>负</strong>延迟值时<strong>拒绝</strong>这个 promise。</p>
<p>这里的关键组件是 Promise() 构造器。Promise() 构造器使用<strong>单个函数</strong>作为参数。我们把这个函数称作<strong>执行器（executor</strong>）。当你创建一个新的 promise 的时候你需要实现这个执行器。</p>
<p>这个<strong>执行器</strong>本身<strong>采用两个参数</strong>，这两个参数<strong>都是函数</strong>，通常被称作 resolve 和 reject。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 resolve，如果失败了，就调用 reject。如果执行器函数抛出了一个错误，reject 会被自动调用。你可以将任何类型的单个参数传递到 resolve 和 reject 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">alarm</span>(<span class="params">person, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Alarm delay must not be negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">`Wake up, <span class="subst">$&#123;person&#125;</span>!`</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数创建并且返回一个新的 Promise。对于执行器中的 promise，我们：</p>
<ul>
<li>检查 delay（延迟）是否为负数，如果是的话就抛出一个错误。</li>
<li>调用 window.setTimeout()，传递一个回调函数和 delay（延迟）。当计时器过期时回调会被调用，在回调函数内，我们调用了 resolve，并且传递了 “Wake up!” 消息。</li>
</ul>
<h2 id="使用-alarm-API"><a href="#使用-alarm-API" class="headerlink" title="使用 alarm() API"></a>使用 alarm() API</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> delay = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#delay&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#set-alarm&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> output = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alarm</span>(<span class="params">person, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Alarm delay must not be negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">`Wake up, <span class="subst">$&#123;person&#125;</span>!`</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alarm</span>(name.<span class="property">value</span>, delay.<span class="property">value</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">message</span>) =&gt;</span> (output.<span class="property">textContent</span> = message))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> (output.<span class="property">textContent</span> = <span class="string">`Couldn&#x27;t set alarm: <span class="subst">$&#123;error&#125;</span>`</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Calarm1.png"></p>
<h2 id="在-alarm-API-上使用-async-和-await"><a href="#在-alarm-API-上使用-async-和-await" class="headerlink" title="在 alarm() API 上使用 async 和 await"></a>在 alarm() API 上使用 async 和 await</h2><p>自从 alarm() 返回了一个 Promise，我们可以对它做任何我们可以对其他任何 promise 做的事情：Promise.all()，和 async &#x2F; await：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> delay = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#delay&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#set-alarm&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> output = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">alarm</span>(<span class="params">person, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Alarm delay must not be negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">`Wake up, <span class="subst">$&#123;person&#125;</span>!`</span>);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="keyword">await</span> <span class="title function_">alarm</span>(name.<span class="property">value</span>, delay.<span class="property">value</span>);</span><br><span class="line">    output.<span class="property">textContent</span> = message;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    output.<span class="property">textContent</span> = <span class="string">`Couldn&#x27;t set alarm: <span class="subst">$&#123;error&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Calarm2.png"></p>
<h1 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h1><p>在本模块的第一篇文章中，我们看到了当在你的程序中具有一个长期运行的的同步任务时发生了什么 ── 整个窗口变得完全没有响应。从根本上讲，出现这种情况的原因是程序是单线程的。一个线程是程序遵循的一系列指令。因为程序由一个线程组成，它在同一时间只能做一件事情：所以如果它正在等待我们的长期运行的同步调用返回，它就不能做其他任何事情。</p>
<p>Workers 给了你在<strong>不同线程</strong>中运行某些任务的能力，因此你可以启动任务，然后继续其他的处理（例如处理用户操作）。</p>
<p>但是这是要付出代价的。对于<strong>多线程</strong>代码，你永远不知道你的线程什么时候将会被挂起，其他线程将会得到运行的机会。因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化，这将<strong>导致</strong>很难发现的 <strong>Bug</strong>。</p>
<p>为了避免 Web 中的这些问题，你的<strong>主代码和</strong>你的 <strong>worker 代码永远不能直接访问</strong>彼此的变量。Workers 和主代码运行在<strong>完全分离</strong>的环境中，只有通过<strong>相互发送消息</strong>来进行<strong>交互</strong>。特别是，这意味着 <strong>workers 不能访问 DOM</strong>（窗口、文档、页面元素等等）。</p>
<p>有<strong>三种</strong>不同类型的 workers：</p>
<ul>
<li>dedicated workers</li>
<li>shared workers</li>
<li>service workers</li>
</ul>
<h2 id="使用-web-workers（dedicated-workers）"><a href="#使用-web-workers（dedicated-workers）" class="headerlink" title="使用 web workers（dedicated workers）"></a>使用 web workers（dedicated workers）</h2><p>用 worker 进行质数生成：</p>
<p>目录下有四个文件：</p>
<ul>
<li>index.html</li>
<li>style.css</li>
<li>main.js</li>
<li>generate.js</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;quota&quot;</span>&gt;</span>Number of primes:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;quota&quot;</span> <span class="attr">name</span>=<span class="string">&quot;quota&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;generate&quot;</span>&gt;</span>Generate primes<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reload&quot;</span>&gt;</span>Reload<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;user-input&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;62&quot;</span>&gt;</span></span><br><span class="line">      Try typing in here immediately after pressing &quot;Generate primes&quot;&lt;/textarea</span><br><span class="line">                                                                       &gt;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“main.js” 和 “generate.js” 文件是空的。我们将向 “main.js” 中添加<strong>主代码</strong>，向 “generate.js” 中添加 <strong>worker 代码</strong>。</p>
<p>首先，我们可以看到 worker 代码被保存在一个与主代码<strong>隔离</strong>的脚本中。我们还可以看到，在上面的 <strong>“index.html” 中，只有主代码被包含在</strong> <strong><code>&lt;script&gt;</code></strong> <strong>标签中</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 &quot;generate.js&quot; 中创建一个新的 worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;./generate.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户点击 &quot;Generate primes&quot; 时，给 worker 发送一条消息。</span></span><br><span class="line"><span class="comment">// 消息中的 command 属性是 &quot;generate&quot;, 还包含另外一个属性 &quot;quota&quot;，即要生成的质数。</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#generate&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> quota = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#quota&quot;</span>).<span class="property">value</span>;</span><br><span class="line">  worker.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">    <span class="attr">command</span>: <span class="string">&quot;generate&quot;</span>,</span><br><span class="line">    <span class="attr">quota</span>: quota,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。</span></span><br><span class="line">worker.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#output&quot;</span>).<span class="property">textContent</span> =</span><br><span class="line">    <span class="string">`Finished generating <span class="subst">$&#123;message.data&#125;</span> primes!`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#reload&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#user-input&quot;</span>).<span class="property">value</span> =</span><br><span class="line">    <span class="string">&#x27;Try typing in here immediately after pressing &quot;Generate primes&quot;&#x27;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">location</span>.<span class="title function_">reload</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先，我们使用 <strong>Worker()</strong> <strong>构造函数</strong>创建 worker。我们传递一个指向 worker 脚本的 URL。只要 worker 被创建了，worker 脚本就会执行。</p>
</li>
<li><p>其次，与同步版本一样，我们向 “Generate primes” 按钮添加一个 click 事件处理器。但是现在，我们不再调用 generatePrimes() 函数，而是使用 <strong>worker.postMessage()</strong> 向 worker 发送一条消息。这条消息可以携带一个参数，在本示例中我们传递一个包含两个属性的 JSON 对象：</p>
</li>
<li><ul>
<li>command：一个用于标识我们希望 worker 所做事情的字符串（以防我们的 worker 可以做多个事情）。</li>
<li>quota：要生成的质数的数量。</li>
</ul>
</li>
<li><p>然后，我们向 worker 添加一个 message 消息处理器。这样 worker 就能告诉我们它是什么时候完成的，并且传递给我们任何结果数据。我们的处理器从消息的 data 属性获取数据，然后将其写入 output 元素（数据与 quota 是完全相同的，这虽然没有意义，但是这展示了其中原理）。</p>
</li>
<li><p>最后，我们为 “Reload” 按钮实现了 click 事件处理器。这与同步版本完全相同。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听主线程中的消息。</span></span><br><span class="line"><span class="comment">// 如果消息中的 command 是 &quot;generate&quot;，则调用 `generatePrimse()`</span></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (message.<span class="property">data</span>.<span class="property">command</span> === <span class="string">&quot;generate&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">generatePrimes</span>(message.<span class="property">data</span>.<span class="property">quota</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成质数 (非常低效)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generatePrimes</span>(<span class="params">quota</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">2</span>; c &lt;= <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(n); ++c) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n % c === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> primes = [];</span><br><span class="line">  <span class="keyword">const</span> maximum = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (primes.<span class="property">length</span> &lt; quota) &#123;</span><br><span class="line">    <span class="keyword">const</span> candidate = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (maximum + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPrime</span>(candidate)) &#123;</span><br><span class="line">      primes.<span class="title function_">push</span>(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成后给主线程发送一条包含我们生成的质数数量的消息消息。</span></span><br><span class="line">  <span class="title function_">postMessage</span>(primes.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请记住，只要主脚本创建 worker，“generate.js”这些代码就会运行。</p>
<p><strong>worker</strong> 要做的<strong>第一件</strong>事情就是开始<strong>监听</strong>来自主脚本的消息。这通过使用 <strong>addEventListener()</strong> 实现，它在 worker 中是一个全局函数。在 message 事件处理器内部，事件的 data 属性包含一个来自主脚本的参数的副本。如果主脚本传递 generate 命令，我们就调用 generatePrimes()，传入来自消息事件的 quota 值。</p>
<p><strong>generatePrimes() 函数</strong>与同步版本类似，只不过我们在完成后向主脚本<strong>发送一条消息，</strong>而不是返回一个值。我们对此使用 <strong>postMessage()</strong> <strong>函数</strong>，就像在 worker 中 addEventListener是<strong>全局函数</strong>一样。如我们所见，<strong>主脚本</strong>正在<strong>监听</strong>这条消息并且将<strong>会在收到消息后更新 DOM</strong>。</p>
<h2 id="其他类型的-worker"><a href="#其他类型的-worker" class="headerlink" title="其他类型的 worker"></a>其他类型的 worker</h2><p>其他类型的 worker：</p>
<ul>
<li>SharedWorker 可以由运行在<strong>不同窗口</strong>中的<strong>多个不同脚本共享</strong>。</li>
<li>Service worker 的行为就像<strong>代理服务器</strong>，缓存资源以便于 web 应用程序可以<strong>在用户离线时工作</strong>。他们是<strong>渐进式 Web 应用</strong>的<strong>关键组件</strong>。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>JavaScript异步</p><p><a href="http://example.com/2019/11/09/前端/JavaScript/javaScript异步/">http://example.com/2019/11/09/前端/JavaScript/javaScript异步/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>冷冷</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-11-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5ab6f60ace89f00013641890&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/11/10/%E5%89%8D%E7%AB%AF/HTML/HTML%20%E5%B1%9E%E6%80%A7/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">HTML 属性</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/11/02/%E5%89%8D%E7%AB%AF/HTML/HTML%E5%85%83%E7%B4%A0/"><span class="level-item">HTML 元素</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="i呼啸冷冷"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">i呼啸冷冷</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#异步编程"><span class="level-left"><span class="level-item">1</span><span class="level-item">异步编程</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#回调"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">回调</span></span></a></li><li><a class="level is-mobile" href="#Promise"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Promise</span></span></a></li><li><a class="level is-mobile" href="#async-await-语法糖"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">async/await 语法糖</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#宏任务、微任务"><span class="level-left"><span class="level-item">2</span><span class="level-item">宏任务、微任务</span></span></a></li><li><a class="level is-mobile" href="#同步编程"><span class="level-left"><span class="level-item">3</span><span class="level-item">同步编程</span></span></a></li><li><a class="level is-mobile" href="#事件处理程序"><span class="level-left"><span class="level-item">4</span><span class="level-item">事件处理程序</span></span></a></li><li><a class="level is-mobile" href="#回调-1"><span class="level-left"><span class="level-item">5</span><span class="level-item">回调</span></span></a></li><li><a class="level is-mobile" href="#Promise-1"><span class="level-left"><span class="level-item">6</span><span class="level-item">Promise</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-fetch-API"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">使用 fetch() API</span></span></a></li><li><a class="level is-mobile" href="#链式使用-Promise"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">链式使用 Promise</span></span></a></li><li><a class="level is-mobile" href="#错误捕获"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">错误捕获</span></span></a></li><li><a class="level is-mobile" href="#Promise-术语"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">Promise 术语</span></span></a></li><li><a class="level is-mobile" href="#合并使用多个-Promise"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">合并使用多个 Promise</span></span></a></li></ul></li><li><a class="level is-mobile" href="#async-和-await"><span class="level-left"><span class="level-item">7</span><span class="level-item">async 和 await</span></span></a></li><li><a class="level is-mobile" href="#实现基于-Promise-的-API"><span class="level-left"><span class="level-item">8</span><span class="level-item">实现基于 Promise 的 API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#实现-alarm-API"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">实现 alarm() API</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#用-setTimeout-包裹"><span class="level-left"><span class="level-item">8.1.1</span><span class="level-item">用 setTimeout() 包裹</span></span></a></li><li><a class="level is-mobile" href="#Promise-构造器"><span class="level-left"><span class="level-item">8.1.2</span><span class="level-item">Promise() 构造器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#使用-alarm-API"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">使用 alarm() API</span></span></a></li><li><a class="level is-mobile" href="#在-alarm-API-上使用-async-和-await"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">在 alarm() API 上使用 async 和 await</span></span></a></li></ul></li><li><a class="level is-mobile" href="#worker"><span class="level-left"><span class="level-item">9</span><span class="level-item">worker</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用-web-workers（dedicated-workers）"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">使用 web workers（dedicated workers）</span></span></a></li><li><a class="level is-mobile" href="#其他类型的-worker"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">其他类型的 worker</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2023/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="设计模式"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-11-19T14:10:43.000Z">2023-11-19</time></p><p class="title"><a href="/2023/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/09/29/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="前端安全性"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-09-29T14:10:43.000Z">2023-09-29</time></p><p class="title"><a href="/2023/09/29/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7/">前端安全性</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/08/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="低代码设计器的实现原理"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-08-19T14:10:43.000Z">2023-08-19</time></p><p class="title"><a href="/2023/08/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">低代码设计器的实现原理</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/06/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="发布 npm 包"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-06-19T14:10:43.000Z">2023-06-19</time></p><p class="title"><a href="/2023/06/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85/">发布 npm 包</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/05/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="低代码简介"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-05-19T14:10:43.000Z">2023-05-19</time></p><p class="title"><a href="/2023/05/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/">低代码简介</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="冷冷" height="28"></a><p class="is-size-7"><span>&copy; 2024 冷冷</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>