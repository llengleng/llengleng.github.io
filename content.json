{"posts":[{"title":"最长公共子序列问题","text":"一. 问题描述 若给定序列X={x1,x2,…,xm}，则另一序列Z={z1,z2,…,zk}，是X的子序列是指存在一个严格递增下标序列{i1,i2,…,ik}使得对于所有j=1,2,…,k有：zj=xij。例如，序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的子序列，相应的递增下标序列为{2，3，5，7}。如果给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。现给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，要求使用动态规划算法思想，找出X和Y的最长公共子序列。 二. 审题 给两个字符串str1和str2，返回这两个字符串的最长公共子序列。就是找出两个字符串中相等的字符。例如：如图中字符串ABCDE和字符串ACE的最长公共子序列为ACE，长度为3。 三. 问题建模 可以根据str1[i]和str2[j]的情况，将最长公共子序列问题分为两种情况解决： ①若strl[i] == str2[j] ，也就是说两个字符串的最后一位相等，那么问题就转化成了字符串str1的[1,j-1]区间和字符串str2的[1,j-1]区间的最长公共子序列长度再加上1，即dp[i][j] = dp[i - 1][j - 1] + 1。（下标从1开始）。 ②若str1[i] != str2[j]，也就是说两个字符串的最后一位不相等，那么字符串str1的[1,i]区间和字符串str2的[1,j]区间的最长公共子序列长度无法延长，因此dp[i][j]就会继承dp[i-1][j]与dp[i][j-1]中的较大值，即dp[i][j] = max(f[i - 1][j],f[i][j - 1])。（下标从1开始） 根据上面的描述，可以得出目标函数： 最后通过逆序获取值相同的字符，并将结果逆置即可。 时间复杂度分析： O(nm)，其中 n 和 m 分别是字符串 str1 和 str2 的长度。二维数组 dp 有 m+1 行和 n+1 列，需要对 dp 中每个元素进行计算。 空间复杂度分析： O(nm)，其中 n 和 m 分别是字符串 str1 和 str2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。 来源于：力扣 四. 代码实现 1. 求解最大子序列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package ch01;import java.util.Scanner;public class dp { public static String removespace(String a){ String a1=&quot;&quot;; for (int i=0;i&lt;a.length();i++) if (a.charAt(i)!=32){ a1+=a.charAt(i); } return a1; } public static String reserve(String a){ String k=&quot;&quot;; for (int i=a.length()-1;i&gt;=0;i--){ k += a.charAt(i); }// System.out.println(k);/ return k; } public static String llist(String a,String b){ String ned=&quot;&quot;; int lena=a.length(),lenb=b.length(); int[][] dp=new int[lena+1][lenb+1]; /* 将矩阵钟所有数据置为0 */ for (int i=0;i&lt;=lena;i++){ for (int j=0;j&lt;=lenb;j++){ dp[i][j]=0; } } /* 根据算法描述，为矩阵填入数据 */ for (int i=1;i&lt;=lena;i++){ for (int j=1;j&lt;=lenb;j++){ /* charAt为提取字符串中序列元素的值 */ if (a.charAt(i-1)==b.charAt(j-1)){ dp[i][j]=dp[i-1][j-1]+1; }else{ dp[i][j]= Math.max(dp[i - 1][j], dp[i][j - 1]); } } } /* 打印矩阵 */// for(int i=0;i&lt;=lena;i++){// for (int j=0;j&lt;=lenb;j++){// System.out.print(dp[i][j]+&quot;\\t&quot;);// }// System.out.println();// } /* 提取序列，倒叙法，纯原创 */ int temp=dp[lena][lenb]; for (int i=lena;i&gt;=1;i--){ for (int j=lenb;j&gt;=1;j--){ if (dp[i][j]==temp &amp;&amp; a.charAt(i-1)==b.charAt(j-1)){ ned+=b.charAt(j-1); temp--; } } } return reserve(ned); /* 提取序列第二钟方式 */// for(int i = lena - 1,j = lenb -1 ;i &gt;= 0 &amp;&amp; j &gt;= 0;) {// if(a.charAt(i) == b.charAt(j)) {// ned+= a.charAt(i);// i--;j--;// }else if(dp[i-1][j] &gt; dp[i][j-1]){// i--;// }else {// j--;// }// }// String lon=reserve(ned);// return lon; } public static void main(String[] args) { String str1,str2; Scanner scanner = new Scanner(System.in); str1=scanner.nextLine(); str2=scanner.nextLine(); String lon=llist(removespace(str1),removespace(str2)); System.out.print(&quot;[&quot;); for (int i=0;i&lt;lon.length();i++){ if (i!=lon.length()-1) System.out.print(&quot;'&quot;+lon.charAt(i)+&quot;',&quot;+&quot; &quot;); else System.out.print(&quot;'&quot;+lon.charAt(i)+&quot;'&quot;); } System.out.print(&quot;]&quot;); }} 运行结果： 2. 求解最大子序列个数1234567891011121314151617181920212223242526package ch01;public class Lo { public static void main(String[] args) { String a = &quot;ABCDFR&quot;; String b = &quot;ll&quot;; int h = longestCommonSubsequence(a, b); System.out.println(h); }public static int longestCommonSubsequence(String text1, String text2) { int m = text1.length(), n = text2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i &lt;= m; i++) { char c1 = text1.charAt(i - 1); for (int j = 1; j &lt;= n; j++) { char c2 = text2.charAt(j - 1); if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[m][n]; }} 运行结果：","link":"/2022/09/29/408/%E7%AE%97%E6%B3%95/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"},{"title":"棋盘覆盖问题","text":"一. 问题描述 给定一个2k×2k的棋盘(具体图例见教材)，有一个特殊棋格，拥有一个特殊棋格的棋盘称为特殊棋盘。现要用四种L型骨牌(具体图例见教材)覆盖特殊棋盘上除特殊棋格外的全部棋格，不能重叠，找出覆盖方案。（使用二分法） 二. 审题 给一个2k * 2k的棋盘(k&gt;=0)，棋盘中有一个特殊棋格。如图所示： 现在需要使用以下四种L型骨牌覆盖除特殊棋格外的全部棋盘，不能重叠。求解覆盖方案。 生活中，像布线时绕过障碍物或者铺地砖遇到障碍物都可以使用此算法来解决这类问题。 三. 问题建模 当n = 1 时，棋盘的大小为2*2，此时可以使用一个L型骨牌将棋盘可以被覆盖。如图所示： 假设n = k时，即棋盘大小为2k * 2k时，该问题有解。 则当n = k + 1时，即棋盘大小为2k+1 * 2k+1时时，我们可以将棋盘分为4个大小为2k * 2k子棋盘，其中一个子棋盘中包含特殊方格，至于其他3个不存在特殊方格的子棋盘，我们利用一个L型骨牌来覆盖这个3个子棋盘的交汇处，从而分别构造一个特殊的方格，将原问题转换为4个n = k时的子问题，因为n = k时有解，所以n = k + 1时也有解。如图所示： 介于上述思路，我们可以采用分治算法，将2k * 2k的棋盘覆盖问题分解为N个规模较小的子棋盘的覆盖问题，即求出子问题的解，就可以得到原问题的解。 分治算法的三个步骤： ① 分解：将原问题的分解成若干个小规模，相互独立，但与原问题形式一样的子问题。 ② 解决：如果子问题规模小并且容易求解就可以直接求解，否则递归求解各子问题。 ③ 合并：将各个子问题的解合并成原问题的解。 算法分析： 当n = 2k 时, T(n) = O(n2) = O(4k) 四. 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package ch01;import java.util.Scanner;import static java.lang.Math.pow;public class FillChess { private static int ChessSize; private static int x1,y1; private static int[][] chess; private static int t = 1; public static void main(String[] args) { ChessSize = (int) pow(2,new Scanner(System.in).nextInt()); Scanner sc = new Scanner(System.in); String[] numbers = sc.nextLine().split(&quot; &quot;); x1=Integer.parseInt(numbers[0])-1; y1=Integer.parseInt(numbers[1])-1; chess = new int[ChessSize][ChessSize]; three(0, 0, x1, y1, ChessSize); print(); } private static void print() { for (int i = 0; i &lt; ChessSize; i++) { for (int j = 0; j &lt; ChessSize; j++) { if (i==x1 &amp;&amp; j==y1) chess[i][j]=-1; System.out.print(chess[i][j] + &quot;\\t&quot;); } System.out.println(); } } public static void three(int chess_h, int chess_l, int t_h, int t_l,int size) { //如果棋盘是1*1,则直接返回 if (size == 1) return; //L牌号 int num = t++; //分割棋盘 int p = size / 2; //覆盖左上角棋盘 if (t_h &lt; chess_h + p &amp;&amp; t_l &lt; chess_l + p) { three(chess_h, chess_l, t_h, t_l, p);//有特殊 } else {//无特殊 //覆盖右下角 chess[chess_h + p - 1][chess_l + p - 1] = num; three(chess_h, chess_l, chess_h + p - 1, chess_l + p - 1, p); } //覆盖右上角棋盘 if (t_h &lt; chess_h + p &amp;&amp; t_l &gt;= chess_l + p) { three(chess_h, chess_l + p, t_h, t_l, p); } else {//殊无特 //覆盖左下角 chess[chess_h + p - 1][chess_l + p] = num; three(chess_h, chess_l + p, chess_h + p - 1, chess_l + p, p); } //覆盖左下角棋盘 if (t_h &gt;= chess_h + p &amp;&amp; t_l &lt; chess_l + p) { three(chess_h + p, chess_l, t_h, t_l, p);//有特殊 } else { //覆盖右上角 chess[chess_h + p][chess_l + p - 1] = num; three(chess_h + p, chess_l, chess_h + p, chess_l + p - 1, p); } //覆盖右下角棋盘 if (t_h &gt;= chess_h + p &amp;&amp; t_l &gt;= chess_l + p) { three(chess_h + p, chess_l + p, t_h, t_l, p);//有特殊 } else { //覆盖左上角 chess[chess_h + p][chess_l + p] = num; three(chess_h + p, chess_l + p, chess_h + p , chess_l + p , p); } }} 运行结果：","link":"/2022/04/29/408/%E7%AE%97%E6%B3%95/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"},{"title":"英语长难句","text":"一、简单句1. 什么是英语的句子英语的句子必须具备主谓结构，并且主语一定是谓语动作的发出者，如果有宾语，宾语一定是谓语动作的承受者。 2. 句子的基本结构1）主谓结构2）主谓宾结构 谓语：实义动词 3）主系表结构 谓语：系动词 be动词 感官动词：look（=seem=appear）、smell（n. 气味。）、taste（n. 喜爱，爱好。have taste for sth. 喜爱…）、sound（n. 声音。 adj. 甜美的，好的。）、feel 变化：become、get、turn、grow、fall 保持：keep、stay、remain、stand 4）主谓双宾5）主谓宾宾补 区别主谓双宾和主谓宾宾补：只需要在最后两个宾语之间加一个be动词，如果意思读起来对的就是主谓宾宾补，如果意思不对就是主谓双宾。 I bought him (is) a dog.（主谓双宾） You should keep the room (is) clean and tidy.（主谓宾宾补） We made him (is) our monitor. （主谓宾宾补） 3. 句子的成分：⭐⭐⭐⭐⭐1）谓语的词性① 谓语的成分：有时态的实义动词或系动词充当谓语。 ② 一句话当中动词能不能多？ 绝对不能多，一句话当中只能有一个动词的存在，并且充当谓语，多余的动词全部都要变成非谓语动词。 谓词只能是动词，动词只能做谓语。所以我们需要把一句话当中所有不做谓语的动词全部都要变成不是动词（1. v+ing 表示主动。 2. v+ed 表示被动。 3. to+do 表示目的。） 他穿上外衣服，锁上门，离开了家。 He putting on his jacket, locking the door, left home. 大熊猫是熊科中最罕见的成员，主要生活在中国的西南部的森林里。 Pandas are the rarest members in bear family, mainly living in the forest of Chinese Southwest. 长江流经不同的生态体系，是诸多濒危物种的栖息地，灌溉了中国五分之一的土地。 YangZi River flowing through diverse ecological systems, keeps the home of a sea of endangered species, irrigating Chinese 1/5 land. 我爱你，你爱我。 I loving you，you love me.（独立主格：两个主语不同，不能省略任何一个主语） 冬天来了，春天就不远了。 Winter approaching，sping will be around the corner.（独立主格：两个主语不同，不能省略任何一个主语） 我是一个老师，我很喜欢唱歌。 being a teacher, I have passion for singing songs. （分词做状语：分词主语=主句主语，可以省略一个） ③ 一句话当中动词能不能少？ 绝对不能少，当一句需要动词而没有动词的时候，永远都加be动词，并且be动词没有意思。 谓语的总结：一句话当中，有且只能有一个有时态的实义动词或系动词的存在。并且充当谓语。 2）主语的词性① 主语的成分：名词、代词、非谓语动词、从句(引导词+句子) handsome and strong are his nature. (×)形容词不能当主语 Being handsome and strong is his nature. (√) ② 一句话当中主语能不能少？ 绝对不能少，那一句话没有主语怎么办呢？ 加 it 做主语：必须与天气、温度、时间有关系。 机舱里很闷。 It feels exceedingly hot in the cabin. there be 句型：听到“有”的时候使用。(exist\\seem\\remain) 有很多人喜欢我。 There exist a host of undergraduate being fascinated with me. ▲▲▲被动：当听到一句话没有主语或听到人称代词做主语的时候都可以考虑写成被动。（三种情况没有被动：1. 如果动词后面有介词，该动词没有被动。 2. 所有系动词都没有被动。 3. have 翻译成“有”的意思没有被动。） 必须指出坚持很重要。 Persistence must be pointed out outstandingly crucial. 越来越多的人认为过度捕捞很严重。 Overfishing is claimed more than fearful by an increasing amount of professors. 人称代词做主语：I、you、we 如果有梦想，就应该会成功。 If there exists a dream, glories are supposed to be achieved. 3）宾语的词性① 宾语的成分：名词、代词、非谓语动词、从句 4）表语的词性① 表语的成分：名词、代词、非谓语动词、从句、形容词、介词短语 I am a teacher. My dream is to become a poet. My dream is becoming a poet. I am beautiful. I am in Chinese. 4. 简单句的考点分析1）写作 所有不会的长难句都暂时写成简单句，一定要保证语法正确。 所有不会写的单词都可以写成自己的单词。 2）长难句分析第一步找这句话当中的动词，也就是谓语，从而找到一句话的主谓宾。 如果一句话当中找到多个动词的时候，就确定主句的谓语动词。前面没有引导词的那个动词就是主句的动词。 这两天心里很不爽。 I feel upset these two days. 全球在变暖。 It is becoming warm throughout the world. 嫉妒本身就是一种仰望。 Jealousness is a kind of worship. 有意义就是好好活，好好活就是做有意义的事情。 Being meaningful proves to live well. Living well seems to do meaningful things. 二、并列句1. 什么是并列句就是用连词连接两个句子。 2. 常见的连词1）平行关系：and、not only…but also副词和介词短语：similarly、equally、likewise、at the same time、in the meanwhile 2）转折关系：but、yet、while、whereas副词和介词短语：however、nevertheless、conversely、unexpectedly、unfortunately、on the contrary、by contrast 3）选择关系：or、whether…or副词：alternatively 4）因果关系：for、so副词和介词短语：therefore、thus、consequently、as a result 5）递进关系：then副词和介词短语：besides、furthermore、moreover、additionally、subsequently、in addition 连词和其他的逻辑关系词的区别：连词的前面有无逗号均可，而其他的逻辑关系词前面，要么用句号，如果用逗号需要加连词and。 有朋自远方来，不亦乐乎。 There remain an army of companies coming from afar，and consequently，I feel more than delighted. 3. 并列句的考点分析1）写作只要写作的上下句之间有逻辑关系就一定要用逻辑关系词(连词、副词、介词、介词短语). 2）完形填空只需要读懂逻辑关系词前后两句话的意思。 3）长难句分析第二步找连词，但是连词在连接两个单词的时候，这个连词就装作没看见。 在分析长难句的时候，只要见到有并列连词的出现，通常都会有省略，翻译的时候先把省略的部分补上再翻译。那如何查找省略的内容呢？ 一句话只要有省略就一定会省略在连词后面而不是连词前面 ——&gt; 所以连词后面有的成分连词前面也通常都要有:如果连词后面只有一个成分的话，连词前一定能找到它的对应成分；如果连词后面有多个成分的话，连词前面不一定都能找到对应成分，但是至少可以找到一个。 ——&gt; 连词前面有而连词后面没有的成分便是省略的内容。 Until these issues are resolved，a technology of behavior will continue to be rejected，and will it possibly the only way to solve our problems （ will continue to be rejected）. it是代词指代题的做题方法：就近原则和一致原则，意思要一致。it指代a technology。 There is no agreement whether methodology refers to the concepts peculiar to historical work in general or（refers）to the research technique appropriate to the various branches of historical inquiry. peculiar = weird = odd 奇怪的，古怪的。 peculiar to …所特有的，…有专属的。 specific = concrete 具体的。 special 特殊的，特别的。 particular 特殊的，特别的。 particularly ≈ such as 三、名词和名词性从句1. 名词能够充当的成分：主语、宾语、表语、同位语(用来解释名词的成分就是同位语)只要在作文中见到名词，都可以有意识的在它后面加一个同位语，对该名词进行补充说明。 同位语的成分：名词、代词、非谓语动词、从句 坚持,一种积极的心态,在所有人的成功中扮演重要角色。 persistence，an active mentality，plays a critical role in the glories of all children and adults. 2. 什么是名词性从句：名词在句子中能够充当的成分，名词性从句都能充当，这就是名词性从句 What I saw is attractive.（主语从句） I appreciate what she said.（宾语从句） Gump is who should I learn from.（表语从句） I enjoy the part that a feather is flying in the sky.（同位语从句） 3. 名词性从句的引导词：⭐⭐⭐⭐⭐ 他离婚是我的错。 That he has got divorced is my fault. 他已经离婚了吗，是显而易见的。 Whether he has got divorced is obvious. 他会跟谁结婚呢，是个秘密。 Who he will marry is a secret. 名词性从句的引导词是按照从句的类型分的类，一共把引导词分词三类① that：当从句是陈述句时。并且 that 在从句中不充当任何成分，也没有任何意思。 ② whether：当从句是一般疑问句时。并且 whether 在从句中不充当任何成分，意思翻译成是否。 ③ 所以的特殊疑问词：当从句是特殊疑问句时。 并且英语中所有的从句都一定是陈述句的形式，也就是 引导词+主语+谓语 的形式 我正在思考外星人存在吗？ I am wondering whether aliens exist .（宾语从句） 女人总是对的是一个常识。 That ladies tend to be right remains common knowledge. （主语从句） 我的意思是孝敬父母是中华民族的传统美德。 My meaning seems that supporting the elderly remains a Chinese conventional virtue.（表语从句） 有一天，你会发现事业、亲情、友情都比爱情重要。 Someday，one will perceive that career,kinship and friendship prove more indispensable than romance.（that 引导的宾语从句） 关键是你什么时候有钱呢？ The point seems when wealth will become available for you. 4. 名词性从句的考点分析1）写作① 主语从句 主语从句的满分句型是：把主语从句放到句末，在前面加 it 作形式主语。动词不定式也是用it作形式主语。 女人总是对的是一个常识。 It remains common knowledge that ladies tend to be right . （主语从句） 学英语很简单。 It is easy to learn English. 几个满分句型：可以写在作文中任何一句话的前面用来拉长句子。 显而易见，众所周知 It is apparent that…. It looks beyond dispute that… It has been widely accepted that… It is universally acknowledged that… 我认为 It keeps my argument that… = I think… 显而易见，关于勤奋这个话题已经引起了广泛的关注了。 It looks beyond dispute that the issue about diligence has been brought into the limelight. ② 同位语从句 同位语从句既可以放在名词后面也可以放到整句话的后面，写作文最好放到名词后面，在长难句分析中经常看到在句末。 他已经找到了一个女朋友，这件事使他的家人开心。 The matter，that he managed to find a girlfriend，makes his superiors rejoiced. The matter makes his superiors rejoiced that he managed to find a girlfriend. 没有什么能够掩盖他正在变老这个事实。 Nothing can hide the truth that he is getting old. 河南人都是骗子这种想法都是错误的。 The outlook proves wrong that private individuals in HeNan seem all deceiver. 温室里的花朵不能经受风雨这个事实表示我们不应该溺爱孩子。 The evidence，that flowers in the greeenhouse fail to undergo storms，indicates that kids should by no means be spoiled by their senior citizens. 2）长难句分析能够识别各个名词性从句，并且把它们通顺的翻译出来。 ① 如何识别主语从句：只要见到有引导词放在句首，并且从句后没有被逗号隔开，就一定是主语从句。主语从句从句首开始到主句的谓语动词之前结束。除此以外，在分析长难句的时候，见到 It…that… 通常都是主语从句，主语从句从 that 开始到句末结束。 ② 如何识别宾语从句：只要实义动词的后面有引导词就暂定为宾语从句(状语从句还没有讲哟)。 ③ 如何识别表语从句：只要系动词的后面有引导词就是表语从句。 ④ 如何识别同位语从句：只要名词的后面有引导词就是暂定为同位语从句(更可能是定语从句哦)。 四、定语和定语从句1. 什么是定语只要听到”…的+名词”，”…的”就是修饰这个名词的定语成分。 2. 定语的成分形容词、名词、介词短语、非谓语动词、从句 善良的夜莺死了。 The innocent nightingale died. 善良又勇敢的夜莺死了。 The nightingale brave and innocent died. 夜莺的歌声能够使这朵花开放。 The singing of the nightingale can make the rose bloom. 窗外的夜莺听到了年轻人的歌声。 The nightingale out of the window heard the sighs of the youngster. 那只唱歌的夜莺失去了它的生命。 The singing nightingale lost his life. 夜莺用生命换来玫瑰花被扔掉了。 The rose that the nightingale exchanged with his life was discarded. 3. 定语的位置前小后大：当一个单词修饰名词通常放在名词前面，当多个单词修饰名词时通常放在名词后面。 这是一个关于夜莺和玫瑰的故事。 This is a fiction **about a nightingale and a rose.**（介词短语修饰名词） 那个懂爱的年轻人离开了王子的舞会。 The youngster grasping romance left the party of the prince. （非谓语动词和名词修饰名词） 被拒绝的那个男生看起来很可怜。 The boy rejected looks pitiful. (当过去分词修饰名词时，即使只有一个单词也通常放在名词后面)（非谓语动词修饰名词） 我有重要的事情告诉你。 I have something important to tell you. (当形容词修饰不定代词的时候，即使只有一个单词也通常放在名词后面)（形容词修饰名词） 4. 定语从句1）定语从句的构成：名词 + 引导词 + 句子2）定语从句的引导词：⭐⭐⭐⭐⭐A. 定语从句可以按照先行词的种类分的类，一共把引导词分词五类(8个)： ① 当先行词是人的时候，先行词有：who、whom、whose ② 当先行词是物的时候，引导词有：that、which、whose ③ 当先行词是时间的时候，引导词有：that、which、when ④ 当先行词是地点的时候，引导词有：that、which、where ⑤ 当先行词是原因的时候，引导词有：that、which、why 到底是谁决定引导词的用法：1. 先行词 2. 引导词在从句中能够充当的成分 共同决定了定语从句引导词的用法。 B. 定语从句的引导词还可以按照引导词本身的词性来分类，一共把引导词分词三类： ① 代词(在从句一定要充当主语或宾语的成分)：who、whom、that、which ② 副词(在从句中不能充当任何主干成分)：where、when、why ③ 形容词(在从句中修饰离它最近的那个名词)：whose 这些圆顶的建筑物看起来漂亮。 Buildings whose roofs are round look beautiful. 成功属于有梦想的人已经被无数个事实证明了。 It has been validated by numerous facts that glories belong to those with dreams. 穿自己的鞋不仅方便而且还确定了一点不用去考虑别人的感受。 Wearing my own shoes proves not only convenient but also ensures a point that the feelings of others can be ignored. 问题的关键是谁应该为道德沦丧负责呢。 The point of the issue seems who should be responsible for the decline of ethics. 外表看起来很邋遢的他其实内心很高尚。 He whose appearance looks indecent proves noble in his mind. 那些全力以赴去实现梦想的人，即使最终没有成功也不会感到遗憾，这是很重要的。 It seems indispensable that those who spare no efforts to realies their dreams never feel pitiful although glories fail to be achieved. 5. 定语从句的特殊用法1）that 在引导定语从句的时候，如果在从句中充当的是宾语，that 可以省略。在分析长难句的时候，如果见到有两个名词或者是代词直接放在一起，中间没有被连词或者标点符号隔开，通常都是省略了 that 的定语从句 我喜欢我妈妈给我买的这本书。 l enjoy the book (that) my mather bought for me. 2）区别限制和非限制性定语从句：在分析长难句的时候，非限制性定语从句就相当于插入语，可以完全不看 我喜欢冷冷，她很漂亮。 I love Lengleng， who is beautiful.（非限制性定语从句） 我喜欢漂亮的冷冷。 I love Lengleng who is beautiful.（限制性定语从句） 3）如果先行词和引导词之间有介词的话，人不用 who 用 whom，物不用 that 只能用 which He is the man who we should learn. He is the man from whom we should learn from. I will never forget the day when I met you. I will never forget the day on which I met you. 4）区别 the same…as 和 the same…that 引导的定语从句 He is the same man as I love.（像） He is the same man that I love.（是） 5）as 和 which 引导的非限制性定语从句：which 引导的非限制性定语从句可以修饰前面整个句子，as 也可以。但是 which 只能放到主句的后面，而as则可前可后 He enjoy talking with young ladies，which drives me mad. He enjoy talking with young ladies，as drives me mad. 6. 区别定语从句和同位语从句 I hava a dream that sounds funny.(定语从句) I hava a dream that I will bacome a rich lady.(同位语从句) 相同点：都是先行词+引导词+句子。 不同点：① 看从句本身的意思，定语从句是对前面名词的修饰，而同位语从句是对前面名词的解释。② 看引导词 that 在从句中是否充当了成分，同位语从句中 that 不充当任何成分，而定语从句中 that 是代词，要充当主语或宾语。③ 定语从句的先行词可以是所有的名词，而同位语从句的名称只能是抽象名词。④ 定语从句的引导词有8个，而同位语从句的引导词一般都是that. 7. 定语从句的至难点如何寻找先行词：必须能读懂这句话才知道先行词是什么 ① 定语从句的先行词是离它最近的那个名词。 ② 定语从句的先行词是它前面并列的几个名词。 ③ 定语从句的先行词是它前面的一个从句。 ④ 定语从句的先行词是它前面的整个句子。 ⑤ 定语从句和先行词中间被一坨东西隔开了。 8. 定语从句的考点分析1）写作 只有在作文中见到名词都可以有意识的给它加一个定语的成分把句子拉长。 Pets which look cute as well as healthy can reduce senior citizens loneliness. Reading books which keep beneficial to our physical and mental health can add knowledge of all children and adults. 万能定语： which/who look(看主语确定是复数还是单数) 形容词 as well as 形容词 复数+such as… 英汉差异对比：① 句子结构 ② 逻辑关系词的使用 ③ 英语多被动汉语多主动 ④ 英语多长句汉语多短句(a.非谓语动词 b.加连词 c.从句) 2）长难句分析能够找到一句话当中的定语成分，并且能够把它们通顺的翻译出来。如何找到定语呢？ 找定语的关键就说找名词，只要名词后面有一坨东西，只要这一坨东西不是动词，就暂定为是定语成分(还有可能是状语哦)，定语从名词后开始到主句的谓语动词之前结束，如果定语在主句的谓语动词之后的话，定语就从名词后开始通常到句末结束，如果定语后有连词的话，定语不是到句末结束而是到连词前结束。 一个大定语中通常都会有无数多个小定语，每一个小定语都是到下一个名词后结束，但是固定搭配除外。翻译从最后往前翻译(③的②的①的…)。 五、状语和状语从句1. 形容词和副词能够充当的成分形容词能够充当的成分：表语、定语 副词能够充当的成分：状语 副词修饰实义动词 副词修饰形容词 副词修饰副词 副词修饰整个句子 He cried sadly. He looks especially sad. He cried rather sadly. Actually,he cries. 2. 什么是状语状语就是在一句话当中修饰实义动词、修饰形容词、修饰副词以及修饰整个句子的成分。 状语在一句话当中除了名词不能修饰，什么成分都可以修饰。 3. 状语的成分1）副词作状语：She smiles sweetly2）介词短语作状语：He runs fast like a crazy dog3）非谓语动词作状语：He leaves,crying4）从句作状语：l will return the book as soon as l have read it4. 状语的位置随便放！！！ 5. 状语从句状语从句的引导词是按照引导词本身的意思分的类，一共把引导词分成九类： ① 时间状语从句：when = while = as 「当…的时候」(当 while 翻译成「当…的时候」后面要跟进行时态)、 before、after、since「自从」(主句必须使用完成时态)、the moment = as soon as、by the time、until、not…until「直到…才」 状语从句的时态问题：在所有的状语从句中，如果主句的动作和从句的动作都尚未发生的话，主句用一般将来时，从句用一般现在时表示将来。 当爱来临的时候，我要牵住她的手。 When love comes，l will hold her hands. 当爱来临的时候，我没有牵到她的手。 When love came，l failed to hold her hands. 区别 until 和 not…until：区别在于看主句的谓语动词是延续性动词还是瞬间动词，如果是延续性动词就用 until ,如果是瞬间动词就用 not…until。 l will wait here until you come. l will not leave until you come. 我意识到母亲的伟大直到我长大。 I did not realize the greatness of mothers until l grew up. when 引导的时间状语从句，如果主句的主语和从句的主语一致，并且从句的谓语动词有 be 动词，此时从句的主语和 be 动词可以同时省略。 When l was a kid，l enjoyed singing songs. ② 地点状语从句：where 这种树在潮湿的地方生长的很好。 This kind of trees grow well where it is moist(= in moist places ). 作地点状语的通常都是介词短语，很少是从句。 ③ 原因状语从句： ⑴ 引导词：because、as、since、in that、seeing that、considering that、now that、given that ⑵ 连词：for ⑶ 介词短语(+n./doing)：because of、due to、owing to、thanks to、for the sake of、as a reuslt of 因为他粗心，他出了一场事故。 He had a car accident because he was careless. He had a car accident for he was careless.（只能放到两句话中间） He had a car accident because of his carelessness. ④ 目的状语从句： ⑴ to = in order to = so as to （动词不定式+v.） ⑵ 引导词：so that(表示目的，通常放到句末不放到句首)、in order that(随便放) 为了看的更远，我们爬的更高。 We will ascend higher in order to overlook farther. We will ascend higher in order that we overlook farther. ⑤ 结果状语从句：so(+adj./adv.) … that、such(+n.) … that 「如此…以至于」 so … thta 替换 very，作文中只要看见 adj. / adv. 的地方，都可以写成「so … that」句型。 今天是如此的热以至于我都穿上裙子了。 It feels so hot today that I wear my dress. 我妈妈是如此善良以至于受到所有员工的尊重。 My mother proves so kind that she is respected by all her staff. ⑥ 让步状语从句：although = though = even though = even if 「虽然，尽管」(位置可以随便放)、as「虽然，尽管」（通常用倒装）、while「虽然，尽管，当…的时候，但是」(当 while 翻译成「虽然，尽管」 只能放到句首不能放到句中，当 while 翻译成「但是」 只能放到两句话中间，当 while 翻译成「当…的时候」后面要跟进行时态) as 引导的让步状语从句，从句的表语可以放在句首构成部分倒装。 虽然我很丑但是我很温柔。 As I seem ugly，l keep gentle. = Although/Though i seem ugly，I keep gentle. Ugly as I seem ，l keep gentle. 虽然这个图表看起来很简单，但是它背后的观点是很深刻的。 Simple as the chart looks, the outlook behind proves far-reaching —— national products become increasingly popular with Chinese customers. ⑦ 方式状语从句： ⑴ 从句：as = the way = as if/though「好像，似乎」 ⑵ 介词短语(+n.)： by、through、by means of、in … way、manner「以…的方式」 他看起来就像是冰做的一样。 He looks as if he were made of ice. ⑧ 条件状语从句：suppose that 「如果」、supposing that「如果」、if、unless = if not「除非」、provided that「如果」、as long as「只要，如果」、so long as「只要，如果」 只要有一丝希望，我也不会放弃。 If there seems a ghost of holp I will never give up. ⑨ 比较状语从句：as … as … (原级比较) 、than 你看起来和我一样漂亮。 You are as beautiful as I（am beautiful ）. 6. 状语从句的考点分析1）写作作文中任何一句话的旁边都可以加一个状语成分把句子拉长。 你可以像猪一样生活，但是你永远不会像猪一样快乐。 One can live as if he were a pig conversely，he can never be as delighted as a pig. 2）长难句分析能够快速的识别一句话当中的状语成分，并且能够把它们通顺的翻译出来。如何识别状语呢？ 一句话当中，除了句子的主干和定语以外，其他部分都可以认为是状语。 具体识别状语：只要在句子中见到以下的一坨东西就一定是状语： 副词 比较状语 条件状语 原因状语 结果状语 让步状语 目的状语 方式状语 伴随状语：with 「名词 + 时间/地点」需要区别是定语还是状语：如果无法确定是定语还是状语的时候，以定语优先原则，只有翻译成定语时读起来巨恶心无比的时候才翻译成状语。 I love a boy in ZheJiang University. 7. 补充状语从句的特殊用法1）as 意思总结 as + n. ：as 的意思翻译成「作为」。 v. + n. + as ：此时 as 的意思取决于前面动词的意思。 as + 句子 ：可能是引导状语从句，as 的意思可以翻译成「当…的时候，因为，虽然/尽管，好像/似乎，(比较级) 和…一样」,具体翻译成什么意思取决于前后两句话的意思。as 还可能是引导定语从句。 2）than 意思总结 not so much as = not even 「甚至不/没有」 He can not so much as spell a word. He did not so much as ask me to sit down. not so much A as B 「与其说A倒不如说B」 与其说他是一个老师倒不如说他是一个诗人。 He is not so much a teacher as a poet. more A than B 「与其说B不如说A」 与其说他是一个老师倒不如说他是一个诗人。 He is more a poet than a teacher. more than + n. 「不仅仅是」 more than + adj./adv. 「非常的」 more than + 数词 「多余」 六、英语的特殊结构1. 强调句型『It is/was … that …』 时态是过去式用 was ，其他时态都是 is；强调句型可以强调句子中所有成分，唯一不能强调谓语动词。 我昨天在街上遇到了我的旧情人。 I met my old flame in the street yesterday. It was l that met my old flame in the street yesterday. It was yesterday that I met my old flame in the street. It was my old flame that I met in the street yesterday. 写作：写作中所有句子都可以写成强调句型。 你至今仍然没有意识到就是因为你交友不慎，你才没有考上心目中理想的大学。 Sofar，you have never realized that it was because you had unfavorable friends that you failed to go to your dream university. 长难句分析：It is/was … that … 「就是…」 2. 倒装句型1）什么是倒装句型：倒装就是把一句话写成一般疑问句的形式，也就是给一句话加个助动词或者把 be 动词放在句首。翻译的时候变成非倒装句型再翻译。 你爱我吗？ Do you love me? 你去过欧洲吗？ Have you ever been to Europe? 你爸爸是老师吗？ Is your father a teacher? 2）倒装的具体用法： 否定词放在句首用倒装 我几乎不会说日语。 Hardly can I speak Japanese. so，nor/neither 位于句首，表明承前句子的肯定或否定时用倒装。 I can cook. So can I. I can not cook. Nor can I. so…that 句型把 so 引导的部分放在句首时用倒装。 She looks so gorgeous that she can catch the eyes of everyone. So gorgeous does she look that she can catch the eyes of everyone. only 引出的状语位于句首时用倒装。 His girlfriend called his name only once. Only once did his girlfriend call his name. as 引导让步状语从句，从句的表语放在句首用倒装。 省略 if 的虚拟语气用倒装。 If you had obeyed my instruction = had you obeyed my instruction If I remembered you in my next life = did I remember you in my next life 3. 虚拟语气什么是虚拟语气：虚拟语气表示与事实相反或者是语气委婉。翻译的时候虚拟和非虚拟都是直接翻译。 1）虚拟语气的一般用法： if 引导的条件状语从句 如果你是我眼中的一滴泪，我就永远不会哭泣。 If you are a tear in my eyes，I will never shed it. 如果我是一条狗，我就可以和你们睡在一起了。 If I was a dog，I could sleep with you in bed. 如何把条件状语从句变成虚拟语气呢？只需要把已经写好的句子的时态变成它的过去式就可以了。并且在虚拟语气中，be 动词的过去式只有 were 没有 was，还并且 could = would = might。 如果你是我眼中的一滴泪，我就永远不会哭泣。 If you were a tear in my eyes，I would never shed it. 如果我是一条狗，我就可以和你们睡一起了。 If I had been a dog，I could have slept with you in bed. 如果下辈子我还记得你，我们死都要在一起。 If I remembered you in my next life，we would never seperate with each other. 如果当初你听我的话，你就能够顺利的通过这次考试了。 If you had obeyed my instruction at the outset，you could have passed the examination. 2）虚拟语气的特殊用法： 以下情况 从句用「should+v.」表示虚拟，并且 should 可以省略。 以防：incase、lest、for fear that 命：order、direct、command 建议：advise、suggest、propose 要求：ask、request、demand、require 用虚拟 是必要的：it is necessary/important that 以防你会传染到严重的传染病，你最好呆在家里。 In case that you should develop fatal infections，you had better stay at home. 以下情况从句用过去式表示虚拟：「would rather」和「it is high time that…」 是时候培养孩子独立性的时候了。 it is high time that the independance of kids were cultivated by senior citizens. 以下情况要区别对待：就是把它本来的时态变成过去式就可以了。wish 「希望」、if only 「如果…该多好」、but for「要不是」、or/otherwise「否则」、as if/as though「好像/似乎」 如果我是你的孩子就好了。 If only I were your child. 4. 情态动词情态动词是表明说话人主观态度的词汇，情态动词后面加动词原形，情态动词相当于助动词。 1）情态动词表示对现在和将来的推测：情态动词+动词原形 2）情态动词表示对过去的推测： must have done：「一定做过某事」(must 否定形式：can not)(must not「禁止做某事」) need not have done：「本没必要做某事，但是做了」 could have done：「本能够做某事，但却没有做，表示遗憾」 should have done：「本应该做某事，但却没有做」 他大学的时候一定很自卑。 He must have been self-biased in his university. 你本没必要以这种方式向我表白。 You need not have shown your love in this way. 我本能够成为一名优秀的诗人。 I could have become a prominent poet. 如果有缘分的话我早就结婚了。 We should have got married if there exists a chance. 七、句子所有成分大总结主语：名词、代词、非谓语动词、从句谓语：实义动词、系动词宾语：名词、代词、非谓语动词、从句表语：名词、代词、非谓语动词、从句、形容词、介词短语同位语：名词、代词、非谓语动词、从句定语：名词、代词、非谓语动词、从句、形容词、介词短语状语：副词、介词短语、非谓语动词、从句 My mother is an elegant lady. My mother is a lady of elegance. My mother is a lady as elegant as a lily. My mother is a lady looking as elegant as a lily. My mother is a lady who looks as elegant as a lily. That I met you is my honor = Meeting you is my honor. 英语长难句的模样（状语/定语），主语 （定语/同位语/状语）谓语 宾语（定语/同位语/状语） English，a universal language throughout the world，is vital although it is hard to recite these words. I，a undergraduate in this university， will recommend you a tourist attraction which keeps popular with Chinese travelers. 总结分析长难句的时候，先把「主谓宾定状同补 」找到，然后分部分翻译好，然后用中国人的说话习惯调整顺序把整句话翻译好。 第一步：找主句的谓语动词，从而找到主谓宾。 第二步：找连词，看看有没有省略。 第三步：找定语。 第四步：找状语。","link":"/2019/09/19/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E9%95%BF%E9%9A%BE%E5%8F%A5/"},{"title":"CSS 选择器","text":"常用的选择器类型： 选择器名称 选择的内容 示例 元素选择器（也称作标签或类型选择器） 所有指定类型的 HTML 元素 p 选择 &lt;p&gt; 全局选择器 选中了文档中的所有内容 * ID 选择器 具有特定 ID 的元素。单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID #my-id 选择 &lt;p id=&quot;my-id&quot;&gt; 或 &lt;a id=&quot;my-id&quot;&gt; 类选择器 具有特定类的元素。单一页面中，一个类可以有多个实例 .my-class 选择&lt;p class=&quot;my-class&quot;&gt; 和 &lt;a class=&quot;my-class&quot;&gt; 指向特定元素的类 建立一个指向应用一个类的特定元素 span.highlight { *background-color: yellow;***}**选择所有 &lt;span&gt; 元素中带有 “highlight” 类的元素 属性选择器 拥有特定属性的元素 img[src] 选择 &lt;img src=&quot;myimage.png&quot;&gt; 但不是 &lt;img&gt; 伪类选择器 特定状态下的特定元素（比如鼠标指针悬停于链接之上） a:hover 选择仅在鼠标指针悬停在链接上时的 &lt;a&gt; 元素 关系选择器 可以将其他选择器组合起来，更复杂的选择元素 article &gt; p选择所有直接位于 &lt;article&gt;元素内的 &lt;p&gt; 元素，而不包括嵌套在更深层次的其他元素中的 &lt;p&gt; 元素。 选择器列表如果你有多个使用相同样式的 CSS 选择器，那么这些单独的选择器可以被混编为一个“选择器列表”，这样，规则就可以应用到所有的单个选择器上了。例如，如果我的h1和.special类有相同的 CSS，那么我可以把它们写成两个分开的规则。 1234567h1 { color: blue;}.special { color: blue;} 也可以将它们组合起来，在它们之间加上一个逗号，变为选择器列表。 1234h1, .special { color: blue;} 属性选择器存否和值选择器这些选择器允许基于一个元素自身是否存在（例如href）或者基于各式不同的按属性值的匹配，来选取元素。 选择器 示例 描述 [attr] a[title] 匹配带有一个名为attr的属性的元素——方括号里的值。 [attr=value] a[href=”","link":"/2020/10/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E9%80%89%E6%8B%A9%E5%99%A8/"},{"title":"CSS 基本语法","text":"HTML 中引入 CSS 的方式有 4 种方式可以在 HTML 中引入 CSS。其中有 2 种方式是在 HTML 文件中直接添加 CSS 代码，另外两种是引入 外部 CSS 文件。下面我们就来看看这些方式和它们的优缺点。 内联方式内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS。 示例： 1&lt;div style=&quot;background: red&quot;&gt;&lt;/div&gt; 这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个&lt;div&gt; 拥有相同的样式，你不得不重复地为每个 &lt;div&gt; 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。 嵌入方式嵌入方式指的是在 HTML 头部中的 &lt;style&gt; 标签下书写 CSS 代码。 示例： 123&lt;head&gt; &lt;style&gt;.content { background: red; } &lt;/style&gt; &lt;/head&gt; 嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。 链接方式链接方式指的是使用 HTML 头部的 &lt;head&gt; 标签引入外部的 CSS 文件。 示例： 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; 这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。 导入方式导入方式指的是使用 CSS 规则引入外部 CSS 文件。 示例： 123&lt;style&gt; @import url(style.css);&lt;/style&gt; 比较链接方式和导入方式链接方式（下面用 link 代替）和导入方式（下面用 @import 代替）都是引入外部的 CSS 文件的方式，下面我们来比较这两种方式，并且说明为什么不推荐使用 @import。 link 属于 HTML，通过 &lt;link&gt;标签中的 href 属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件； @import 是 CSS2.1 才出现的概念，所以如果浏览器版本较低，无法正确导入外部样式文件； 当 HTML 文件被加载时，link 引用的文件会同时被加载，而 @import 引用的文件则会等页面全部下载完毕再被加载； 小结：我们应尽量使用&lt;link&gt; 标签导入外部 CSS 文件，避免或者少用使用其他三种方式。 @ 规则CSS 的 @rules（读作“at-rules”）是一些特殊的规则，提供了关于 CSS 应该执行什么或如何表现的指令。有些@规则很简单，只有一个关键词和一个值。例如，@import 将一个样式表导入另一个 CSS 样式表： 1@import &quot;styles2.css&quot;; 一个常见的@规则是 @media，它被用来创建媒体查询。媒体查询使用条件逻辑来应用 CSS 样式。 在下面的例子中，样式表为 &lt;body&gt; 元素定义了一个默认的粉红色背景。然而，如果浏览器的视口宽于 30em，接下来的媒体查询则定义了蓝色背景。 123456789body { background-color: pink;}@media (min-width: 30em) { body { background-color: blue; }} 层叠、优先级和继承CSS 语言有一些规则来控制在发生冲突的情况下哪个选择器更强大。这些规则被称为层叠（cascade）和优先级（specificity）。也有继承的概念，也就是在默认情况下，一些 css 属性继承当前元素的父元素上设置的值，有些则不继承。这也可能导致一些和期望不同的结果。 层叠样式表层叠——简单的说，就是 CSS 规则的顺序很重要；当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。 层叠：后面的样式会替换样式表中较早出现的冲突样式。 有三个因素需要考虑，根据重要性排序如下，后面的更重要： 资源顺序 如果你有超过一条规则，而且都是相同的权重，那么最后面的规则会应用。可以理解为后面的规则覆盖前面的规则，直到最后一个开始设置样式。资源顺序仅在规则的优先级相同时才体现出来。 优先级 在一些情况下，有些规则在最后出现，但是却应用了前面的具有冲突的规则。这是因为前面的有更高的优先级——它范围更小，因此浏览器就把它选择为元素的样式。 类选择器的权重大于元素选择器，因此类上定义的属性将覆盖应用于元素上的属性。 一种常见的做法是给基本元素定义通用样式，然后给不同的元素创建对应的类。 本质上，不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。一个选择器的优先级可以说是由三个不同的值（或分量）相加，可以认为是百（ID）十（类）个（元素）——三位数的三个位数： ID：选择器中包含 ID 选择器则百位得一分。 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分。 元素：选择器中包含元素、伪元素选择器则个位得一分。 选择器 ID 类 元素 优先级 h1 0 0 1 0-0-1 h1 + p::first-letter 0 0 3 0-0-3 li &gt; a[href*=”en-US”] &gt; .inline-warning 0 2 2 0-2-2 #identifier 1 0 0 1-0-0 button:not(#mainBtn, .cta) 1 0 1 1-0-1 备注： 通用选择器（*）、组合符（+、&gt;、~、’ ‘）和调整优先级的选择器（:where()）不会影响优先级。 重要程度 内联样式，即style属性内的样式声明，优先于所有普通的样式，无论其优先级如何。这样的声明没有选择器，但它们的优先级可以理解为 1-0-0-0；即无论选择器中有多少个 ID，它总是比其他任何优先级的权重都要高。 !important，有一个特殊的 CSS 可以用来覆盖所有上面所有优先级计算，不过需要很小心的使用。用于修改特定属性的值，能够覆盖普通规则的层叠。 了解 !important 是为了在阅读别人代码的时候知道有什么作用。但是，强烈建议除了非常情况不要使用它。!important 改变了层叠的常规工作方式，它会使调试 CSS 问题非常困难，特别是在大型样式表中。 优先级浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度： 一个元素选择器不是很具体，则会选择页面上该类型的所有元素，所以它的优先级就会低一些。 一个类选择器稍微具体点，则会选择该页面中有特定 class 属性值的元素，所以它的优先级就要高一点。 优先级：类选择器&gt;元素选择器 继承继承也需要在上下文中去理解——一些设置在父元素上的 CSS 属性是可以被子元素继承的，有些则不能。 像 width、margin、padding 和 border 不会被继承。 CSS 为控制继承提供了五个特殊的通用属性值。 inherit：设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。 initial：将应用于选定元素的属性值设置为该属性的初始值。 unset：将属性重置为自然值，也就是如果属性是自然继承那么就是inherit，否则和 initial 一样。 revert：将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。 revert-layer：将应用于选定元素的属性值重置为在上一个层叠层中建立的值。 CSS 的简写属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个（inherit、initial、unset 或 revert）。这是一种撤销对样式所做更改的简便方法，以便回到之前已知的起点。 层叠层使用来自多个源的 CSS，或当存在冲突的 CSS 选择器和竞争优先级时，又或者当你考虑使用 !important(en-US) 时，层叠层最为相关。 有三种层叠来源类型：用户代理样式表、用户样式表和作者样式表。“用户代理”指的是浏览器。“用户”指的是是网站访问者。“作者”指的是你，开发者。 层叠层的优先权顺序类似于我们有六个基于来源和重要性的优先权级别，层叠层使我们能够在这些来源中创建子来源级别的优先权。 在六个来源中的每一个，都可以有多个层叠层。层创建的顺序非常重要。层创建的顺序确定了同一来源内层的优先权顺序。 在普通来源中，层按照创建的顺序排序。优先权顺序是从首个创建的层到最后一个层，然后是未分层的普通样式。 对于重要样式，这个顺序是相反的。所有未分层的重要样式会层叠在一起，形成一个隐式层，优先权高于所有非过渡的普通样式。未分层的重要样式的优先权低于任何重要分层样式。在同一来源内，先前声明的层中的重要样式优先于后续声明的层中的重要样式。 层叠层可以解决的问题大型代码库可能会有来自多个团队、组件库、框架和第三方的样式。无论包含了多少样式表，所有这些样式都会层叠在一个单一的来源中：作者样式表。 将许多来源的样式层叠在一起，特别是来自不同团队的样式，可能会导致问题。优先级冲突可能会迅速升级。Web 开发人员可能通过添加 !important 标志来进行“快速修复”。虽然这可能看起来是一种简单的解决方案，但它通常只是将优先级战争从普通声明转移到重要声明。 就像层叠来源在用户、用户代理和作者样式之间提供了力量平衡一样，层叠层提供了一种结构化的方式来组织和平衡单一来源内的关注点，就好像来源中的每个层都是一个子来源。可以为每个团队、组件和第三方创建一个层，其中的样式优先权基于层的顺序。 层内的规则层叠在一起，而不会与层外的样式规则竞争。层叠层使得可以优先考虑整个样式表而不必担心这些子来源之间的优先级。层的优先权始终高于选择器的优先级。 嵌套层叠层可以解决的问题层叠层允许创建嵌套层。每个层叠层可以包含嵌套层。 嵌套层的能力非常适用于开发组件库、框架、第三方小部件和主题的任何人。 创建层叠层可以使用以下任一方法创建层叠层： 使用 @layer 声明 at 规则，使用 @layer 后跟一个或多个层的名称来声明层。这将创建一个没有分配任何样式的具名层。 使用 @layer 块 at 规则，在块中的所有样式都将添加到一个命名或未命名的层中。 使用具有 layer 关键字或 layer() 函数的 @import 规则，将导入文件的内容分配到该层中。 用于具名层的 @layer 声明 at 规则使用 @layer 后跟一个或多个层的名称而不分配任何样式是定义层顺序的一种方式。 1@layer theme，layout，utilities; 如果上述声明是站点 CSS 的第一行，那么层的顺序将是 theme、layout 和 utilities。如果在上述语句之前已经创建了一些层，只要同名的层还不存在，这三个层就会被创建并添加到现有层列表的末尾。但是，如果同名的层已经存在，那么上述语句只会创建两个新层。例如，如果 layout 已经存在，只会创建 theme 和 utilities, 但在这种情况下的层顺序将是 layout、theme 和 utilities。 优先级从前到后越来越高，utilities优先级最高。 用于具名层和匿名层的 @layer 块 at 规则如果在使用 @layer 创建块样式时没有指定名称，则该规则中的样式将被添加到一个新的匿名层中。 示例中，使用了四个块和一个内联的 @layer at 规则： 创建一个命名的 layout 层 创建一个未命名的匿名层 声明三个层的列表并只创建两个新层 theme 和 utilities，因为 layout 已经存在 向已经存在的 layout 层添加额外的样式 创建第二个未命名的匿名层 123456789101112131415161718192021222324252627282930313233343536/* 文件：layers1.css *//* 未分层的样式 */body { color: #333;}/* 创建第一个层：`layout` */@layer layout { main { display: grid; }}/* 创建第二个层：一个未命名的匿名层 */@layer { body { margin: 0; }}/* 创建第三和第四个层：`theme` 和 `utilities` */@layer theme，layout，utilities；/* 向已经存在的 `layout` 层添加样式 */@layer layout { main { color: #000; }}/* 创建第五个层：一个未命名的匿名层 */@layer { body { margin: 1vw; }} 在上面的 CSS 中，我们创建了五个层：layout、&lt;anonymous(01)&gt;、theme、utilities 和 &lt;anonymous(02)&gt;——按这个顺序——第六个隐含的未分层样式层包含在 body 样式块中。层的顺序是层的创建顺序，前面的优先级低于后面的优先级。未分层样式的隐含层总是在最后的，优先级最高。一旦创建了层之后就无法改变层的顺序。 层创建和媒体查询如果你使用媒体或特性查询来定义层，且媒体不匹配或特征不被支持，则不会创建该层。 下面的示例展示了改变设备或浏览器的尺寸可能会改变层的顺序： 1234567891011121314151617@media (min-width: 50em) { @layer site;}@layer page { h1 { text-decoration: overline; color: red; }}@layer site { h1 { text-decoration: underline; color: green; }} 在宽屏上，site 层在第一行被声明，这意味着 site 的优先权低于 page。否则在窄屏上，site 的优先权高于 page，因为它在后面被声明。 使用 @import 将样式表导入具名层和匿名层@import 规则允许用户直接从其他样式表导入样式规则到 CSS 文件或&lt;style&gt; 元素中。 可以将样式表导入具名层、嵌套具名层或匿名层。 以下层分别将样式表导入 components 层、components 层中的嵌套 dialog 层和一个未命名层： 123@import url(&quot;components-lib.css&quot;) layer(components);@import url(&quot;dialog.css&quot;) layer(components.dialog);@import url(&quot;marketing.css&quot;) layer(); 你可以使用媒体查询和特性查询根据特定条件导入样式并创建层。 以下将样式表导入到 international 层，但前提是浏览器支持 display: ruby，而且被导入的文件取决于屏幕的宽度。 1234@import url(&quot;ruby-narrow.css&quot;) layer(international) supports(display: ruby) and (width &lt; 32rem);@import url(&quot;ruby-wide.css&quot;) layer(international) supports(display: ruby) and (width &gt;= 32rem); 嵌套层的概述嵌套层是具名层或匿名层中的子层。每个层叠层（即使是匿名的）都可以包含嵌套层。导入到另一个层中的层会成为该层中的嵌套层。 嵌套层的优点嵌套层的能力使团队可以创建层叠层，而不用担心其他团队会将它们导入到一个层中。同样，嵌套使你可以将第三方样式表导入到一个层中，而不用担心该样式表本身是否具有层。因为层可以嵌套，所以你不必担心外部和内部样式表之间会有冲突的层名称。 创建嵌套层叠层嵌套层可以使用与常规层相同的方法创建。例如，可以使用点表示法，在 @layer 规则后跟一个或多个层名称来创建。多个点和层名称表示多重嵌套。 12@import url(&quot;components-lib.css&quot;) layer(components);@import url(&quot;narrowtheme.css&quot;) layer(components.narrow); 在第一行中，我们将 components-lib.css 导入 components 层。如果该文件包含任何层，无论命名与否，这些层都会成为 components 层中的嵌套层。 第二行将 narrowtheme.css 导入 narrow 层，narrow 是 components 的子层。嵌套的 components.narrow 会作为 components 层中的最后一个层创建，除非 components-lib.css 已经包含一个 narrow 层，在这种情况下，narrowtheme.css 的内容会被附加到 components.narrow 嵌套层。可以使用 components.&lt;layerName&gt; 模式向 components 层添加更多命名嵌套层。如前所述，可以创建未命名层，但随后无法访问它们。 根据层的顺序确定优先权层的顺序决定了它们的优先权顺序。因此，层的顺序非常重要。与层叠根据来源和重要性进行排序的方式相同，层叠也会根据来源层和重要性对每个 CSS 声明进行排序。 常规层叠层的优先权顺序123@import url(A.css) layer(firstLayer);@import url(B.css) layer(secondLayer);@import url(C.css); 上述代码创建了两个具名层和一个未命名层。假设这三个文件（A.css、 B.css 和 C.css）本身不包含任何额外的层。以下列表显示了在这些文件内外声明的样式将以从最低（1）优先权到最高（10）优先权进行排序。 firstLayer 普通样式（A.css） secondLayer 普通样式（B.css） 未分层普通样式（C.css） 内联普通样式 动画样式 未分层重要样式（C.css） secondLayer 重要样式（B.css） firstLayer 重要样式（A.css） 内联重要样式 过渡样式 在层中声明的普通样式具有最低的优先权，并按照创建层的顺序进行排序。在最先创建的层中声明的普通样式具有最低的优先权，而在最后创建的层中声明的普通样式在所有层中具有最高的优先权。换句话说，如果存在冲突的话，在 firstLayer 中声明的普通样式将被列表中任何后续的样式覆盖。 接下来是在层外声明的任何样式。C.css 中的样式没有导入到层中，并将覆盖任何来自 firstLayer 和 secondLayer 的冲突样式。在层外声明的普通样式总是比层内的普通样式具有更高的优先权。 过渡样式具有最高的优先权。当正在过渡普通属性值时，它优先于所有其他属性值声明，甚至是内联重要样式；但是只在过渡时。 总结： 层的优先权顺序是创建层的顺序。 一旦创建，就无法更改层顺序。 普通样式的层优先权是创建层的顺序。 未分层普通样式优先于有层普通样式。 重要样式的层优先权被反转，早期创建的层具有优先权。 所有有层的重要样式都优先于未分层的重要（和普通）样式。 普通内联样式优先于所有普通样式，无论是否分层。 重要内联样式优先于所有其他样式，正在过渡的样式除外。 作者样式无法覆盖重要内联样式（过渡除外，但这是临时的）。 嵌套层叠层的优先权顺序嵌套层的层叠优先权顺序与常规层类似，但包含在层内。优先权顺序基于嵌套层创建的顺序。层中的非嵌套样式优先于嵌套的普通样式，对于重要样式则相反。嵌套层之间的优先级权重并不重要，但它在嵌套层内的冲突样式中确实很重要。 下面创建并向 components 层和 components.narrow 嵌套层添加样式，然后创建并追加样式到新的 components.wide 层： 123456789101112131415161718192021@import url(&quot;components-lib.css&quot;) layer(components);@import url(&quot;narrowtheme.css&quot;) layer(components.narrow);@layer components { :root { --theme: red; font-family: serif !important; }}@layer components.narrow { :root { --theme: blue; font-family: sans-serif !important; }}@layer components.wide { :root { --theme: purple; font-family: cursive !important; }} 因为未分层普通样式优先于分层普通样式，并且在层内，非嵌套样式优先于普通嵌套样式，所以 red 优先于其他 theme 颜色。 对于重要样式，分层样式优先于未分层样式，并且早期声明的层中的重要样式优先于后来声明的层。在这个例子中，嵌套层的创建顺序是 components.narrow，然后是 components.wide，所以 components.narrow 中的重要样式优先于 components.wide 中的重要样式，这意味着 sans-serif 获胜。 盒模型块级盒子（Block box）和 内联盒子（Inline box）在 CSS 中我们广泛地使用两种“盒子” —— 块级盒子 (block box) 和 内联盒子 (inline box)。这两种盒子会在页面流（page flow）和元素之间的关系方面表现出不同的行为： 一个被定义成块级的（block）盒子会表现出以下行为： 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽 每个盒子都会换行 width 和 height 属性可以发挥作用 内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开” 除非特殊指定，诸如标题 (&lt;h1&gt;等) 和段落 (&lt;p&gt;) 默认情况下都是块级的盒子。 如果一个盒子对外显示为 inline，那么他的行为如下： 盒子不会产生换行。 width 和 height 属性将不起作用。 垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。 水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。 用做链接的 &lt;a&gt; 元素、&lt;span&gt;、 &lt;em&gt; 以及 &lt;strong&gt; 都是默认处于 inline 状态的。 通过对盒子display 属性的设置，比如 inline 或者 block ，来控制盒子的外部显示类型。 什么是 CSS 盒模型完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。 盒模型的各个部分CSS 中组成一个块级盒子需要： Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height. Padding box: 包围在内容区域外部的空白区域；大小通过 padding 相关属性设置。 Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。 Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。 标准盒模型在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。见下图。 假设定义了 width, height, margin, border, and padding: 1234567.box { width: 350px; height: 150px; margin: 25px; padding: 25px; border: 5px solid black;} 如果使用标准模型，实际占用空间的宽高分别为：宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)。 margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。 替代（IE）盒模型css 还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px). 默认浏览器会使用标准模型。如果需要使用替代模型，你可以通过为其设置 box-sizing: border-box 来实现。这样就可以告诉浏览器使用 border-box 来定义区域，从而设定你想要的大小。 外边距折叠理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。 在下面的例子中，我们有两个段落。顶部段落的页 margin-bottom为 50px。第二段的margin-top 为 30px。因为外边距折叠的概念，所以框之间的实际外边距是 50px，而不是两个外边距的总和。 使用 display: inline-blockdisplay 有一个特殊的值，它在内联和块之间提供了一个中间状态。这对于以下情况非常有用：你不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。 一个元素使用 display: inline-block，实现我们需要的块级的部分效果： 设置width 和height 属性会生效。 padding, margin, 以及border 会推开其他元素。 但是，它不会跳转到新行，如果显式添加 width 和 height 属性，它只会变得比其内容更大。 当你想要通过添加内边距使链接具有更大的命中区域时，这是很有用的。&lt;a&gt; 是像 &lt;span&gt;一样的内联元素；你可以使用 display: inline-block 来设置内边距，让用户更容易点击链接。 这种情况在导航栏中很常见。 背景控制背景平铺行为background-repeat 属性用于控制图像的平铺行为。可用的值是： no-repeat——阻止背景重复平铺。 repeat-x——仅水平方向上重复平铺。 repeat-y——仅垂直方向上重复平铺。 repeat——默认值，在水平和垂直两个方向重复平铺。 调整背景图像的大小使用 background-size 属性，它可以设置长度或百分比值，来调整图像的大小以适应背景。 也可以使用关键字： cover：浏览器将使图像足够大，使它完全覆盖了盒子区域，同时仍然保持其宽高比。在这种情况下，图像的部分区域可能会跳出盒子外。 contain：浏览器会将图像调整到适合框内的尺寸。在这种情况下，如果图像的长宽比与盒子的长宽比不同，你可能会在图像的两边或顶部和底部出现空隙。 背景图像定位background-position 属性允许你选择背景图片出现在它所应用的盒子上的位置。这使用了一个坐标系统，其中方框的左上角是 (0,0)，方框沿水平（x）和垂直（y）轴定位。 默认的 background-position 值是 (0,0)。 渐变背景当渐变用于背景时，也可以使用像图像一样的 background-image 属性设置。 &lt;gradient&gt; 数据类型是由下面列出的函数类型中的一个定义的。 线性渐变 线性渐变会在一个假想的直线上过渡颜色。线性渐变是由 linear-gradient() 函数产生的。 径向渐变 径向渐变从一个中间点（原点）开始过渡颜色。径向渐变是由 radial-gradient() 函数产生的。 重复渐变 重复渐变可根据需要复制渐变，以填充指定区域。重复渐变是使用 repeating-linear-gradient() 和 repeating-radial-gradient() 函数生成的。 锥形渐变 锥形渐变会沿着一个圆过渡颜色。锥形渐变是由 conic-gradient() 函数产生的。 多个背景图像也可以有多个背景图像——在单个属性值中指定多个 background-image 值，用逗号分隔每个值。 当你这样做时，你可能会出现背景图片相互重叠的情况。背景将分层，最后列出的背景图片位于最下层，而之前的每张图片都堆在代码中紧随其后的那张图片之上。 渐变可以与常规的背景图像很好地混合在一起。 背景附加为背景提供的另一个选项是指定内容滚动时的滚动方式。这是用 background-attachment 属性控制的，它可以取以下值： scroll：使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。 fixed：使元素的背景固定在视口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。 local：将背景固定在它所设置的元素上，所以当你滚动该元素时，背景也随之滚动。 使用 background 简写属性在简写背景图像属性时遵循，例如： background-color 只能在最后一个逗号之后指定。 background-size 值只能立即包含在 background-position 之后，用“/”字符分隔，例如：center/80%。 处理不同方向的文本使用writing-mode: vertical-rl对一个标题的显示进行设置。现在，标题文本是竖向的了。 123h1 { writing-mode: vertical-rl;} writing-mode的三个值分别是： horizontal-tb: 块流向从上至下。对应的文本方向是横向的。 vertical-rl: 块流向从右向左。对应的文本方向是纵向的。 vertical-lr: 块流向从左向右。对应的文本方向是纵向的。 逻辑属性和逻辑值两个盒子——一个用horizontal-tb设定了书写模式，一个用vertical-rl设定了书写模式。我为这两个盒子分别设定了宽度（ width）。可以看到，当盒子处于纵向书写模式下时，宽度也发生了变化，从而导致文本超出了盒子的范围。 当处于纵向书写模式之下时，我们希望盒子可以向横向模式下一样得到拓宽。 为了更容易实现这样的转变，CSS 最近开发了一系列映射属性。这些属性用逻辑（logical）和相对变化（flow relative）代替了像宽width和高height一样的物理属性。 横向书写模式下，映射到width的属性被称作内联尺寸（inline-size）——内联维度的尺寸。而映射height的属性被称为块级尺寸（block-size），这是块级维度的尺寸。 逻辑外边距、边框和内边距属性margin-top属性的映射是margin-block-start——总是指向块级维度开始处的边距。 padding-left属性映射到 padding-inline-start，这是应用到内联开始方向（这是该书写模式文本开始的地方）上的内边距。 border-bottom属性映射到的是border-block-end，也就是块级维度结尾处的边框。 逻辑值有一些属性的取值是一些物理值（如top、right、bottom和left）。这些值同样拥有逻辑值映射（block-start、inline-end、block-end和inline-start） 溢出的内容（BFC）什么是溢出？CSS 中万物皆盒，因此我们可以通过给 width 和 height（或者 inline-size 和 block-size）赋值的方式来约束盒子的尺寸。溢出是在你往盒子里面塞太多东西的时候发生的，所以盒子里面的东西也不会老老实实待着。 CSS 尽力减少“数据损失”只要有可能，CSS 就不会隐藏你的内容，隐藏引起的数据损失通常会造成困扰。在 CSS 的术语里面，这会导致一些内容消失，你的访客可能不会注意到这一点，如果消失的是表格上的提交按钮，没有人能填完这个表格，这是很麻烦的事情！所以 CSS 反而会把它以可见的形式溢出出去。这样做的结果就是，你会看到错误的 CSS 导致的一片混乱，或者最坏的情况也只是你的网站的访客会告诉你有些内容冒了出来，你的网站需要修缮。 overflow 属性overflow属性是你控制一个元素溢出的方式，它告诉浏览器你想怎样处理溢出。 overflow 的默认值为 visible，这就是我们的内容溢出的时候，我们在默认情况下看到它们的原因。 如果你想在内容溢出的时候把它裁剪掉，你可以在你的盒子上设置 overflow: hidden。这就会像它表面上所显示的那样作用——隐藏掉溢出。这可能会很自然地让东西消失掉，所以你只应该在判断隐藏内容不会引起问题的时候这样做。 在有内容溢出的时候加个滚动条？如果你用了 overflow: scroll，那么你的浏览器总会显示滚动条，即使没有足够多引起溢出的内容。你可能会需要这样的样式，它避免了滚动条在内容变化的时候出现和消失。 想让滚动条在有比盒子所能装下更多的内容的时候才显示，那么使用 overflow: auto。 如果你真的需要在小盒子里面和长英文词打交道，那么你可能要了解一下 word-break 或者 overflow-wrap 属性。 区别和选择: overflow-wrap 主要关注的是如何处理整个单词的换行，而 word-break 更侧重于在何处断开换行，即使这涉及到单词内部的断行。 在处理非拉丁字符（例如中文、日文）时，word-break: break-all; 会在字符之间插入换行，而 overflow-wrap: break-word; 不会。 通常情况下，如果你更关注整个单词的处理，可以使用 overflow-wrap，而如果你更关注在非拉丁字符之间的处理，可以使用 word-break。在某些情况下，你可能需要同时使用这两个属性以达到期望的效果。 溢出建立了区块格式化上下文CSS 中有所谓区块格式化上下文（Block Formatting Context，BFC）的概念。在你使用诸如 scroll 或者 auto 的时候，你就建立了一个块级排版上下文。结果就是，你改变了 overflow 的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，你的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件，于是就产生了一个协调的滚动体验。 CSS 的值与单位在 CSS 规范和 MDN 的属性页上，你将能够发现值的存在，因为它们将被尖括号包围，如 &lt;color&gt; 或 &lt;length&gt;。当你看到值 &lt;color&gt; 对特定属性有效时，这意味着你可以使用任何有效的颜色作为该属性的值。 你还将看到被称为数据类型的 CSS 值。这些术语基本上是可以互换的——当你在 CSS 中看到一些被称为数据类型的东西时，它实际上只是一种表示值的奇特方式。 CSS 值倾向于使用尖括号表示，以区别于 CSS 属性（例如 color 属性和 &lt;color&gt; 数据类型）。你可能还会混淆 CSS 数据类型和 HTML 元素，因为它们都使用尖括号，但这不太可能——它们在完全不一样的上下文中使用。 在 CSS 中使用了各种数值数据类型。以下全部归类为数值： 数值类型 描述 &lt;integer&gt; &lt;integer&gt;是一个整数，比如 1024 或 -55。 &lt;number&gt; &lt;number&gt; 表示一个小数——它可能有小数点后面的部分，也可能没有，例如 0.255、128 或 -1.2。 &lt;dimension&gt; &lt;dimension&gt; 是一个 &lt;number&gt; 它有一个附加的单位，例如 45deg、5s 或 10px。&lt;dimension&gt; 是一个伞形类别，包括 &lt;length&gt;、&lt;angle&gt;、&lt;time&gt; 和 &lt;resolution&gt; 类型。 &lt;percentage&gt; &lt;percentage&gt; 表示一些其他值的一部分，例如 50%。百分比值总是相对于另一个量。例如，一个元素的长度相对于其父元素的长度。 在 CSS 中调整大小原始尺寸，或固有尺寸在受 CSS 设置影响之前，HTML 元素有其原始的尺寸。一个直观的例子就是图像。一幅图像的长和宽由这个图像文件自身确定。这个尺寸就是固有尺寸。 元素的固有尺寸是由其所包含的内容决定。 设置具体的尺寸当给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为外部尺寸。以上面例子中的 &lt;div&gt; 举例——我们可以给它一个具体的 width 和 height 值，然后不论我们放什么内容进去它都是该尺寸。 由于存在溢出问题，在网络上使用长度或百分比固定元素的高度需要非常小心。 使用百分数：当使用百分数时，你需要清楚，它是什么东西的百分数。对于一个处于另外一个容器当中的盒子，如果你给予了子盒子一个百分数作为宽度，那么它指的是父容器宽度的百分数。 使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的内联尺寸进行计算的，也就是元素的水平宽度。 min- 和 max- 尺寸：如果你有一个包含了变化容量的内容的盒子，而且你总是想让它至少有个确定的高度，你应该给它设置一个 min-height 属性。盒子就会一直保持大于这个最小高度，但是如果有比这个盒子在最小高度状态下所能容纳的更多内容，那么盒子就会变大。这在避免溢出的同时并处理变化容量的内容的时候是很有用的。 max-width 的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。这个技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放。 视口单位：视口，即你在浏览器中看到的部分页面，也是有尺寸的。在 CSS 中，我们有与视口尺寸相关的度量单位，即意为视口宽度的 vw 单位，以及意为视口高度的 vh 单位。使用这些单位，你可以把一些东西做得随用户的视口改变大小。 1vh 等于视口高度的 1%，1vw 则为视口宽度的 1%。 如果你改变了 vh 和 vw 的对应值，盒子和字体的大小也会改变；视口大小的变化也会让它们的大小变化，因为它们是依照视口来定大小的。根据视口改变物件的大小是很有用的。 图像、媒体替换元素图像和视频被描述为替换元素。这意味着 CSS 不能影响它们的内部布局——而仅影响它们在页面上相对于其他元素的位置。但是，正如我们将看到的，CSS 可以对图像执行多种操作。 某些替换元素（例如图像和视频）也具有宽高比。这意味着它在水平（x）和垂直（y）方向上均具有大小，并且默认情况下将使用文件的固有尺寸进行显示。 调整图像大小下面的示例中有两个盒子，长宽均为 200 像素： 一个包含了一张小于 200 像素的图像，它比盒子小，并且不会自动拉伸来充满盒子。 另一张图像大于 200 像素，溢出了盒子。 那么该如何处理溢出问题呢？ 一个常用的方法是将一张图片的max-width设为100% 。这将会使图片的尺寸小于等于盒子。这个技术也会对其他替换元素（例如 &lt;video&gt;，或者 &lt;iframe&gt; 起作用）。 想把一张图像调整到能够完全盖住一个盒子的大小。object-fit 属性可以在这里帮助你。当使用 object-fit 时，替换元素可以以多种方式被调整到合乎盒子的大小。 1234567891011121314151617.box { width: 200px; height: 200px;}img { height: 100%; width: 100%;}.cover { object-fit: cover;}.contain { object-fit: contain;} 使用了值 cover 来缩小图像，同时维持了图像的原始比例。这样图像就可以充满盒子。但由于比例保持不变，图像多余的一部分将会被盒子裁切掉。 使用值 contain，图像就会被缩放到足以完整地放到盒子里面的大小。 fill 值，它可以让图像充满盒子，但是不会维持比例。 布局中的替换元素在对替换元素使用各种 CSS 布局时，你可能会发现他们的表现方式与其他元素有一些细节上的差异。例如，flex 或者 grid 布局中，默认情况下元素会被拉伸到充满整块区域。但是图像不会被拉伸，而会对齐到网格区域或者弹性容器的起始处。 替换元素在成为网格或者弹性布局的一部分时，有不同的默认行为。这一默认行为很有必要，因为它避免了替换元素被布局拉伸成奇怪的样子。 样式化表格列出了有用的点： 使你的表格标记尽可能简单，并且保持灵活性，例如使用百分比，这样设计就更有响应性。 使用 table-layout: fixed 创建更可控的表布局，可以通过在标题width中设置width来轻松设置列的宽度。 使用 border-collapse: collapse 使表元素边框合并，生成一个更整洁、更易于控制的外观。 使用&lt;thead&gt;, &lt;tbody&gt;和&lt;tfoot&gt; 将表格分割成逻辑块，并提供额外的应用 CSS 的地方，因此如果需要的话，可以更容易地将样式层叠在一起。 使用斑马线来让其他行更容易阅读。 使用 text-align直线对齐你的&lt;th&gt;和&lt;td&gt;文本，使内容更整洁、更易于跟随。 caption-side: bottom属性使标题被放置在表格的底部。","link":"/2019/05/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"title":"CSS 布局","text":"布局CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口/窗口的位置。在这个模块中将涉及更多关于页面布局技术的细节： 正常布局流 display属性 弹性盒子 网格 浮动 定位 CSS 表格布局 多列布局 每种技术都有它们的用途，各有优缺点，相互辅助。通过理解各个布局方法的设计理念，你能够找到构建你想要的网页需要的布局方案。 正常布局流正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。 下列布局技术会覆盖默认的布局行为： display 属性 — 标准的 value，比如block, inline 或者 inline-block 元素在正常布局流中的表现形式。 接着是全新的布局方式，通过设置display的值，比如 CSS Grid 和 Flexbox. 浮动——应用 float 值，诸如 left 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。 position 属性 — 允许你精准设置盒子中的盒子的位置，正常布局流中，默认为 static ，使用其他值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。 表格布局— 表格的布局方式可以用在非表格内容上，可以使用display: table和相关属性在非表元素上使用。 多列布局— 这个 Multi-column layout 属性可以让块按列布局，比如报纸的内容就是一列一列排布的。 display 属性在 css 中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容都有一个display的值，用作元素的默认行为方式。 在讨论布局时，对我们来说最重要的两个值是 display: flex 和 display: grid。 弹性盒子Flexbox 是 CSS 弹性盒子布局模块（Flexible Box Layout Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，你只需要在想要进行 flex 布局的父元素上应用display: flex ，所有直接子元素都将会按照 flex 进行布局。 当我们把display: flex添加到它的父元素时，元素就自动按列进行排列。这是由于它们变成了flex 项 (flex items)，按照 flex 容器（也就是它们的父元素）的一些 flex 相关的初值进行 flex 布局：它们整整齐齐排成一行，是因为父元素上flex-direction的初值是row。它们全都被拉伸至和最高的元素高度相同，是因为父元素上align-items属性的初值是stretch。 flex 模型说明: 当元素表现为 flex 框时，它们沿着两个轴来布局： 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。 设置了 display: flex 的父元素被称之为 flex 容器（flex container）。 在 flex 容器中表现为弹性的盒子的元素被称之为 flex 项（flex item）。 弹性盒子提供了 flex-direction 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它默认值是 row，这使得它们在按你浏览器的默认语言方向排成一排（在英语/中文浏览器中是从左到右）。flex-direction:column是垂直排列。 还可以使用 row-reverse 和 column-reverse 值反向排列 flex 项。 换行：flex-wrap：wrap flex-flow 缩写: flex-direction 和 flex-wrap——的缩写 flex-flow 1234flex-direction: row;flex-wrap: wrap;flex-flow: row wrap; flex 项的动态尺寸: 本例中，我们设置 &lt;article&gt; 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。 第三个 &lt;article&gt; 元素占用了两倍的可用宽度，剩下的一样——现在总共有四个比例单位可用。前两个 flex 项各有一个，因此它们占用每个可用空间的 1/4。第三个有两个单位，所以它占用 2/4 或者说是 1/2 的可用空间。 1234567article { flex: 1;}article:nth-of-type(3) { flex: 2;} 这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。 还可以指定 flex 的最小值。 1234567article { flex: 1 200px;}article:nth-of-type(3) { flex: 2 200px;} 水平和垂直对齐: align-items 控制 flex 项在交叉轴上的位置。 默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。 在上面规则中我们使用的 center 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。 你也可以设置诸如 flex-start 或 flex-end 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。 12345div { display: flex; align-items: center; justify-content: space-around;} 可以用 align-self 属性覆盖 align-items 的行为。 123button:first-child { align-self: flex-end;} justify-content 控制 flex 项在主轴上的位置。 默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处。 你也可以用 flex-end 来让 flex 项到结尾处。 center 在 justify-content 里也是可用的，可以让 flex 项在主轴居中。 而我们上面用到的值 space-around 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。 还有一个值是 space-between，它和 space-around 非常相似，只是它不会在两端留下任何空间。 flex 项排序: 弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。 123button:first-child { order: 1;} 刷新下，然后你会看到“Smile”按钮移动到了主轴的末尾。下面我们谈下它实现的一些细节： 所有 flex 项默认的 order 值是 0。 order 值大的 flex 项比 order 值小的在显示顺序中更靠后。 相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。 第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。 你也可以给 order 设置负值使它们比值为 0 的元素排得更前面。比如，你可以设置“Blush”按钮排在主轴的最前面： 123button:last-child { order: -1;} flex 嵌套: 弹性盒子也能创建一些颇为复杂的布局。设置一个元素为 flex 项，那么他同样成为一个 flex 容器，它的孩子（直接子节点）也表现为弹性盒子。 123456789101112131415&lt;section&gt; &lt;article&gt; &lt;h2&gt;First article&lt;/h2&gt; &lt;p&gt;Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;article&gt; &lt;h2&gt;Third article&lt;/h2&gt; &lt;p&gt;Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.&lt;/p&gt; &lt;p&gt;Cray food truck brunch, XOXO +1 keffiyeh pickled chambray waistcoat ennui. Organic small batch paleo 8-bit. Intelligentsia umami wayfarers pickled, asymmetrical kombucha letterpress kitsch leggings cold-pressed squid chartreuse put a bird on it. Listicle pickled man bun cornhole heirloom art party.&lt;/p&gt; &lt;/article&gt; &lt;p&gt;Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 1234567section { display: flex;}article:nth-of-type(2) { display: flex;} Grid 布局Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在两个维度上把元素按行和列排列整齐。 使用display:grid，分别使用 grid-template-rows 和 grid-template-columns 两个属性定义了一些行和列的轨道。 利用 grid-column 和 grid-row 两个属性来指定每一个子元素应该从哪一行/列开始，并在哪一行/列结束。这就能够让子元素在多个行/列上展开。 什么是网格布局？ 网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。 一个网格通常具有许多的列（column）与行（row），以及行与行、列与列之间的间隙，这个间隙一般被称为沟槽（gutter）。 定义一个网格: 默认情况下，子项按照正常布局流自顶而下排布。 通过把容器的 display 属性设置为 grid ,来定义一个网格。 与弹性盒子一样，将父容器改为网格布局后，他的直接子项会变为网格项。 与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为 display: grid 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。 123.container { display: grid;} 为了让我们的容器看起来更像一个网格，我们要给刚定义的网格加一些列。那就让我们加三个宽度为200px的列。当然，这里可以用任何长度单位，包括百分比。 1234.container { display: grid; grid-template-columns: 200px 200px 200px;} 使用 fr 单位的灵活网格：除了长度和百分比，我们也可以用 fr 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份。 将窗口调窄（由于示例中设定了max-width，可能需要很窄），你应该能看到每一列的宽度可以会随着可用空间变小而变小。fr 单位按比例划分了可用空间。 这个定义里，第一列被分配了 2fr 可用空间，余下的两列各被分配了 1fr 的可用空间，这会使得第一列的宽度更大。另外，fr可以与一般的长度单位混合使用。比如设置 grid-template-columns: 300px 2fr 1fr，那么第一列宽度是300px，剩下的两列会根据剩余的可用空间按比例分配。 1234.container { display: grid; grid-template-columns: 2fr 1fr 1fr;} fr单位分配的是可用空间而非所有空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。 网格间隙: 使用 grid-column-gap 属性来定义列间隙；使用 grid-row-gap来定义行间隙；使用 grid-gap 可以同时设定两者。 间隙距离可以用任何长度单位包括百分比来表示，但不能使用fr单位。 gap属性曾经有一个grid-前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。 123456.container { display: grid; grid-template-columns: 2fr 1fr 1fr; grid-gap: 20px; gap: 20px;} 重复构建轨道组: 可以使用repeat来重复构建具有某些宽度配置的某些列。举个例子，如果要创建多个等宽轨道，可以用下面的方法。 12345.container { display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 20px;} 和之前一样，你仍然得到了 3 个 1fr 的列。第一个传入 repeat 函数的值（3）表明了后续列宽的配置要重复多少次，而第二个值（1fr）表示需要重复的构建配置，这个配置可以具有多个长度设定。例如repeat(2, 2fr 1fr)，这相当于填入了 2fr 1fr 2fr 1fr。 关键字auto-fill可以确定的重复次数。 123456repeat(auto-fill, 250px)repeat(auto-fit, 250px)repeat(auto-fill, [col-start] 250px [col-end])repeat(auto-fit, [col-start] 250px [col-end])repeat(auto-fill, [col-start] minmax(100px, 1fr) [col-end])repeat(auto-fill, 10px [col-start] 30% [col-middle] 400px [col-end]) 显式网格与隐式网格: 到目前为止，我们定义过了列，但还没有管过行。但在这之前，我们要来理解一下显式网格和隐式网格。显式网格是我们用 grid-template-columns 或 grid-template-rows 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。 隐式网格中生成的行/列大小是参数默认是 auto ，大小会根据放入的内容自动调整。当然，你也可以使用grid-auto-rows和grid-auto-columns属性手动设定隐式网格轨道的大小。下面的例子将grid-auto-rows设为了100px，然后你可以看到那些隐式网格中的行（因为这个例子里没有设定grid-template-rows，因此，所有行都位于隐式网格内）现在都是 100 像素高了。 123456.container { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px; grid-gap: 20px;} minmax() 函数: 很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了minmax()函数。 minmax() 函数为一个行/列的尺寸设置了取值范围。比如设定为 minmax(100px, auto)，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。在这里试一下把 grid-auto-rows 属性设置为minmax函数。 123456.container { display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(100px, auto); grid-gap: 20px;} 如果所有网格内的内容均小于 100 像素，看起来不会有变化。 但如果在某一项中放入很长的内容或者图片，你可以看到这个格子所在的哪一行的高度变成能刚好容纳内容的高度了 自动使用多列填充: 用到 repeat() 函数中的一个关键字auto-fill来替代确定的重复次数。而函数的第二个参数，我们使用minmax()函数来设定一个行/列的最小值，以及最大值 1fr。 123456.container { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px;} 可以看到形成了一个包含了许多至少 200 像素宽的列的网格，将容器填满。随着容器宽度的改变，网格会自动根据容器宽度进行调整，每一列的宽度总是大于 200 像素，并且容器总会被列填满。 基于线的元素放置在定义完了网格之后，我们要把元素放入网格中。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。 我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。 grid-column-start(en-US) grid-column-end(en-US) grid-row-start(en-US) grid-row-end(en-US) 这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。 grid-column grid-row 注意开始与结束的线的序号要使用/符号分开。 12345678910111213141516171819header { grid-column: 1 / 3; grid-row: 1;}article { grid-column: 2; grid-row: 2;}aside { grid-column: 1; grid-row: 2;}footer { grid-column: 1 / 3; grid-row: 3;} 也可以用 -1 来定位到最后一条列分隔线或是行分隔线，并且可以用负数来指定倒数的某一条分隔线。但是这只能用于显式网格，对于隐式网格-1不一定能定位到最后一条分隔线。 使用 grid-template-areas 属性放置元素: 另一种往网格放元素的方式是用grid-template-areas属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。 12345678910111213141516171819202122232425.container { display: grid; grid-template-areas: &quot;header header&quot; &quot;sidebar content&quot; &quot;footer footer&quot;; grid-template-columns: 1fr 3fr; gap: 20px;}header { grid-area: header;}article { grid-area: content;}aside { grid-area: sidebar;}footer { grid-area: footer;} grid-template-areas属性的使用规则如下： 你需要填满网格的每个格子 对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字 所有名字只能出现在一个连续的区域，不能在不同的位置出现 一个连续的区域必须是一个矩形 使用.符号，让一个格子留空 浮动把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (float) 的元素周围环绕。 当一个元素被浮动后，它会像一个盒子一样，从文档流中移动到其容器的一边。其他元素会认为浮动的元素所占据的空间仍然存在，因此会在布局时避开这个空间。 float 属性有四个可能的值： left — 将元素浮动到左侧。 right — 将元素浮动到右侧。 none — 默认值，不浮动。 inherit — 继承父元素的浮动属性。 例子当中，我们把一个元素浮动到左侧，并且给了他一个右侧的margin，把文字推开。这给了我们文字环绕着这个元素的效果，在现代网页设计当中，这是你唯一需要学会的事情。 123456789101112131415&lt;h1&gt;Simple float example&lt;/h1&gt;&lt;div class=&quot;box&quot;&gt;Float&lt;/div&gt;&lt;p&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt; 123456.box { float: left; width: 150px; height: 150px; margin-right: 30px;} 清除浮动如果不想让剩余元素也受到浮动元素的影响，我们需要停止它；这是通过添加 clear 属性实现的。 123.cleared { clear: left;} 应该看到，第二个段落已经停止了浮动，不会再跟随浮动元素排布了。clear 属性接受下列值： left：停止任何活动的左浮动 right：停止任何活动的右浮动 both：停止任何活动的左右浮动 清除浮动元素周围的盒子当浮动元素脱离正常文档流时，它会不再占据文档流中的空间，而是漂浮在文档的特定位置。当你想要一个盒子（容器）包含浮动元素并与浮动元素后续内容产生正常的布局时，通常需要处理浮动元素的影响。这涉及到清除浮动。 1234567891011121314151617&lt;div class=&quot;wrapper&quot;&gt;&lt;div class=&quot;box&quot;&gt;Float&lt;/div&gt;&lt;p class=&quot;hhh&quot;&gt; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet.&lt;/p&gt;&lt;/div&gt;&lt;p&gt; Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.&lt;/p&gt; 如果你给 .float-left 元素应用了 float: left;，它会脱离正常文档流，而 .container 的高度不会自动包含浮动元素。这可能导致 .container 的高度坍缩，从而影响下方紧随其后的内容。 有三种方法可以处理这个问题:clearfix: 先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。 12345.wrapper::after { content: &quot;&quot;; clear: both; display: block;} 使用 overflow: 一个替代的方案是将包裹元素的 overflow 属性设置为除 visible 外的其他值。在包裹元素上添加 overflow: auto 规则。现在，盒子应该再一次停止浮动。 123456.wrapper { background-color: rgb(79, 185, 227); padding: 10px; color: #fff; overflow: auto;} 这个例子之所以能够生效，是因为创建了所谓的 块格式化上下文（BFC）。可以把它看作页面内部包含所需元素的一小块布局区域。如此设置可以让浮动元素包含在 BFC 及其背景之内。大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的滚动条或裁剪阴影，这是使用 overflow 带来的一些副作用。 display: flow-root: 一个较为现代的方案是使用 display 属性的 flow-root 值。它可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。 123456.wrapper { background-color: rgb(79, 185, 227); padding: 10px; color: #fff; display: flow-root;} 定位技术定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。 有一些非常有用的技术在特定的布局下依赖于position属性。同时，理解定位 (positioning) 也能够帮助你理解正常布局流 (normal flow)，理解把一个元素移出正常布局流 (normal flow) 是怎么一回事。 有五种主要的定位类型需要我们了解： 静态定位（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。 123.positioned { position: static;} 相对定位（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计（design pinpointing）非常有用。 1position: relative; 绝对定位（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它单独放在一个图层中。我们可以将元素相对于页面的 元素边缘固定，或者相对于该元素的最近被定位祖先元素*（nearest positioned ancestor element）。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。将元素从文档流 (document flow) 当中移出了。* 1position: absolute; 定位上下文：可以改变定位上下文 —— 绝对定位的元素的相对位置元素。通过设置其中一个父元素的定位属性 —— 也就是包含绝对定位元素的那个元素（如果要设置绝对定位元素的相对元素，那么这个元素一定要包含绝对定位元素）。 z-index：可以更改堆叠顺序，网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。z-index 只接受无单位索引值，较高的值将高于较低的值。 固定定位（Fixed positioning）与绝对定位非常类似，但是它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。将元素从文档流 (document flow) 当中移出了。 1position: fixed; 粘性定位（Sticky positioning）是一种新的定位方式，它会让元素先保持和 position: static 一样的定位，当它的相对视口位置（offset from the viewport）达到某一个预设值时，它就会像 position: fixed 一样定位。 1position: sticky; 表格布局一个&lt;table&gt;标签之所以能够像表格那样展示，是由于 css 默认给&lt;table&gt;标签设置了一组 table 布局属性。当这些属性被应用于排列非&lt;table&gt;元素时，这种用法被称为“使用 CSS 表格”。 表布局是不灵活的，繁重的标记，难以调试和语义上的错误。 1display: table; 多列布局多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。 要把一个块转变成多列容器 (multicol container)，我们可以使用 column-count属性来告诉浏览器我们需要多少列。也可以使用column-width来告诉浏览器以至少某个宽度的尽可能多的列来填充容器，任何剩余的空间之后会被现有的列平分。这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。 123456.container { column-count: 3;}.container { column-width: 200px;} 使用 column-gap 改变列间间隙。 用 column-rule 在列间加入一条分割线，column-rule 是 column-rule-color 和 column-rule-style的缩写，接受同 border 一样的单位。 break-inside属性来控制 multicol 和多页媒体中的内容拆分、折断。 传统的布局方法CSS 网格布局之前的布局与网格系统可以了解到基于 float 和 flexbox 的网格系统和网格框架是如何工作的。它们里面没有哪个的建立方式是像通过 CSS 网格布局创建网格那样，真的建立一个网格。他们通过给目标一个大小，然后推动它们，让它们看起来像网格一样排列成一条线。 两列布局body 将会占据 90% 的视口宽度，直到达到 900 像素，在这种情况下，它将固定并保持在视口正中。 12345body { width: 90%; max-width: 900px; margin: 0 auto;} 如果希望两个&lt;div&gt;，一个浮在窗口的一边，另一个浮动在另一边的话，需要将它们的宽度设置为其父元素的 100% 或者更小，以便他们可以并排放置。 这里我们将它们都设置为了父元素宽度的 48%——总共是 96%，在两栏之间留 4% 的空隙，为它们提供一些宽松的空间。 123456789div:nth-of-type(1) { width: 48%; float: left;}div:nth-of-type(2) { width: 48%; float: right;} 在宽度的表示上都用的是百分比——这是一个很好的策略，这创建了一个流动布局（liquid layout），能够适应不同的屏幕大小，在小一些的屏幕上也能使列保持一样的比例。 浮动网格的限制当你想用这个网格系统时，你得仔细看看你的总长是否正确，并且每行中的元素所横跨的列数不超过这一行可容纳的列数。由于浮动布局实现的方式，如果网格列的数目对与网格来说太大，在最后边的元素会跑到下一行去，搞坏了布局。 还要记住，如果元素内容比行宽，它会溢出，看起来一团糟。 这个系统的最大限制是，它本质上是一维的。我们在处理列、让元素跨越列，但是处理不了行。如果不设置一个确定的高度，用老方法很难控制元素高。这个方法很不灵活 —它只有在你确定你的内容有个明确的高的情况下有用。 弹性盒网格弹性布局不是为网格布局而设的，把它当网格布局来用也有新的挑战。 在顶行，我们有十二个整齐的盒子，它们在视口宽度改变时同等地放大缩小。可是在下一行，我们只有四个物件，它们也从六十像素的基础上变大变小。因为它们只有四个，它们可以长得比上一行的物件更快，结果是它们都占据了第二行的相同宽度。 为了解决这个问题，我们仍然需要包含span类，以提供一个用于那个元素的，可以替换掉为 flex-basis所使用的值的宽度。 弹性盒设计上是一维。它处理单个维度，行的或者列的。我们不能创建一个对行列严格要求的网格，意即如果我们要在我们的网格上使用弹性盒的话，我们仍然需要计算浮动布局的百分比。 第三方网格系统流行的框架，例如Bootstrap和Foundation和Skeleton，就包含了网格系统。 Skeleton（或者其他任何网格框架）正在做的所有事情是，设定一个预定义的类，可以通过把它们加到你的标记文件里面的方式使用这些框架，和你自己做计算这些百分数的工作完全是一样的。 正如你所看到的这样，使用 Skeleton 的时候，几乎不需要写多少 CSS。向标记文本里面加类的时候，替我们处理了所有的浮动。 响应式设计如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念（responsive web design，RWD），RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。这是改变我们设计多设备网页的方式的思想。 响应式设计是将三种技术的混合使用： 第一个是液态网格。 第二个是液态图像的理念，通过使用相当简单的将设置max-width属性设置为100%的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。 第三个关键的组件是媒体查询，可以只使用 CSS 实现，和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。 媒介查询CSS 媒体查询（media query）是响应式设计的关键组成部分，你可以根据各种设备特征和参数是否存在以及对应的值来应用 CSS 样式。 123@media media-type and (media-feature-rule) { /* CSS rules go here */} 它由以下部分组成： 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的(例如印刷品或者屏幕)。可以指定的媒体类型为： all print screen speech 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试。 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 媒体特征规则在指定了类型以后，你可以用一条规则指向一种媒体特征。 宽和高: 使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到width或height 单独使用的情况。 12345@media screen and (min-width: 800px) { .container { margin: 1em 2em; }} 朝向: 一个受到良好支持的媒体特征是orientation，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。对朝向的测试可以帮你建立一个为竖放设备优化的布局。 12345@media (orientation: landscape) { body { color: rebeccapurple; }} 使用指点设备: 作为四级规范的一部分，hover媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。 12345@media (hover: hover) { body { color: rebeccapurple; }} 如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。 还是在四级规范中，出现了pointer媒体特征。它可取三个值：none、fine和coarse。fine指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。coarse指针是你在触摸屏上的手指。none值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。使用pointer可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。 更复杂的媒体查询有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。 媒体查询中的“与”逻辑: 为了混合媒体特征，你可以以与在上面使用and很相同的方式，用and来混合媒体类型和特征。 例如，我们可能会想要测得min-width和orientation，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。 12345@media screen and (min-width: 400px) and (orientation: landscape) { body { color: blue; }} 媒体查询中的“或”逻辑: 如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。 在下面的示例中，文本会在视口至少为 400 像素宽的时候或者设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。 12345@media screen and (min-width: 400px), screen and (orientation: landscape) { body { color: blue; }} 媒体查询中的“非”逻辑: 你可以用not操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。 12345@media not all and (orientation: landscape) { body { color: blue; }} 怎么选择断点可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到适应各式屏幕尺寸的最佳效果。引入媒体查询，以及样式改变时的点，被叫做*断点（breakpoints）。 开发者工具中的响应式设计模式能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。 移动优先的响应式设计使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为移动优先设计。 真的需要媒体查询吗？弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。 灵活网格使用灵活网格，你只需要加进去一个断点，在内容看起来不齐整的时候改变设计。例如如果一行随着屏幕大小增加而增长得不可读的长，或者是一个盒子在变窄时把每行的两个单词挤到一起。 早年间进行响应式设计的时候，我们唯一的实现布局的选项是使用float。灵活浮动布局是这样实现的，让每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过 100%。在他对于液态网格文章的原文中，Marcotte 详细描述了一种布局的法则，通过使用像素并把布局转化为百分数的方式设计。 target / context = result 例如如果我们的预期栏尺寸为 60 像素，而且它所在的上下文（或者容器）为 960 像素，我们在将零点二的空间移动到右边以后，用 960 去除 60，得到我们能够使用在我们的 CSS 上的值。 123.col { width: 6.25%; /* 60 / 960 = 0.0625 */} 现代布局技术现代布局方式，例如多栏布局、伸缩盒和网格默认是响应式的。 多个列123456.container { column-count: 3;}.container { column-width: 10em;} 伸缩盒1234567.container { display: flex;}.item { flex: 1;} CSS 网格1234.container { display: grid; grid-template-columns: 1fr 1fr 1fr;} 响应式图像响应式图像，使用了&lt;picture&gt;元素和&lt;img&gt; srcset和sizes 特性，可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。也可以给用于不同尺寸的图像做“艺术指导”，为不同的屏幕尺寸提供不同的图像裁切或者完全不同的图像。 响应式排版根据屏幕真实使用范围的多少，在媒体查询的同时改变字体大小。 在本例子中，想讲一级标题设置为4rem，也就是说它将会有基础字体的四倍大。但是只想在大些的屏幕上有这么个超大的标题，那先弄个小点的标题，再使用媒体查询，在知道用户使用至少1200px的屏幕的时候，拿大些的尺寸覆写它。 12345678910111213html { font-size: 1em;}h1 { font-size: 2rem;}@media (min-width: 1200px) { h1 { font-size: 4rem; }} 使用视口单位实现响应式排版一个有趣的方式是使用视口单位vw来实现响应式排版。1vw等同于视口宽度的百分之一，即如果你用vw来设定字体大小的话，字体的大小将总是随视口的大小进行改变。 123h1 { font-size: 6vw;} 问题在于，当做上面的事情的时候，因为文本总是随着视口的大小改变大小，用户失去了放缩任何使用vw单位的文本的能力。所以你永远都不要只用 viewport 单位设定文本。 这里有一个解决方法，它使用了calc()，如果你将vw单位加到了使用固定大小（例如em或者rem）的值组，那么文本仍然是可放缩的。基本来说，是vw加在了放缩后的值上。 123h1 { font-size: calc(1.5rem + 3vw);} 这就是说，只需要指定标题的字体大小一次，而不是为移动端设定它，然后再在媒介查询中重新定义它。字体会在你增加视口大小的时候逐渐增大。 视口元标签看一张响应式页面的 HTML 源代码，通常将会在文档的&lt;head&gt;看到下面的&lt;meta&gt;标签。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt; 这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的 100%，在移动端以你所希望的为移动优化的大小展示文档。 如果你有个窄屏布局，在 480 像素及以下的视口宽度下生效，但是视口是按 960 像素设定的，你将不会在移动端看到你的窄屏布局。通过设定width=device-width，你用设备的实际宽度覆写了苹果默认的width=960px，然后你的媒介查询就会像预期那样生效。 所以你应该在你的文档头部总是包含上面那行 &lt;meta&gt;。 和视口元标签一起，你可以使用另外几个设定，但大体说来，上面那行就是你想要使用的。 initial-scale：设定了页面的初始缩放，我们设定为 1。 height：特别为视口设定一个高度。 minimum-scale：设定最小缩放级别。 maximum-scale：设定最大缩放级别。 user-scalable：如果设为no的话阻止缩放。 你应该避免使用minimum-scale、maximum-scale，尤其是将user-scalable设为no。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。 支持旧浏览器需要查明使用旧浏览器浏览你的站点的用户的数量。 你应该同样考虑设备的类型和人们使用你的网站的方式。 无障碍和使用辅助性技术的人总应当被考虑，对于一些站点，这问题可能更加重要。 在 CSS 中构建回滚CSS 规范包含了在一个物件上同时应用两种布局的时候，解释浏览器如何反应的信息。例如，规范定义如果一个浮动元素同时又是用 CSS 网格布局实现的网格元素（Grid Item）的时候会发生什么。结合浏览器会忽略掉它不会理解的 CSS 的特点组合起来，你就得到了使用我们已经提到的传统技术构建简单布局的方法，在可以理解你的网格布局的现代浏览器中，传统布局方法会被网格布局覆写掉。 如果浏览器器支持网格布局，它会显示网格视图，否则它会忽略****display: grid相关的属性，使用浮动布局。 回滚方式浮动和清除 如果浮动和清除的物件变成了弹性或网格物件，浮动和清除属性不再影响布局。 display: inline-block 这种方式能被用来建立列布局，如果一个物件被设为display: inline-block，但是之后变成了弹性或者网格物件，inline-block 行为将会被忽略。 display: table 被设为 CSS 表格布局的物件将会在它们变为弹性或者网格物件的时候不再表现出这种行为。重要的是，被建立起来用于修复表格结构的匿名盒子没有被建立起来。 Multiple-column Layout 对于某些布局，你能用multi-col作为回滚。如果你的容器有任何一个column-*属性被定义，之后变成了网格容器，那么多列行为不会实现。 作为网格的回滚的弹性盒 弹性盒由于受到了 IE10 和 IE11 的支持，比网格有着更好的浏览器支持。不过，如果你把弹性容器做成了网格容器，任何应用到子元素的flex属性都会被忽略。 在浮动布局中，百分数是依照容器计算的——33.333% 是容器宽度的三分之一。但在网格中，这 33.333% 是根据物件所在的网格区域计算的，所以只要网格布局引入进来，物件的大小实际上变成了我们想要的大小的三分之一。 为了处理这种问题，我们需要有能够探测网格是否受到支持的方法，也就是探测它是否会覆写宽度的方法。CSS 在这里为我们提供了一个解决方法。 特性查询特性查询允许你测试一个浏览器是否支持任何特定的一个 CSS 特性。这就是说，你可以写一些面向不支持某项特性的浏览器的 CSS，然后检查以了解浏览器是否支持，如果支持的话就可以加进你的复杂布局了。 示例中加入了一条特征查询，要是我们知道网格受到支持的话，我们可以用它把我们的物件宽度设定回auto。 12345678910111213.item { float: left; border-radius: 5px; background-color: rgb(207, 232, 220); padding: 1em; width: 33.333%;}@supports (display: grid) { .item { width: auto; }} 对特性查询的支持，在各现代浏览器中都是很好的。 先在任何特性查询以外，编写我们的旧 CSS。不支持网格也不支持特性查询的浏览器会使用这部分它们可以理解的布局信息，将其他东西全都忽略掉。支持特性查询和 CSS 网格等的浏览器会运行网格代码和特性查询之内的代码。 弹性盒的旧版本在旧版浏览器中，你可以找到弹性盒规范的旧有修订版本。在编写这篇文章的时候，这大多数是 IE10 的问题，它在弹性盒上使用了-ms-前缀。这也意味着现在还存在着一些过时的文章和教程，这篇有用的指导帮助你分辨你看到的信息；如果你需要在很旧的浏览器中需要 flex 支持的话，它也会帮到你。 IE10 和 IE11 的带前缀版的网格CSS 网格规范最初成形于 IE10，也就是说尽管 IE10 和 IE11 不支持现代的网格，虽然这种网格和本站记载的现代布局不同，它们还是有一个很堪用的网格布局版本。IE10 和 IE11 的实现是以-ms-为前缀的，也就是说你可以给这两个浏览器用，而在非微软浏览器上，这种属性会被忽略。不过 Edge 仍然能理解旧语法，所以小心点，让每个东西都安全地在你的现代网格 CSS 中覆写。 测试旧浏览器由于大多数浏览器都支持弹性盒和网格，测试旧浏览器想想就很难。一种方式是使用在线的测试工具，例如 Sauce Labs，在跨浏览器测试模块里有详细说明。 你也可以下载安装虚拟机，在你的电脑的容器环境中运行旧版浏览器。能够使用旧版 IE 是很有用的，为此，微软已经制作了一些可以免费下载的虚拟机。这些对 Mac、Windows 和 Linux 操作系统都是可以用的，所以即使你没有 Windows 电脑，这也是一个测试旧的和现代 Windows 浏览器的绝佳办法。","link":"/2021/10/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E5%B8%83%E5%B1%80/"},{"title":"CSS3","text":"样式边框 box-shadow：用来给边框添加阴影 1234box-shadow: h-shadow v-shadow blur spread color inset;//可以设置多个阴影，多个阴影之间用逗号分隔box-shadow: 0 5px 10px black, 0 10px 20px rgba(0, 0, 0, 0.5); h-shadow：表示水平方向的阴影偏移量，可以是负值（向左偏移）或正值（向右偏移）。 v-shadow：表示垂直方向的阴影偏移量，可以是负值（向上偏移）或正值（向下偏移）。 blur：表示模糊半径，值越大，阴影越模糊，为 0 时没有模糊效果。 spread：表示阴影的尺寸，为正值时会增加阴影的尺寸，为负值时会减少阴影的尺寸。 color：表示阴影的颜色，可以使用颜色关键字、十六进制值、RGB 值等。 inset：可选值，表示阴影是否为内阴影（inset）。 border-image：使用图像创建一个边框 1border-image: source slice width outset repeat; source：指定用作边框的图像路径。可以是图片的 URL，也可以是 none，表示不使用图像，仅使用 CSS 定义的边框样式。 slice：指定图片如何被分割成九个区域。这个值通常是一个数值或百分比，用于定义四条边框分割图像的位置。 width：指定边框的宽度。可以是像素、百分比或其他长度单位。 outset：可选项，指定边框图像的外部填充（通常用于创建立体效果）。 repeat：可选项，指定边框图像的重复方式，可以是 stretch（拉伸）、repeat（平铺）、round（拉伸并平铺）、或者指定一个数值表示图像重复的次数。 圆角border-radius：用于创建圆角： 1border-radius: value; 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 一个值： 四个圆角值相同 背景 background-image background-size background-origin：指定了背景图像的位置区域。 content-box, padding-box,和 border-box区域内可以放置背景图像。 background-clip：背景剪裁属性从指定位置开始绘制。 文本 text-shadow：用于文本阴影 text-overflow：指定应向用户如何显示溢出内容 word-wrap：自动换行属性允许您强制文本换行，即使这意味着分裂它中间的一个字 word-break：指定换行规则 渐变 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 12345678//使用方向语法：background-image: linear-gradient(direction, color-stop1, color-stop2, ...);//使用角度语法：background-image: linear-gradient(angle, color-stop1, color-stop2);//函数用于重复线性渐变：repeating-linear-gradient() 径向渐变（Radial Gradients）- 由它们的中心定义 12345//语法：background-image: radial-gradient(shape size at position, start-color, ..., last-color); //函数用于重复径向渐变：repeating-radial-gradient() 2D/3D 转换定义：CSS transform 属性允许你旋转，缩放，倾斜或平移给定元素。 语法： 123456789101112131415161718192021222324252627282930313233/* Keyword values */transform: none;/* Function values */transform: matrix(1.0, 2.0, 3.0, 4.0, 5.0, 6.0);transform: translate(12px, 50%); //平移transform: translateX(2em);transform: translateY(3in);transform: scale(2, 0.5); //缩放transform: scaleX(2);transform: scaleY(0.5);transform: rotate(0.5turn); //旋转transform: skew(30deg, 20deg); //歪斜transform: skewX(30deg);transform: skewY(1.07rad);transform: matrix3d(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0);transform: translate3d(12px, 50%, 3em);transform: translateZ(2px);transform: scale3d(2.5, 1.2, 0.3);transform: scaleZ(0.3);transform: rotate3d(1, 2.0, 3.0, 10deg);transform: rotateX(10deg);transform: rotateY(10deg);transform: rotateZ(10deg);transform: perspective(17px);/* Multiple function values */transform: translateX(10px) rotate(10deg) translateY(5px);/* Global values */transform: inherit;transform: initial;transform: unset; translate()：根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate()：在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转 scale()：该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数 skew()：包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。 skewX();表示只在X轴(水平方向)倾斜。 skewY();表示只在Y轴(垂直方向)倾斜。 matrix()：有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。 rotateX()：围绕其在一个给定度数X轴旋转的元素 rotateY()：围绕其在一个给定度数Y轴旋转的元素 要应用的一个或多个 CSS 变换函数。变换函数按从左到右的顺序相乘，这意味着复合变换按从右到左的顺序有效地应用。 none：不应用任何变换。 transform-origin 属性更改一个元素变形的原点： transform-origin 属性可以使用一个，两个或三个值来指定，其中每个值都表示一个偏移量。没有明确定义的偏移将重置为其对应的初始值。 如果定义了两个或更多值并且没有值的关键字，或者唯一使用的关键字是center，则第一个值表示水平偏移量，第二个值表示垂直偏移量。 一个值： 必须是长度，百分比值，或 left, center, right, top, bottom关键字中的一个。 两个值： 其中一个必须是长度，百分比值，或left, center, right关键字中的一个。 另一个必须是长度，百分比值，或top, center, bottom关键字中的一个。 三个值： 前两个值和只有两个值时的用法相同。 第三个值必须是长度。它始终代表 Z 轴偏移量。 12transform-origin: center;transform-origin: top left; 动画过度定义：过渡可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素()之间切换，像是 :hover,:active或者通过 JS 实现的状态变化。 语法： 1234567891011121314151617181920212223/* Apply to 1 property *//* property name | duration */transition: margin-right 4s;/* property name | duration | delay */transition: margin-right 4s 1s;/* property name | duration | timing function */transition: margin-right 4s ease-in-out;/* property name | duration | timing function | delay */transition: margin-right 4s ease-in-out 1s;/* Apply to 2 properties */transition: margin-right 4s, color 1s;/* Apply to all changed properties */transition: all 0.5s ease-out;/* Global values */transition: inherit;transition: initial;transition: unset; CSS transitions 可以决定哪些属性发生动画效果 (明确地列出这些属性)：何时开始 (设置 delay），持续多久 (设置 duration) 以及如何动画 (定义timing function，比如匀速地或先快后慢)。 transition 属性可以被指定为一个或多个 CSS 属性的过渡效果，多个属性之间用逗号进行分隔。 可以设置过渡的属性一般是数值型的，例如宽高、颜色、间距等。 每个单属性转换都描述了应该应用于单个属性的转换（或特殊值all和none）。这包括： 零或一个值，表示转换应适用的属性。这可能是以下任何一种： 关键字none 关键字all 命名 CSS 属性的标识符 。 零或一个时间函数值表示要使用的过渡函数 零，一或两个时间值。可以解析为时间的第一个值被分配给 duration ，并且可以解析为时间的第二个值被分配给 delay 。 当transition属性的值个数超过可以接收的值的个数时，多余的值都会被忽略掉，不再进行解析。 过渡是一次性的不能循环，如果想要循环需要使用「@keyframes」关键字。 动画@keyframes 规则是创建动画。 @keyframes 规则内指定一个 CSS 样式和动画将逐步从目前的样式更改为新的样式。 1234567891011@keyframes myfirst{ from {background: red;} to {background: yellow;}}@-webkit-keyframes myfirst /* Safari 与 Chrome */{ from {background: red;} to {background: yellow;}} 当在 @keyframes 创建动画，把它绑定到一个选择器，否则动画不会有任何效果。 指定至少这两个CSS3的动画属性绑定向一个选择器： 规定动画的名称 规定动画的时长 12345div{ animation: myfirst 5s; -webkit-animation: myfirst 5s; /* Safari 与 Chrome */} 响应式/自适应em使用 em 值创建动态或计算字体大小（历史上，em 单位是从给定字体中大写字母“M”的宽度派生的）。数字值作为当前元素的 font-size 属性的乘数。考虑以下示例： 123p { font-size: 2em;} 在这种情况下，&lt;p&gt;元素的大小将会是其通过继承得到的 font-size 计算值的两倍。因此，1em 的 font-size 等于元素所使用的 font-size 计算值。 为了计算所需像素值的等效 em 值，你可以使用以下公式： em = 希望得到的像素大小 / 父元素字体像素大小 例如，假设页面的 &lt;body&gt;的 font-size 设置为 16px。如果你想要的字体大小为 12px，那么应该指定 0.75em（因为 12/16 = 0.75）。同样，如果你想要字体大小为 10px，则应指定 0.625em（10/16 = 0.625）；对于 22px，请指定 1.375em（22/16）。 CSS 中的 em 是非常有用的单位，因为它会根据读者选择使用的字体自动调整其长度。 记住一个重要事实：em 值是复合的。看下面的 HTML 和 CSS： 123456html { font-size: 100%;}span { font-size: 1.6em;} 123&lt;div&gt; &lt;span&gt;Outer &lt;span&gt;inner&lt;/span&gt; outer&lt;/span&gt;&lt;/div&gt; 结果： 假设浏览器的默认 font-size 为 16px，则单词“outer”将渲染为 25.6px，但单词“inner”将渲染为 40.96px。这是因为内部 &lt;span&gt; 的 font-size 为 1.6em，相对于其父级的 font-size，而其父级又相对于其父级的 font-size。这通常被称为复合。 remrem 值的发明是为了避免复合问题。rem 值是相对于根 html 元素而不是父元素的。换句话说，它允许你以相对方式指定字体大小，而不受到父元素大小的影响，从而消除了复合问题。 下面的 CSS 与前一个示例几乎相同。唯一的例外是单位已更改为 rem。 结果： 在这个例子中，“outer inner outer”这些单词都以 25.6 像素的大小显示（假设浏览器的 font-size 已保留默认值 16px）。 vh/vw vw 视口宽度的 1%。 vh 视口高度的 1%。","link":"/2021/01/09/%E5%89%8D%E7%AB%AF/CSS/CSS3/"},{"title":"HTML 属性","text":"属性介绍元素也可以拥有属性，属性看起来像这样： 属性必须包含： 一个空格，它在属性和元素名称之间。如果一个元素具有多个属性，则每个属性之间必须由空格分隔。 属性名称，后面跟着一个等于号。 一个属性值，由一对引号（””）引起来。 有些特殊的属性，没有属性名，只有属性值，例如：disabled。 全局属性集合accesskeyaccesskey 全局属性 提供了为当前元素生成快捷键的方式。属性值必须包含一个可打印字符。 autocapitalizeThe autocapitalize 全局属性 是一个枚举属性，它控制用户输入/编辑文本输入时文本输入是否自动大写，以及如何自动大写。属性必须取下列值之一： off or none: 没有应用自动大写（所有字母都默认为小写字母）。 on or sentences: 每个句子的第一个字母默认为大写字母；所有其他字母都默认为小写字母。 words: 每个单词的第一个字母默认为大写字母；所有其他字母都默认为小写字母。 characters: 所有的字母都默认为大写。 class全局属性 class 的值是一个以空格分隔的元素的类名（classes）列表，它允许 CSS 和 Javascript 通过类选择器 (class selectors) 或 DOM 方法 ( document.getElementsByClassName) 来选择和访问特定的元素。 contenteditable全局属性 contenteditable 是一个枚举属性，表示元素是否可被用户编辑。如果可以，浏览器会修改元素的组件以允许编辑。 true 或空字符串，表示元素是可编辑的。 false 表示元素不是可编辑的。 plaintext-only 表示元素的原始文本是可编辑的，但富文本格式会被禁用。 data-*data-* 全局属性是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。 dir全局属性dir是一个指示元素中文本方向的枚举属性。它的取值如下： ltr，指从左到右，用于那种从左向右书写的语言（比如英语）； rtl，指从右到左，用于那种从右向左书写的语言（比如阿拉伯语）； auto，指由用户代理决定方向。它在解析元素中字符时会运用一个基本算法，直到发现一个具有强方向性的字符，然后将这一方向应用于整个元素。 备注：这个属性对有不同语义的&lt;bdo&gt;元素是必须的。这个属性在&lt;bdi&gt;元素中***不可***继承。未赋值时，它的默认值是 auto。这个属性可以被 CSS 属性direction和unicode-bidi覆盖，如果 CSS 网页有效且该元素支持这些属性的话。由于文本的方向是和内容的语义而不是和表现相关，因此有可能的话，网页开发者使用这一属性而非 CSS 属性是被推荐的。这样，即使在不支持 CSS 或禁用 CSS 的浏览器中，文本也会正常显示。auto 应当用于方向未知的数据，如用户输入的数据，最终保存在数据库中的数据。 draggable全局属性 draggable 是一种枚举(en-US)属性，用于标识元素是否允许使用浏览器原生行为或 HTML 拖放操作 API 拖动。 draggable 可以有如下取值： true：表示元素可以被拖动 false：表示元素不可以被拖动 如果该属性没有设值，则默认值 为 auto，表示使用浏览器定义的默认行为 警告： 这个属性是枚举类型(en-US)，而不是布尔类型。这意味着必须显式指定值为 true 或者 false，像 &lt;img draggable&gt; 这样的简写是不允许的。正确的用法是 &lt;img draggable=&quot;false&quot;&gt;。 如果没有设置该属性，其默认值为 auto，这意味着拖动行为是浏览器的默认行为：只有选择的文本、图像和链接可以被拖动。对于其他元素，必须设置事件 ondragstart 以使拖放行为生效，如本综合实例所示。 hidden全局属性 hidden 是一个布尔属性，表示一个元素尚未或者不再相关。例如，它可以被用来隐藏一个页面元素直到登录完毕。如果一个元素设置了这个属性，它就不会被显示。 idid 全局属性定义了一个全文档唯一的标识符（ID）。它用于在链接（使用片段）、脚本和样式（通过 CSS）中辨识元素。 inputmodeinputmode 全局属性 是一个枚举属性，它提供了用户在编辑元素或其内容时可能输入的数据类型的提示。 isis 全局属性允许你指定标准 HTML 元素像定义的内置元素一样工作。 itemiditemid 全局属性 是元素的唯一的全局标识符。itemid 属性只能为同时拥有 itemscope 和 itemtype 的元素指定。同时，itemid 只能为拥有 itemscope 的元素指定，它的相应 itemtype 引用或定义了支持全局标识符的词汇。 itemprop全局属性 itemprop被用于向一个物体中添加属性。每一个 HTML 元素都可以指定一个 itemprop 属性，一个itemprop属性由 name-value 对组成。每一个键值对称为一个属性，一个元素可以有一个或者多个属性。属性值可以是一个 string 或者一个 URL，并且可以和大部分元素进行组合，包括&lt;audio&gt;， &lt;embed&gt;， &lt;iframe&gt;，&lt;img&gt;，&lt;link&gt;， &lt;object&gt;， &lt;source&gt;(en-US) ， &lt;track&gt;，和 &lt;video&gt;。 itemrefitemref 全局属性 不具有 itemscope 属性的元素的后代，才可以与具有 itemref 的元素关联。itemref 提供了元素 id（并不是 itemid）的列表，并具有文档其他地方的额外属性。 itemref 属性只能在指定了 itemscope 的元素上指定。 itemscopeitemscope 是一个布尔值的 全局属性 。它定义了一个与元数据关联的数据项。就是说一个元素的 itemscope 属性会创建一个项，包含了一组与元素相关的键值对。 itemtypeitemtype 全局属性 指定了词汇的 URL，它将会用于定义数据结构中的 itemprop（条目属性）。itemscope 用于设置词汇的生效范围，其中词汇在数据结构中由 itemtype 设置。 langlang 全局属性 参与了元素语言的定义。这个语言是不可编辑元素写入的语言，或者可编辑元素应该写入的语言。 partpart 全局属性 包含一个以元素中 part 属性名称组成的列表，该列表以空格分隔。通过 Part 的名称，可以使用 CSS 伪元素“::part”来选择 shadow 树中指定元素并设置其样式。 popover全局属性 popover 用来指定一个元素为弹出式元素。 slotslot 全局属性 将一个（shadow DOM ）shadow 树中的槽分配给一个元素：带有 slot 属性的元素分配给由 &lt;slot&gt; 创建的槽，它的 name 属性的值匹配 slot 属性的值。 spellcheckspellcheck 全局属性是枚举属性，定义是否可以检查元素的拼写错误。它可以具有以下值： true, 设置在可能的情况下会去检查元素内容的拼写错误; false, 设置在可能的情况下关闭对元素内容拼写检查。 stylestyle 全局属性 包含应用到元素的 CSS 样式声明。要注意样式最好定义在单独的文件中。这个属性以及 &lt;style&gt; 元素的主要目的是快速装饰。例如用于测试目的。 tabindextabindex 全局属性 指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航。 title全局属性 title 包含代表与它所属的元素有关的咨询信息的文本。 title 属性的主要用途是为辅助技术标注 &lt;iframe&gt; 元素。 title 属性也可以用来标注数据表格中的控件。 translate全局属性 translate 是一种枚举(en-US)属性，用来规定对应元素的可翻译属性值及其 Text(en-US) 子节点内容是否跟随系统语言作出对应的翻译变化。 空字符串或 yes，意味着网页在进行本地化的时候，对应内容要被翻译。 no，意味着对应的内容无需做任何翻译。 HTML属性集合acceptaccept 属性的值是一个以逗号分隔的列表，其中包含一个或多个文件类型，或唯一的文件类型指定符，用于描述允许使用的文件类型。 12345&lt;label for=&quot;movie&quot;&gt;Choose a movie to upload:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;movie&quot; accept=&quot;video/*&quot; /&gt;&lt;label for=&quot;poster&quot;&gt;Choose a poster:&lt;/label&gt;&lt;input type=&quot;file&quot; name=&quot;poster&quot; accept=&quot;image/png, image/jpeg&quot; multiple /&gt; 字符串 audio/* 意为 “任何音频文件”。 字符串 video/* 意为 “任何视频文件”。 字符串 image/* 意为 “任何图像文件”。 包含multiple属性可以同时选择多个文件。 autocompleteHTML autocomplete 属性允许 web 开发人员指定用户代理是否有权限在填写表单字段值时提供自动帮助，并指导浏览器填写该字段的预期信息类型。 可用于以文本或数字作为输入的 &lt;input&gt; 元素、&lt;textarea&gt; 元素、&lt;select&gt; 元素和 &lt;form&gt;元素。 capture捕获属性指定（可选）捕获一个新文件，并指定使用哪个设备捕获由 accept 属性定义类型的新媒体(摄像头或麦克风)。 crossorigincrossorigin 属性在 &lt;audio&gt;、&lt;img&gt;、&lt;link&gt;、&lt;script&gt; 和&lt;video&gt; 元素中有效，它们提供对 CORS 的支持，定义该元素如何处理跨源请求，从而实现对该元素获取数据的 CORS 请求的配置。根据元素的不同，该属性可以是一个 CORS 设置属性。 网页经常请求加载其他服务器的资源。这就是 CORS 的用武之地。 跨域请求是对来自另一个域的资源（例如样式表、iframe、图像、字体或脚本）的请求 dirnamedirname 属性可用于 &lt;textarea&gt; 和 &lt;input&gt; 元素，用于描述表单提交时元素文本内容的方向性。浏览器使用该属性的值来确定用户输入的文本是从左到右还是从右到左。使用时，元素的文本方向性值将与作为字段名称的 dirname 属性值一起包含在表单提交数据中。 disabled当布尔属性 disabled 存在时，元素将不可变、不能聚焦或与表单一同提交。用户将不能在表单控件本身或其子控件进行编辑或聚焦操作。 这些元素支持 disabled 属性：&lt;button&gt;、&lt;command&gt;、&lt;fieldset&gt;、&lt;optgroup&gt;、&lt;option&gt;、&lt;select&gt;、&lt;textarea&gt; 和 &lt;input&gt;。 elementtimingelementtiming 属性用于表示某个元素被标记为由使用 “元素 “类型的 PerformanceObserver 对象跟踪。浏览器就会记住这些元素的加载时长，渲染时长等各种信息。配合PerformanceObserver API，我们就可以获得这些信息了。 该属性可应用于 &lt;img&gt;、&lt;svg&gt; 中的 &lt;image&gt; 元素、&lt;video&gt; 元素的海报图像、具有背景图像的元素以及包含文本节点（如 &lt;p&gt;）的元素。 forfor 属性是 &lt;label&gt; 和 &lt;output&gt; 允许使用的属性。在&lt;label&gt; 元素上使用时，它表示该标签所描述的表单元素。当用于 &lt;output&gt; 元素时，它允许在表示输出中使用的值的元素之间建立明确的关系。 maxmax 属性定义了包含该属性的输入可接受且有效的最大值。如果元素的值大于此值，则验证失败。该值必须大于或等于 min 属性的值。如果 max 属性存在但未指定或无效，则不会应用最大值。如果 max 属性有效，且非空值大于 max 属性允许的最大值，则约束验证将阻止表单提交。 max 属性适用于数字输入类型，包括日期、月、周、时间、本地日期时间、数字和范围类型，以及 &lt;progress&gt; 和 &lt;meter&gt; 元素。 maxlengthmaxlength 属性定义了用户可输入 &lt;input&gt; 或 &lt;textarea&gt; 的最大字符串长度。该属性的整数值必须为 0 或更高。 minmin 属性定义了包含该属性的输入可接受且有效的最小值。如果元素的值小于该值，则验证失败。该值必须小于或等于 max 属性的值。 minlengthminlength 属性定义了用户可输入 &lt;input&gt; 或 &lt;textarea&gt; 的最小字符串长度。该属性的整数值必须为 0 或更高。 multiple如果设置了布尔多重属性，则表示表单控件接受一个或多个值。该属性对电子邮件和文件输入类型以及 &lt;select&gt; 有效，用户选择多个值的方式取决于表单控件。 patternpattern 属性规定了一个表单控件的值应该匹配的正则表达式。如果一个非 null 值不满足 pattern 值设置的约束，ValidityState 对象的只读属性 patternMismatch(en-US) 将为 true。 placeholder占位符属性定义了表单控件无值时显示的文本。占位符文本应向用户简要提示应输入到控件中的预期数据类型。 readonly存在布尔只读属性时，元素不可更改，这意味着用户不能编辑控件。 relrel 属性定义了所链接的资源与当前文档的关系，在 &lt;a&gt;、&lt;area&gt; 和 &lt;link&gt; 元素上有效。支持的值取决于拥有该属性的元素。 required如果存在布尔型 required 属性，则表示用户必须为输入指定一个值，才能提交所拥有的表单。 sizesize 属性定义了 &lt;input&gt; 的宽度和 &lt;select&gt;元素的高度。对于输入，如果 type 属性是文本或密码，那么它就是字符数。该值必须是 0 或更高的整数。如果没有指定大小，或指定的值无效，则不会声明输入的大小，表单控件将采用用户代理默认的宽度。如果 CSS 目标元素的属性会影响宽度，则 CSS 优先。 stepstep属性是一个数字，用于指定数值必须遵守的粒度或关键字 any。它适用于数字输入类型，包括日期、月、周、时间、本地日期时间、数字和范围类型。","link":"/2019/11/10/%E5%89%8D%E7%AB%AF/HTML/HTML%20%E5%B1%9E%E6%80%A7/"},{"title":"HTML5","text":"新增语义化标签HTML5 添加了很多语义元素如下所示： 标签 描述 &lt;article&gt; 定义页面独立的内容区域。 &lt;aside&gt; 定义页面的侧边栏内容。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。 &lt;command&gt; 定义命令按钮，比如单选按钮、复选框或按钮 &lt;details&gt; 用于描述文档或文档某个部分的细节 &lt;dialog&gt; 定义对话框，比如提示框 &lt;summary&gt; 标签包含 details 元素的标题 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;footer&gt; 定义 section 或 document 的页脚。 &lt;header&gt; 定义了文档的头部区域 &lt;mark&gt; 定义带有记号的文本。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。 &lt;nav&gt; 定义导航链接的部分。 &lt;progress&gt; 定义任何类型的任务的进度。 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符）。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 &lt;rp&gt; 在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容。 &lt;section&gt; 定义文档中的节（section、区段）。 &lt;time&gt; 定义日期或时间。 &lt;wbr&gt; 规定在文本中的何处适合添加换行符。 HTML5 浏览器兼容性处理将 HTML5 元素定义为块元素HTML5 定了 8 个新的 HTML 语义（semantic） 元素。所有这些元素都是 块级 元素。 为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block: 123header, section, footer, aside, nav, main, article, figure { display: block; } 为 HTML 添加新元素为 HTML 添加新的元素。 该实例向 HTML 添加的新的元素，并为该元素定义样式，元素名为 ： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;为 HTML 添加新元素&lt;/title&gt; &lt;script&gt; document.createElement(&quot;myHero&quot;) &lt;/script&gt; &lt;style&gt; myHero { display: block; background-color: #ddd; padding: 50px; font-size: 30px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;myHero&gt;我的第一个新元素&lt;/myHero&gt; &lt;/body&gt;&lt;/html&gt; Internet Explorer 浏览器问题针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。 html5shiv.js 引用代码必须放在 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;渲染 HTML5&lt;/title&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; &lt;canvas&gt; HTML5 &lt;canvas&gt;元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成. &lt;canvas&gt; 标签只是图形容器，您必须使用脚本来绘制图形。 你可以通过多种方法使用 canvas 绘制路径,盒、圆、字符以及添加图像。 使用 JavaScript 来绘制图像设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。 fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。 1234var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.fillStyle=&quot;#FF0000&quot;;ctx.fillRect(0,0,150,75); moveTo(x,y) 定义线条开始坐标 lineTo(x,y) 定义线条结束坐标 绘制圆形：arc(x,y,r,start,stop) 文本：fillText(text,x,y) - 在 canvas 上绘制实心的文本。strokeText(text,x,y) - 在 canvas 上绘制空心的文本。 渐变：createLinearGradient(x,y,x1,y1) - 创建线条渐变。createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变。当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1。使用渐变，设置fillStyle或strokeStyle的值为 渐变，然后绘制形状，如矩形，文本，或一条线。使用 createLinearGradient()。使用 createRadialGradient()。 图像：把一幅图像放置到画布上, 使用以下方法:drawImage(image,x,y) localStorage 和 sessionStorage客户端存储数据的两个对象为： localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。 sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。 不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); localStorage 对象localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 12345// 存储:key=&quot;sitename&quot; 和 value=&quot;hhh&quot; 创建一个 localStorage 键/值对。localStorage.setItem(&quot;sitename&quot;, &quot;hhh&quot;);// 查找document.getElementById(&quot;result&quot;).innerHTML = &quot;网站名：&quot; + localStorage.getItem(&quot;sitename&quot;); sessionStorage 对象sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 12345678910//实例展示了用户点击按钮的次数。if (sessionStorage.clickcount){ sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;}else{ sessionStorage.clickcount=1;}document.getElementById(&quot;result&quot;).innerHTML=&quot;在这个会话中你已经点击了该按钮 &quot; + sessionStorage.clickcount + &quot; 次 &quot;; 应用程序缓存（Application Cache内存缓存）HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 HTML5 Cache Manifest 实例12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest=&quot;demo.appcache&quot;&gt; &lt;body&gt; 文档内容...... &lt;/body&gt;&lt;/html&gt; Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） Web Workerweb worker 是运行在后台的 JavaScript，不会影响页面的性能。 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 12345678910var i=0;function timedCount(){ i=i+1; postMessage(i); setTimeout(&quot;timedCount()&quot;,500);}timedCount(); 123456789101112if(typeof(Worker) !== &quot;undefined&quot;) { //检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 &quot;demo_workers.js&quot; 中的代码 if(typeof(w) == &quot;undefined&quot;) { w = new Worker(&quot;demo_workers.js&quot;); } //就可以从 web worker 发送和接收消息了。向 web worker 添加一个 &quot;onmessage&quot; 事件监听器 w.onmessage = function(event) { document.getElementById(&quot;result&quot;).innerHTML = event.data; }; } else { document.getElementById(&quot;result&quot;).innerHTML = &quot;抱歉，你的浏览器不支持 Web Workers...&quot;; } 1w.terminate(); 服务器发送事件(Server-Sent Events,SSE)HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。 接收 Server-Sent 事件通知EventSource 对象用于接收服务器发送事件通知： 12345var source=new EventSource(&quot;demo_sse.php&quot;);source.onmessage=function(event){ document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br&gt;&quot;;}; WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 1var Socket = new WebSocket(url, [protocol] ); 获取 Web Socket 连接后，可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。","link":"/2021/04/20/%E5%89%8D%E7%AB%AF/HTML/HTML5/"},{"title":"HTML 事件","text":"窗口事件属性由窗口触发该事件 (适用于 &lt;body&gt; 标签) 属性 值 描述 onafterprint script 在打印文档之后运行脚本 onafterprint script 在打印文档之后运行脚本 onbeforeprint script 在文档打印之前运行脚本 onbeforeonload script 在文档加载之前运行脚本 onblur script 当窗口失去焦点时运行脚本 onerror script 当错误发生时运行脚本 onfocus script 当窗口获得焦点时运行脚本 onhashchange script 当文档改变时运行脚本 onload script 当文档加载时运行脚本 onmessage script 当触发消息时运行脚本 onoffline script 当文档离线时运行脚本 ononline script 当文档上线时运行脚本 onpagehide script 当窗口隐藏时运行脚本 onpageshow script 当窗口可见时运行脚本 onpopstate script 当窗口历史记录改变时运行脚本 onredo script 当文档执行再执行操作（redo）时运行脚本 onresize script 当调整窗口大小时运行脚本 onstorage script 当 Web Storage 区域更新时（存储空间中的数据发生变化时）运行脚本 onundo script 当文档执行撤销时运行脚本 onunload script 当用户离开文档时运行脚本 Form 事件由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中） 属性 值 描述 onblur script 当元素失去焦点时运行脚本 onchange script 当元素改变时运行脚本 oncontextmenu script 当触发上下文菜单时运行脚本 onfocus script 当元素获得焦点时运行脚本 onformchange script 当表单改变时运行脚本 onforminput script 当表单获得用户输入时运行脚本 oninput script 当元素获得用户输入时运行脚本 oninvalid script 当元素无效时运行脚本 onreset script 当表单重置时运行脚本。HTML 5 不支持。 onselect script 当选取元素时运行脚本 onsubmit script 当提交表单时运行脚本 Keyboard 事件键盘事件 属性 值 描述 onkeydown script 当按下按键时运行脚本 onkeypress script 当按下并松开按键时运行脚本 onkeyup script 当松开按键时运行脚本 Mouse 事件由鼠标或类似用户动作触发的事件 属性 值 描述 onclick script 当单击鼠标时运行脚本 ondblclick script 当双击鼠标时运行脚本 ondrag script 当拖动元素时运行脚本 ondragend script 当拖动操作结束时运行脚本 ondragenter script 当元素被拖动至有效的拖放目标时运行脚本 ondragleave script 当元素离开有效拖放目标时运行脚本 ondragover script 当元素被拖动至有效拖放目标上方时运行脚本 ondragstart script 当拖动操作开始时运行脚本 ondrop script 当被拖动元素正在被拖放时运行脚本 onmousedown script 当按下鼠标按钮时运行脚本 onmousemove script 当鼠标指针移动时运行脚本 onmouseout script 当鼠标指针移出元素时运行脚本 onmouseover script 当鼠标指针移至元素之上时运行脚本 onmouseup script 当松开鼠标按钮时运行脚本 onmousewheel script 当转动鼠标滚轮时运行脚本 onscroll script 当滚动元素的滚动条时运行脚本 Media 事件由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 &lt;audio&gt;、&lt;embed&gt;、&lt;img&gt;、&lt;object&gt; 以及 &lt;video&gt;） 属性 值 描述 onabort script 当发生中止事件时运行脚本 oncanplay script 当媒介能够开始播放但可能因缓冲而需要停止时运行脚本 oncanplaythrough script 当媒介能够无需因缓冲而停止即可播放至结尾时运行脚本 ondurationchange script 当媒介长度改变时运行脚本 onemptied script 当媒介资源元素突然为空时（网络错误、加载错误等）运行脚本 onended script 当媒介已抵达结尾时运行脚本 onerror script 当在元素加载期间发生错误时运行脚本 onloadeddata script 当加载媒介数据时运行脚本 onloadedmetadata script 当媒介元素的持续时间以及其他媒介数据已加载时运行脚本 onloadstart script 当浏览器开始加载媒介数据时运行脚本 onpause script 当媒介数据暂停时运行脚本 onplay script 当媒介数据将要开始播放时运行脚本 onplaying script 当媒介数据已开始播放时运行脚本 onprogress script 当浏览器正在取媒介数据时运行脚本 onratechange script 当媒介数据的播放速率改变时运行脚本 onreadystatechange script 当就绪状态（ready-state）改变时运行脚本 onseeked script 当媒介元素的定位属性 [1] 不再为真且定位已结束时运行脚本 onseeking script 当媒介元素的定位属性为真且定位已开始时运行脚本 onstalled script 当取回媒介数据过程中（延迟）存在错误时运行脚本 onsuspend script 当浏览器已在取媒介数据但在取回整个媒介文件之前停止时运行脚本 ontimeupdate script 当媒介改变其播放位置时运行脚本 onvolumechange script 当媒介改变音量亦或当音量被设置为静音时运行脚本 onwaiting script 当媒介已停止播放但打算继续播放时运行脚本 其他事件 属性 值 描述 onshow script 当 &lt;menu&gt; 元素在上下文显示时触发 ontoggle script 当用户打开或关闭 &lt;details&gt; 元素时触发","link":"/2020/04/09/%E5%89%8D%E7%AB%AF/HTML/HTML%E4%BA%8B%E4%BB%B6/"},{"title":"7种form表单提交方式","text":"无刷新页面提交表单表单可实现无刷新页面提交，无需页面跳转，如下，通过一个隐藏的iframe实现，form表单的target设置为iframe的name名称，form提交目标位当前页面iframe则不会刷新页面 1234&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; target=&quot;targetIfr&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/form&gt; &lt;iframe name=&quot;targetIfr&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt; 通过type=submit提交一般表单提交通过type=submit实现，input type=”submit”,浏览器显示为button按钮，通过点击这个按钮提交表单数据跳转到/url.do 1234&lt;form action=&quot;/url.do&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 阻止新页面跳转：从前面可以知道，form 表单的提交会伴随着跳转到action中指定 的url 链接，为了阻止这一行为，可以通过设置一个隐藏的iframe 页面，并将form 的target 属性指向这个iframe，当前页面iframe则不会刷新页面。 123456&lt;form action=&quot;http://localhost:3008/user&quot; method=&quot;POST&quot; name=&quot;post提交&quot; target=&quot;targetIfr&quot;&gt; &lt;p&gt;name: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;iframe name=&quot;targetIfr&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt; 12345&lt;form action=&quot;http://localhost:3008/user&quot; method=&quot;GET&quot; name=&quot;get提交&quot;&gt; &lt;p&gt;name: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; form 的提交行为需要通过type=submit实现form 中的method 属性不指定时， form 默认的提交方式为 get请求。form 表单的提交后会有默认行为，会跳转刷新到action 的页面form 表单的提交方式，请求头默认的content-type 为 x-www-form-urlencoded当一个form 表单内部，所有的input 中只有一个 type=’text’ 的时候，enter 键会有默认的提交行为（注意前提条件）。 js提交form表单js事件触发表单提交，通过button、链接等触发事件，js调用submit()方法提交表单数据，jquery通过submit()方法 123&lt;form id=&quot;form&quot; action=&quot;/url.do&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/form&gt; 12js: document.getElementById(&quot;form&quot;).submit();jquery: $(&quot;#form&quot;).submit(); 脚本触发form 表单的提交行为js事件触发表单提交，通过button、链接等触发事件，js调用submit()方法提交表单数据，jquery通过submit()方法 123456789101112&lt;form action=&quot;http://localhost:3008/user&quot; method=&quot;POST&quot; name=&quot;jsForm&quot; target=&quot;targetIfr&quot; id=&quot;jsForm&quot;&gt; &lt;p&gt;name: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;!-- 通过jquery 进行表单的提交 存在问题，并阻止页面跳转刷新--&gt; &lt;form action=&quot;http://localhost:3008/user&quot; method=&quot;POST&quot; name=&quot;jqueryForm&quot; target=&quot;targetIfr&quot; id=&quot;jqueryForm&quot;&gt; &lt;p&gt;name: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/p&gt; &lt;p&gt;password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/p&gt; &lt;button id=&quot;jqbtn&quot;&gt;提交&lt;/button&gt; &lt;/form&gt; 12345678910111213// jsvar btn = document.getElementById('btn')var jsForm = document.getElementById('jsForm')btn.onclick = function () {jsForm.submit()}// jquery$('#jqbtn').click(function () {$('#jqueryForm').submit(function () {console.log('submit success')return false})}) 通过脚本提交行为依然存在跳转 新页面刷新的问题脚本中可以通过阻止默认行为来禁止页面跳转 ajax异步提交表单数据采用ajax异步方式，通过js获取form中所有input、select等组件的值，将这些值组成Json格式，通过异步的方式与服务器端进行交互，一般将表单数据传送给服务器端，服务器端处理数据并返回结果信息等 1234567891011121314&lt;form id=&quot;form&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;/&gt;&lt;/form&gt;var params = {&quot;name&quot;, $(&quot;#name&quot;).val()} $.ajax({ type: &quot;POST&quot;, url: &quot;/url.do&quot;, data: params, dataType : &quot;json&quot;, success: function(respMsg){ } }); 通过ajax 请求模拟form 的提交需要注意 form 表单内 不允许 的存在，否则会和ajax 自身的请求相冲突ajax 请求中，默认的content-type 为’formdata’,可根据自己的需要修改后台对不同的content-type 请求头的处理如下：// 处理请求 的content-type 为application/jsonapp.use(bodyParser.json())//处理请求的content-type 为application/x-www-form-urlencodedapp.use(bodyParser.urlencoded({extended: false}))ajax 请求需要处理跨域问题，而form 表单的默认提交不需要，原因是，原页面用form 提交到另一个域名之后，原脚本无法获取响应的内容，所以浏览器认为这是安全的，而ajax 需要处理响应的内容，浏览器则认为这是一种跨域的行为为了解决ajax 的跨域问题，需要在后台的代码中加入跨域的处理const cors = require(“cors”)// 解决跨域app.use(cors()) 页面无跳转如果通过form表单提交请求服务端去下载文件，这时当前页面不会发生跳转，服务端返回void，通过response 去写文件数据，页面会显示下载文件。 1234567891011121314151617181920212223242526&lt;form action=&quot;/url.do&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;@RequestMapping(value = &quot;/url&quot;) public void exportFile(HttpServletRequest req, HttpServletResponse response, String rptId) throws Exception { OutputStream out = null; try { String rptName = &quot;file&quot;; String fileName = new String((rptName + excelAble.getFileSuffix()).getBytes(&quot;GBK&quot;), &quot;8859_1&quot;); response.reset(); response.setContentType(&quot;application/octec-stream&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment; filename=&quot; + fileName); out = response.getOutputStream(); excelAble.exportFile(out); } catch (Exception e) { logger.error(e); } finally { if (out != null) { out.close(); } } } form表单上传文件使用form表单进行上传文件需要为form添加enctype=”multipart/form-data” 属性，除此之外还需要将表单的提交方法改成post,如下 method=”post”, input type的类型需要设置为file 1234&lt;form action=&quot;/url.do&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;name&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;","link":"/2019/10/09/%E5%89%8D%E7%AB%AF/HTML/form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/"},{"title":"JSX 基本语法","text":"JSX 基本语法规则 当遇到&lt;&gt;就会解析为标签：如果是 html 语法标准的标签就会直接解析为同名元素，比如 nav 或者 Nav 等 html 语法标准的标签不能做为组件的标签使用。 如果是其他标签需要特别解析就会创建一个对象即组件。而 vue 是在编译时 vue 文件中导出一个对象，导出的对象当做标签用。 在使用标签时同样如果是驼峰命名在当做标签使用时可以用连字符号。 遇到 { } 的就会以 JS 的语法解析，{ } 中的就是 js 变量或者 js 表达式，标签中的 js代码必须用 { } 包含。 只有一个根标签。 样式的类名指定不用用 class,要用 className。 内联样式，要用 style={ {key:value } } 的形式去写。 注释：{/* ….. */} 基本用法创建 Vnodes：Vue 提供了一个 h() 函数用于创建 vnodes。 123456789import { h } from 'vue'const vnode = h( 'div', // type { id: 'foo', class: 'bar' }, // props [ /* children */ ]) h() 函数的使用方式： 12345678910111213141516171819202122232425262728293031323334// 除了类型必填以外，其他的参数都是可选的h('div')h('div', { id: 'foo' })// attribute 和 property 都能在 prop 中书写// Vue 会自动将它们分配到正确的位置h('div', { class: 'bar', innerHTML: 'hello' })// 像 `.prop` 和 `.attr` 这样的的属性修饰符// 可以分别通过 `.` 和 `^` 前缀来添加h('div', { '.name': 'some-name', '^width': '100' })// 类与样式可以像在模板中一样// 用数组或对象的形式书写h('div', { class: [foo, { bar }], style: { color: 'red' } })// 事件监听器应以 onXxx 的形式书写h('div', { onClick: () =&gt; {} })// children 可以是一个字符串h('div', { id: 'foo' }, 'hello')// 没有 props 时可以省略不写h('div', 'hello')h('div', [h('span', 'hello')])// children 数组可以同时包含 vnodes 与字符串h('div', ['hello', h('span', 'hello')])const vnode = h('div', { id: 'foo' }, [])vnode.type // 'div'vnode.props // { id: 'foo' }vnode.children // []vnode.key // null 组件树中的 vnodes 必须是唯一的。 如果想在页面上渲染多个重复的元素或者组件，你可以使用一个工厂函数来做这件事。 12345678function render() { return h( 'div', Array.from({ length: 20 }).map(() =&gt; { return h('p', 'hi') }) )} render 函数： 使用 render() 函数可以用 js 语言来构建 DOM。 Vue.js 还提供了 render() 函数来创建 HTML。让我们可以通过 JS 逻辑代码，更灵活的创建 HTML。 例如在封装文章标题的 &lt;Title&gt; 组件时不确定最终生成的，具体是 h1~h6 的标签。这个时候，如果用 v-if 做判断，那么代码量太大，但用 render() 函数来实现就很简单。 vue3 的官方文档中，render 的参数都是用 h() 来表示。 模板语法template 常用指令：v-html | v-text、v-if、v-for、v-moda l等。但是 template 的指令在JSX 是无法使用的，所以需要使用 JSX 的语法。 v-html | v-text 在 JSX 里面，如果要设置 dom 元素的 innerHTML，就用到 domProps。 12345678render() { const { htmlCode } = this return ( &lt;div&gt; &lt;div domPropsInnerHTML={htmlCode}&gt;&lt;/div&gt; &lt;/div&gt; ); } v-on 以 on 开头，并跟着大写字母的 props 会被当作事件监听器。比如，onClick 与模板中的 @click 等价。使用 bind，或者箭头函数来传参。 123456789101112131415161718192021222324h( 'button', { onClick(event) { /* ... */ } }, 'click me')&lt;button type=&quot;button&quot; onClick={this.handleClick.bind(this, event)}&gt; click me&lt;/button&gt;&lt;button onClick={(event) =&gt; { /* ... */ }}&gt; click me&lt;/button&gt; v-model v-model 指令扩展为 modelValue 和 onUpdate:modelValue 在模板编译过程中，必须自己提供这些 props。 1234567891011export default { props: ['modelValue'], emits: ['update:modelValue'], setup(props, { emit }) { return () =&gt; h(SomeComponent, { modelValue: props.modelValue, 'onUpdate:modelValue': (value) =&gt; emit('update:modelValue', value) }) }} 属性绑定（class，style，props，on）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677render:(h) =&gt; { return h('div',{ //给div绑定value属性 props: { value:'' }, //给div绑定样式 style:{ width:'30px' }, //给div绑定点击事件 on: { click: () =&gt; { console.log('点击事件') } }, })}{ // 和`v-bind:class`一样的 API 'class': { foo: true, bar: false }, // 和`v-bind:style`一样的 API style: { color: 'red', fontSize: '14px' }, // 正常的 HTML 特性 attrs: { id: 'foo' }, // 组件 props props: { myProp: 'bar' }, // DOM 属性 domProps: { innerHTML: 'baz' }, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: { click: this.clickHandler }, // 仅对于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: { click: this.nativeClickHandler }, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ { name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: { bar: true } } ], // Scoped slots in the form of // { name: props =&gt; VNode | Array&lt;VNode&gt; } scopedSlots: { default: props =&gt; createElement('span', props.text) }, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef'} style 方式内联样式可以直接写成 style=””。 在标签上使用 {…{}} 进行绑定。 1234567891011121314151617181920212223242526272829303132&lt;script&gt;export default { data() { return { backgroundColor: 'blue', styleObject: { backgroundColor: 'red', fontSize: '20px', color: '#fff' } }; }, render() { return ( &lt;div&gt; &lt;span {...{ style: { backgroundColor: this.backgroundColor }, props: { menuStyle: 'left' } }}&gt;我是蓝色背景&lt;/span&gt; &lt;span {...{ style: this.styleObject }}&gt;我是红色背景&lt;/span&gt; &lt;/div&gt; ); }};&lt;/script&gt; class 方式在 Vue 中 jsx 中可以直接写成 class=”xx”。实际上由于 class 是 JS 的保留字，因此在 DOM中其属性名为 className 而在 HTML 属性中为 class，我们也可以在 Vue 中这样写： 1&lt;div domPropsClassName=&quot;mt__xs&quot;&gt;&lt;/div&gt; 注意：如果同时写了 class=”xx” domPropsClassName=”yy” 那么后者的优先级较高，和位置无关。所以尽量还是采用 class 的写法。 在标签上使用 {…{ }} 进行绑定 12345678910111213141516171819202122232425&lt;script&gt;export default { data() { return { isBlue: true, classOjbect: ['red'] }; }, render() { return ( &lt;div&gt; &lt;span {...{ class: { blue: this.isBlue, } }}&gt;我是蓝色背景&lt;/span&gt; &lt;span {...{ class: this.classOjbect }}&gt;我是红色背景&lt;/span&gt; &lt;/div&gt; ); }};&lt;/script&gt; on 方式事件绑定需要在事件名称前端加上 on 前缀。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { methods: { handleClick() { console.log('Button clicked'); } }}&lt;/script&gt; 列表渲染v-for 12345678910111213141516171819&lt;ul&gt; &lt;li v-for=&quot;{ id, text } in items&quot; :key=&quot;id&quot;&gt; {{ text }} &lt;/li&gt;&lt;/ul&gt;//等价写法1:h( 'ul', // assuming `items` is a ref with array value items.value.map(({ id, text }) =&gt; { return h('li', { key: id }, text) })) //等价写法2: &lt;ul&gt; {items.value.map(({ id, text }) =&gt; { return &lt;li key={id}&gt;{text}&lt;/li&gt; })} &lt;/ul&gt; 条件渲染v-if 12345678&lt;div&gt; &lt;div v-if=&quot;ok&quot;&gt;yes&lt;/div&gt; &lt;span v-else&gt;no&lt;/span&gt;&lt;/div&gt;//等价写法1:h('div', [ok.value ? h('div', 'yes') : h('span', 'no')])//等价写法2:&lt;div&gt;{ok.value ? &lt;div&gt;yes&lt;/div&gt; : &lt;span&gt;no&lt;/span&gt;}&lt;/div&gt; 插槽语法插槽就是子组件中提供给父组件使用的一个占位符。 在渲染函数中，插槽可以通过 setup() 的上下文来访问。每个 slots 对象中的插槽都是一个返回 vnodes 数组的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243export default { props: ['message'], setup(props, { slots }) { return () =&gt; [ // 默认插槽： // &lt;div&gt;&lt;slot /&gt;&lt;/div&gt; h('div', slots.default()), // 具名插槽： // &lt;div&gt;&lt;slot name=&quot;footer&quot; :text=&quot;message&quot; /&gt;&lt;/div&gt; h( 'div', slots.footer({ text: props.message }) ) ] }}//等价于// 默认插槽&lt;div&gt;{this.slots.default}&lt;/div&gt;&lt;button&gt; {this.$scopedSlots.default()}&lt;/button&gt; //具名插槽&lt;div&gt;{slots.footer({ text: props.message })}&lt;/div&gt;let before = '';if (this.$scopedSlots.before) { before = this.$scopedSlots.before(props =&gt; props.text);}return (&lt;button&gt; { before } {this.$scopedSlots.default()}&lt;/button&gt;)//作用域插槽{this.$scopedSlots.default({ isAdvancedPanelShow: this.isAdvancedPanelShow})} 传递插槽 向组件传递子元素的方式与向元素传递子元素的方式有些许不同。我们需要传递一个插槽函数或者是一个包含插槽函数的对象而非是数组，插槽函数的返回值同一个正常的渲染函数的返回值一样——并且在子组件中被访问时总是会被转化为一个 vnodes 数组。 123456789101112131415161718192021//单个默认插槽h(MyComponent, () =&gt; 'hello')// 具名插槽// 注意 `null` 是必需的// 以避免 slot 对象被当成 prop 处理h(MyComponent, null, { default: () =&gt; 'default slot', foo: () =&gt; h('div', 'foo'), bar: () =&gt; [h('span', 'one'), h('span', 'two')]})//等价于// 默认插槽&lt;MyComponent&gt;{() =&gt; 'hello'}&lt;/MyComponent&gt;// 具名插槽&lt;MyComponent&gt;{{ default: () =&gt; 'default slot', foo: () =&gt; &lt;div&gt;foo&lt;/div&gt;, bar: () =&gt; [&lt;span&gt;one&lt;/span&gt;, &lt;span&gt;two&lt;/span&gt;]}}&lt;/MyComponent&gt; 插槽以函数的形式传递使得它们可以被子组件懒调用。这能确保它被注册为子组件的依赖关系，而不是父组件。这使得更新更加准确及有效。 事件修饰符事件修饰符是通过『 : 』来修饰。 .stop ： 阻止事件冒泡，在 JSX 中使用 event.stopPropagation() 来代替。 .prevent：阻止默认行为，在 JSX 中使用 event.preventDefault() 来代替。 .self：只当事件是从侦听器绑定的元素本身触发时才触发回调，使用下面的条件判断进行代替。 修饰符 前缀 .passive &amp; .capture ! .once ~ .capture.once或.once.capture ~!","link":"/2021/01/09/%E5%89%8D%E7%AB%AF/JavaScript/JSX%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"JavaScript基础知识","text":"JavaScript 是什么 JavaScript 是一门编程语言，可为网站添加交互功能（例如：游戏、动态样式、动画以及在按下按钮或收到表单数据时做出的响应等）。 JavaScript 是一种具有函数优先特性的轻量级、解释型或者说即时编译型的编程语言。 进一步说，JavaScript 是一种基于原型、多范式、单线程的动态语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 折叠：//#region //#endregion JavaScript 的实用工具 浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成 3D 图像与音频样本等等。 第三方 API —— 让开发者可以在自己的站点中整合其他内容提供者（Twitter、Facebook 等）提供的功能。 第三方框架和库 —— 用来快速构建网站和应用。 JavaScript 的特点 JavaScript 对大小写敏感，myDay 和 myday 是不同的。如果代码出现问题了，先检查一下大小写！ 外部引入JavaScript12345678910111213&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1、在head中引入--&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2、在body中引入--&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 内部引入JavaScript123456789101112131415161718192021&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;!--1、在head中引入--&gt; &lt;script&gt; …… &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2、在body中引入--&gt; &lt;script&gt; …… &lt;/script&gt; &lt;!--3、等价于上面的写法，上面是简写--&gt; &lt;script type=&quot;text/javascript&quot;&gt; …… &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 脚本调用策略要让脚本调用的时机符合预期，需要解决一系列的问题。这里看似简单，实际大有文章。最常见的问题就是：HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用文档对象模型），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将出错。 “内部”、“外部”示例中，JavaScript 在文档头部，解析 HTML 文档体之前加载并执行。这样做是有隐患的，需要使用一些结构来避免错误发生。 “内部”示例使用了以下结构： 123document.addEventListener(&quot;DOMContentLoaded&quot;, () =&gt; { // …}); 这是一个事件监听器，它监听浏览器的 DOMContentLoaded 事件，其标志了 HTML 文档体完全加载和解析。该代码块中的 JavaScript 在事件被触发后才会运行，因此避免了错误。 “外部”示例中使用了 JavaScript 的一项现代技术（defer 属性）来解决这一问题，它告知浏览器在遇到 &lt;script&gt; 元素时继续下载 HTML 内容。 1&lt;script src=&quot;script.js&quot; defer&gt;&lt;/script&gt; 上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。 解决此问题的旧方法是：把脚本元素放在文档体的底端（也就是 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。此方案的问题是：只有在所有 HTML DOM 加载完成后才开始脚本的加载/解析过程。对于有大量 JavaScript 代码的大型网站，可能会带来显著的性能损耗。 脚本阻塞问题实际有两种解决方案——async 和 defer : async：浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。这样脚本的运行次序就无法控制，只是脚本不会阻止剩余页面的显示。当页面的脚本之间彼此独立，且不依赖于本页面的其他任何脚本时，async 是最理想的选择。「无序」 添加 defer 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 jquery.js 必定加载于 script2.js 和 script3.js 之前，同时 script2.js 必定加载于 script3.js 之前。「有序」 ⭐脚本调用策略小结： 如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 async。 如果脚本需要等待页面解析，且依赖于其他脚本，调用这些脚本时应使用 defer，将关联的脚本按所需顺序置于 HTML 中。","link":"/2019/10/01/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"HTML 元素","text":"剖析 HTML 文档 12345678910&lt;!doctype html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;我的测试站点&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是我的页面&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt;: 声明文档类型。必须写在第一行，且在&lt;html&gt;标签外面。 &lt;html&gt;&lt;/html&gt;: &lt;html&gt;元素。这个元素包裹了页面中所有的内容，有时被称为根元素。 &lt;head&gt;&lt;/head&gt;:&lt;head&gt;元素。这个元素是一个容器，它包含了所有你想包含在 HTML 页面中但不在 HTML 页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述、CSS 样式、字符集声明等等。 &lt;meta charset=&quot;utf-8&quot;&gt;: &lt;meta&gt; 元素。这个元素代表了不能由其他 HTML 元相关元素表示的元数据，比如 &lt;base&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt; 或 &lt;title&gt;。charset 属性将你的文档的字符集设置为 UTF-8，其中包括绝大多数人类书面语言的大多数字符。 1234567891011121314151617181920212223242526272829配置字符编码：&lt;meta charset=&quot;utf-8&quot;&gt;针对 IE 浏览器的兼容性配置：&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;针对移动端的配置（移动端课程中会详细讲解）：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;配置网页关键字：&lt;meta name=&quot;keywords&quot; content=&quot;8-12个以英文逗号隔开的单词/词语&quot;&gt;置网页描述信息：&lt;meta name=&quot;description&quot; content=&quot;80字以内的一段话，与网站内容相关&quot;&gt;针对搜索引擎爬虫配置： &lt;meta name=&quot;robots&quot; content=&quot;此处可选值见下表&quot;&gt;配置网页作者： &lt;meta name=&quot;author&quot; content=&quot;tony&quot;&gt;配置网页生成工具：&lt;meta name=&quot;generator&quot; content=&quot;Visual Studio Code&quot;&gt;配置定义网页版权信息： &lt;meta name=&quot;copyright&quot; content=&quot;2023-2027©版权所有&quot;配置网页自动刷新：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10;url=http://www.baidu.com&quot;&gt; &lt;title&gt;&lt;/title&gt;: &lt;title&gt; 元素。这设置了页面的标题，也就是出现在该页面加载的浏览器标签中的内容。当页面被加入书签时，页面标题也被用来描述该页面。 &lt;body&gt;&lt;/body&gt;: &lt;body&gt; 元素。包含了你访问页面时所有显示在页面上的内容，包含文本、图片、视频、游戏、可播放音频轨道等等。 HTML 中的 head 部分是不会被显示在 Web 浏览器中的。 HTML 标签不区分大小写，从一致性、可读性来说，最好仅使用小写字母。 三种 html 页面自动刷新的方式 页面自动刷新：把如下代码加入&lt;head&gt;区域中&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;,其中20指每隔20秒刷新一次页面. 页面自动跳转：把如下代码加入&lt;head&gt;区域中&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;,其中20指隔20秒后跳转到 http://www.jb51.net 页面 页面自动刷新js版&lt;script language=&quot;JavaScript&quot;&gt;function myrefresh(){window.location.reload();}setTimeout('myrefresh()',1000); //指定1秒刷新一次&lt;/script&gt; 块级元素和内联元素 块级元素在页面中以块的形式展现。 独占一行（排版标签都是块级元素）。 任何跟在块级元素后面的内容也会出现在新的行上。 块级元素通常是页面上的结构元素。例如，一个块级元素可能代表标题、段落、列表、导航菜单或页脚。 一个块级元素不会嵌套在一个内联元素里面，但它可能嵌套在另一个块级元素里面。 &lt;p&gt; 是一个块级元素。 内联元素通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。 内联元素不独占一行，不会导致文本换行。 它通常与文本一起使用，例如，&lt;a&gt; 元素创建一个超链接，&lt;em&gt; 和 &lt;strong&gt;等元素创建强调。 位图和矢量图 位图使用像素网格来定义，一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.) jpg 格式： 概述：扩展名为 .jpg 或 .jpeg ，是一种有损的压缩格式（把肉眼不容易观察出来的细节丢弃了）。 主要特点：支持的颜色丰富、占用空间较小、不支持透明背景、不支持动态图。 使用场景：对图片细节没有极高要求的场景，例如：网站的产品宣传图等 。—— 该格式网页中很常见。 png 格式： 概述：扩展名为 .png ，是一种无损的压缩格式，能够更高质量的保存图片。 主要特点：支持的颜色丰富、占用空间略大、支持透明背景、不支持动态图。 使用场景：①想让图片有透明背景；②想更高质量的呈现图片；例如 ：公司logo图、重要配图等。 bmp 格式： 概述：扩展名为 .bmp ，不进行压缩的一种格式，在最大程度上保留图片更多的细节。 主要特点：支持的颜色丰富、保留的细节更多、占用空间极大、不支持透明背景、不支持动态图。 使用场景：对图片细节要求极高的场景，例如：一些大型游戏中的图片 。（网页中很少使用） gif 格式： 概述：扩展名为 .gif ，仅支持256种颜色，色彩呈现不是很完整。 主要特点：支持的颜色较少、支持简单透明背景、支持动态图。 使用场景：网页中的动态图片。 webp 格式： 概述：扩展名为 .webp ，谷歌推出的一种格式，专门用来在网页中呈现图片。 主要特点：具备上述几种格式的优点，但兼容性不太好，一旦使用务必要解决兼容性问题。 使用场景：网页中的各种图片。 base64 格式： 本质：一串特殊的文本，要通过浏览器打开，传统看图应用通常无法打开。 原理：把图片进行 base64 编码，形成一串文本。 如何生成：靠一些工具或网站。 如何使用：直接作为 img 标签的 src 属性的值即可，并且不受文件位置的影响。 使用场景：一些较小的图片，或者需要和网页一起加载的图片。 矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG 格式可以让我们创造用于 Web 的精彩的矢量图形。 将 SVG 添加到页面要通过 &lt;img&gt; 元素嵌入 SVG，你只需要按照预期的方式在 src 属性中引用它。你将需要一个height或width属性（或者如果你的 SVG 没有固有的宽高比）。 12345&lt;img src=&quot;equilateral.svg&quot; alt=&quot;triangle with all three sides equal&quot; height=&quot;87px&quot; width=&quot;100px&quot; /&gt; HTML 中引入 SVG 代码123&lt;svg width=&quot;300&quot; height=&quot;200&quot;&gt; &lt;rect width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;green&quot; /&gt;&lt;/svg&gt; 路径相对路径：以当前位置作为参考点，去建立路径。 注意点： 相对路径中的 ./ 可以省略不写。 相对路径依赖的是当前位置，后期若调整了文件位置，那么文件中的路径也要修改。 绝对路径：以根位置作为参考点，去建立路径。 本地绝对路径： E:/a/b/c/奥特曼.jpg 。（很少使用） 网络绝对路径： http://www.atguigu.com/images/index_new/logo.png 。 注意点： 使用本地绝对路径，一旦更换设备，路径处理起来比较麻烦，所以很少使用。 使用网络绝对路径，确实方便，但要注意：若服务器开启了防盗链，会造成图片引入失败。 HTML 实体在 HTML 中我们可以用一种特殊的形式的内容，来表示某个符号，这种特殊形式的内容，就是 HTML 实 体。比如小于号 &lt; 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须 在 HTML 源码中插入字符实体。 字符实体由三部分组成：一个 &amp; 和 一个实体名称（或者一个 # 和 一个实体编号），最后加上一 个分号 ; 。 语义化标签语义化标签：用特定的标签，去表达特定的含义。 原则：标签的默认效果不重要（后期可以通过 CSS 随便控制效果），语义最重要！ 举例：对于&lt;h1&gt; 标签，效果是文字很大（不重要），语义是网页主要内容（很重要）。 优势： 代码结构清晰可读性强。 有利于 SEO（搜索引擎优化）。 方便设备解析（如屏幕阅读器、盲人阅读器等）。 常用标签排版标签 标签名 标签含义 单 / 双 标签 h1 ~ h6 标题 双 p 段落 双 div 没有任何含义，用于整体布局。 双 h1 最好写一个， h2~h6 能适当多写。 h1~h6 不能互相嵌套，例如：h1 标签中最好不要写 h2 标签了。 p 标签很特殊！它里面不能有：h1~h6 、p 、div 标签。 文本标签 用于包裹：词汇、短语等。 通常写在排版标签里面。 排版标签更宏观（大段的文字），文本标签更微观（词汇、短语）。 文本标签通常都是行内元素。 标签名 标签含义 单 / 双 标签 em 要着重阅读的内容 双 strong 十分重要的内容（语气比em要强） 双 span 没有语义，用于包裹短语的通用容器。 双 其他标签 标签名 标签含义 单 / 双 标签 br 换行 单 hr 分隔 单 pre 按原文显示(一般用于在页面中嵌入大段代码) 双 注意点： 不要用&lt;br&gt;来增加文本之间的行间隔，应使用&lt;p&gt;元素，或后面即将学到的 CSS margin 属性。 &lt;hr&gt;的语义是分隔，如果不想要语义，只是想画一条水平线，那么应当使用 CSS 完成。 元素集合&lt;a&gt;&lt;a&gt; 元素（或称锚元素）可以通过它的href属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。&lt;a&gt; 中的内容应该指明链接的目标。如果存在 href 属性，当 &lt;a&gt;元素聚焦时按下回车键就会激活它。 href：指定要跳转到的具体目标。 target：控制跳转时如何打开页面，常用值如下: _self ：在本窗口打开。 _blank ：在新窗口打开。 id：元素的唯一 标识，可用于设置锚点。 name：元素的名字，写在 a 标签中，也能设置锚点。 1&lt;a href=&quot;https://www.mozilla.com&quot;&gt; Mozilla &lt;/a&gt; &lt;abbr&gt;缩写元素&lt;abbr&gt;用于代表缩写，并且可以通过可选的 title 属性提供完整的描述。若使用 title 属性，则它必须且仅可包含完整的描述内容。 123&lt;p&gt;Using &lt;abbr&gt;HTML&lt;/abbr&gt; is fun and easy!&lt;/p&gt;&lt;p&gt;Ashok's joke made me &lt;abbr title=&quot;Laugh Out Loud&quot;&gt;LOL&lt;/abbr&gt; big time.&lt;/p&gt; &lt;abbr&gt; 与 &lt;dfn&gt; 联合使用可以定义一个更加正式的缩写： 123456789&lt;p&gt; &lt;dfn id=&quot;html&quot;&gt;&lt;abbr title=&quot;HyperText Markup Language&quot;&gt;HTML&lt;/abbr&gt; &lt;/dfn&gt; is a markup language used to create the semantics and structure of a web page.&lt;/p&gt;&lt;p&gt; A &lt;dfn id=&quot;spec&quot;&gt;Specification&lt;/dfn&gt; (&lt;abbr title=&quot;Specification&quot;&gt;spec&lt;/abbr&gt;) is a document that outlines in detail how a technology or API is intended to function and how it is accessed. &lt;address&gt;&lt;address&gt;元素 表示其中的 HTML 提供了某个人或某个组织（等等）的联系信息。 当表示一个和联系信息无关的任意的地址时，请改用&lt;p&gt;元素而不是&lt;address&gt;元素。 这个元素不能包含除联系信息之外的任何信息，比如出版日期（这应当被包含在 &lt;time&gt; 元素之中）。 通常，&lt;address&gt;元素可以放在 &lt;footer&gt; 元素之中（如果存在的话）。 1234567891011&lt;address&gt; You can contact author at &lt;a href=&quot;http://www.somedomain.com/contact&quot;&gt;www.somedomain.com&lt;/a&gt;.&lt;br /&gt; If you see any bugs, please &lt;a href=&quot;mailto:webmaster@somedomain.com&quot;&gt;contact webmaster&lt;/a&gt;.&lt;br /&gt; You may also want to visit us:&lt;br /&gt; Mozilla Foundation&lt;br /&gt; 331 E Evelyn Ave&lt;br /&gt; Mountain View, CA 94041&lt;br /&gt; USA&lt;/address&gt; &lt;area&gt;：带有可点击区域的图像&lt;area&gt;元素在图片上定义一个热点区域，可以关联一个超链接。&lt;area&gt;元素仅在&lt;map&gt;元素内部使用。 1234&lt;map name=&quot;primary&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;200,250,25&quot; href=&quot;another.htm&quot; /&gt; &lt;area shape=&quot;default&quot; nohref /&gt;&lt;/map&gt; &lt;article&gt;&lt;article&gt; 元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 123456789101112131415&lt;article class=&quot;forecast&quot;&gt; &lt;h1&gt;Weather forecast for Seattle&lt;/h1&gt; &lt;article class=&quot;day-forecast&quot;&gt; &lt;h2&gt;03 March 2018&lt;/h2&gt; &lt;p&gt;Rain.&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;day-forecast&quot;&gt; &lt;h2&gt;04 March 2018&lt;/h2&gt; &lt;p&gt;Periods of rain.&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;day-forecast&quot;&gt; &lt;h2&gt;05 March 2018&lt;/h2&gt; &lt;p&gt;Heavy rain.&lt;/p&gt; &lt;/article&gt;&lt;/article&gt; &lt;aside&gt;&lt;aside&gt; 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框。 12345678&lt;article&gt; &lt;p&gt; 迪斯尼电影&lt;cite&gt;海的女儿&lt;/cite&gt;（&lt;cite&gt;The Little Mermaid&lt;/cite&gt;）于 1989 年首次登上银幕。 &lt;/p&gt; &lt;aside&gt;在首次发行期间，该片便收获了 8700 万美元的票房。&lt;/aside&gt; &lt;p&gt;更多有关该电影的信息…&lt;/p&gt;&lt;/article&gt; &lt;audio&gt;&lt;audio&gt; HTML 元素用于在文档中嵌入音频内容。&lt;audio&gt; 元素可以包含一个或多个音频资源，这些音频资源可以使用 src 属性或者 &lt;source&gt;元素来进行描述：浏览器将会选择最合适的一个来使用。也可以使用 MediaStream 将这个元素用于流式媒体。 123&lt;audio src=&quot;AudioTest.ogg&quot; autoplay&gt; Your browser does not support the &lt;code&gt;audio&lt;/code&gt; element.&lt;/audio&gt; 12345678&lt;audio controls&gt; &lt;source src=&quot;myAudio.mp3&quot; type=&quot;audio/mpeg&quot; /&gt; &lt;source src=&quot;myAudio.ogg&quot; type=&quot;audio/ogg&quot; /&gt; &lt;p&gt; Your browser doesn't support HTML5 audio. Here is a &lt;a href=&quot;myAudio.mp4&quot;&gt;link to the audio&lt;/a&gt; instead. &lt;/p&gt;&lt;/audio&gt; &lt;b&gt;提醒注意元素（&lt;b&gt;）用于吸引读者的注意到该元素的内容上（如果没有另加特别强调）。这个元素过去被认为是粗体（Boldface）元素，并且大多数浏览器仍然将文字显示为粗体。尽管如此，你不应将 &lt;b&gt; 元素用于显示粗体文字；替代方案是使用 CSS font-weight 属性来创建粗体文字。 &lt;b&gt; 应用场合如：摘要中的关键字、评论中的产品名称，或其他典型的应该加粗显示的文字（除此之外无其他特别强调）。 不要将&lt;b&gt;元素与 &lt;strong&gt;、&lt;em&gt;或&lt;mark&gt;元素混淆。 &lt;strong&gt;元素表示某些重要性的文本，&lt;em&gt;强调文本，而&lt;mark&gt;元素表示某些相关性的文本。 &lt;b&gt;元素不传达这样的特殊语义信息；仅在没有其他合适的元素时使用它。 类似的，也不要用 &lt;b&gt;元素来标记标题。如果需要表示标题，请使用 &lt;h1&gt;到 &lt;h6&gt;标签。此外，可以通过样式表来改变这些元素的的默认样式，结果就是它们并不一定都是粗体。 通过在 &lt;b&gt; 元素上添加 class 属性来表示额外的语义信息是一个很好的方式（例如 &lt;b class=&quot;lead&quot;&gt; 来表示段落中的第一句）。这可以在样式需要变动的情况下更轻松地处理不同应用场合的 &lt;b&gt; 元素，无须改动 HTML。 如果不是出于语义目的而使用 &lt;b&gt;元素，那么让文本显示粗体更好的方式是使用将 CSS 的 font-weight 属性设置为 “bold”。 1234&lt;p&gt; This article describes several &lt;b&gt;text-level&lt;/b&gt; elements. It explains their usage in an &lt;b&gt;HTML&lt;/b&gt; document.&lt;/p&gt; &lt;base&gt;&lt;base&gt; 元素指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个 &lt;base&gt;元素。 如果指定了多个 &lt;base&gt;元素，只会使用第一个 href 和 target 值，其余都会被忽略。 123&lt;base href=&quot;http://www.example.com/&quot; /&gt;&lt;base target=&quot;_blank&quot; /&gt;&lt;base target=&quot;_top&quot; href=&quot;http://www.example.com/&quot; /&gt; &lt;bdi&gt;双向隔离元素&lt;bdi&gt;告诉浏览器的双向算法将其包含的文本与周围的文本隔离，当网站动态插入一些文本且不知道所插入文本的方向性时，此功能特别有用。 1234&lt;p dir=&quot;ltr&quot;&gt; This arabic word &lt;bdi&gt;ARABIC_PLACEHOLDER&lt;/bdi&gt; is automatically displayed right-to-left.&lt;/p&gt; &lt;bdo&gt;双向文本替代元素 &lt;bdo&gt;改写了文本的方向性，使文本以不同的方向渲染呈现出来。 dir 属性： ltr: 指示文本应从左到右的方向。 rtl: 指示文本应从右到左的方向。 1&lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;This text will go right to left.&lt;/bdo&gt;&lt;/p&gt; &lt;blockquote&gt;：块级引用元素&lt;blockquote&gt; 元素（或者 HTML 块级引用元素），代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 &lt;cite&gt; 元素。 1234&lt;blockquote cite=&quot;https://www.huxley.net/bnw/four.html&quot;&gt; &lt;p&gt;Words can be like X-rays, if you use them properly—they’ll go through anything. You read and you’re pierced.&lt;/p&gt; &lt;footer&gt;—Aldous Huxley, &lt;cite&gt;Brave New World&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt; &lt;body&gt;body 元素表示文档的内容。必须是 html 元素的直接子元素。 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Document title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This is a paragraph&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; &lt;br&gt;&lt;br&gt; 元素在文本中生成一个换行（回车）符号。此元素在写诗和地址时很有用，这些地方的换行都非常重要。 不要用 &lt;br&gt;来增加文本之间的行间隔；应使用 CSS margin 属性或&lt;p&gt; 元素。 12Mozilla Foundation&lt;br /&gt;1981 Landings Drive&lt;br /&gt; &lt;button&gt;&lt;button&gt; 元素表示一个可点击的按钮，可以用在表单或文档其他需要使用简单标准按钮的地方。 &lt;canvas&gt;&lt;canvas&gt;元素可被用来通过 JavaScript（Canvas API 或 WebGL API）绘制图形及图形动画。 123456789&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; 抱歉，你的浏览器不支持 canvas 元素 （这些内容将会在不支持&amp;lt;canvas%gt;元素的浏览器或是禁用了 JavaScript 的浏览器内渲染并展现）&lt;/canvas&gt;var canvas = document.getElementById(&quot;canvas&quot;);var ctx = canvas.getContext(&quot;2d&quot;);ctx.fillStyle = &quot;green&quot;;ctx.fillRect(10, 10, 100, 100); &lt;caption&gt;&lt;caption&gt; 元素 (or HTML 表格标题元素) 展示一个表格的标题，它常常作为&lt;table&gt; 的第一个子元素出现，同时显示在表格内容的最前面，但是，它同样可以被 CSS 样式化，所以，它同样可以出现在任何一个一个相对于表格的做任意位置。 当 &lt;table&gt; 元素是&lt;caption&gt; 的父元素，caption 是&lt;figure&gt; 元素的唯一后代的时候，使用&lt;figcaption&gt;元素替代 caption 元素。 &lt;cite&gt;引用（Citation）标签 (&lt;cite&gt;) 表示一个作品的引用，且必须包含作品的标题。这个引用可能是一个根据适当的上下文约定关联引用的元数据的缩写。 通常，浏览器默认使用斜体来展示&lt;cite&gt;元素中的内容。可以通过指定&lt;cite&gt;元素的font-style样式来覆盖这种默认行为。 1More information can be found in &lt;cite&gt;[ISO-0000]&lt;/cite&gt;. &lt;code&gt;&lt;code&gt; 元素呈现一段计算机代码。默认情况下，它以浏览器的默认等宽字体显示。 1&lt;p&gt;Regular text. &lt;code&gt;This is code.&lt;/code&gt; Regular text.&lt;/p&gt; &lt;col&gt;&lt;col&gt;元素 定义表格中的列，并用于定义所有公共单元格上的公共语义。它通常位于&lt;colgroup&gt;元素内。 &lt;colgroup&gt;表格列组（Column Group &lt;colgroup&gt;）标签用来定义表中的一组列表。 123456789101112131415161718192021222324&lt;table&gt; &lt;caption&gt; Superheros and sidekicks &lt;/caption&gt; &lt;colgroup&gt; &lt;col /&gt; &lt;col span=&quot;2&quot; class=&quot;batman&quot; /&gt; &lt;col span=&quot;2&quot; class=&quot;flash&quot; /&gt; &lt;/colgroup&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;th scope=&quot;col&quot;&gt;Batman&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Robin&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;The Flash&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Kid Flash&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th scope=&quot;row&quot;&gt;Skill&lt;/th&gt; &lt;td&gt;Smarts&lt;/td&gt; &lt;td&gt;Dex, acrobat&lt;/td&gt; &lt;td&gt;Super speed&lt;/td&gt; &lt;td&gt;Super speed&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;data&gt;&lt;data&gt; 元素将一个指定内容和机器可读的翻译联系在一起。但是，如果内容是与时间或者日期相关的，则一定要使用 &lt;time&gt;。 123456&lt;p&gt;新产品&lt;/p&gt;&lt;ul&gt; &lt;li&gt;&lt;data value=&quot;398&quot;&gt;迷你番茄酱&lt;/data&gt;&lt;/li&gt; &lt;li&gt;&lt;data value=&quot;399&quot;&gt;巨无霸番茄酱&lt;/data&gt;&lt;/li&gt; &lt;li&gt;&lt;data value=&quot;400&quot;&gt;超级巨无霸番茄酱&lt;/data&gt;&lt;/li&gt;&lt;/ul&gt; &lt;datalist&gt;&lt;datalist&gt; 元素包含了一组 &lt;option&gt; 元素，这些元素表示其他表单控件可选值。 12345678910&lt;label &gt;Choose a browser from this list: &lt;input list=&quot;browsers&quot; name=&quot;myBrowser&quot;/&gt;&lt;/label&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Firefox&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Internet Explorer&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Opera&quot;&gt;&lt;/option&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/option&gt;&lt;/datalist&gt; &lt;dd&gt;&lt;dd&gt;元素（HTML 描述元素）用来指明一个描述列表 (&lt;dl&gt;) 元素中一个术语的描述。这个元素只能作为描述列表元素的子元素出现，并且必须跟着一个 &lt;dt&gt; 元素。 12345678910&lt;dl&gt; &lt;dt&gt;Beast of Bodmin&lt;/dt&gt; &lt;dd&gt;A large feline inhabiting Bodmin Moor.&lt;/dd&gt; &lt;dt&gt;Morgawr&lt;/dt&gt; &lt;dd&gt;A sea serpent.&lt;/dd&gt; &lt;dt&gt;Owlman&lt;/dt&gt; &lt;dd&gt;A giant owl-like creature.&lt;/dd&gt;&lt;/dl&gt; &lt;del&gt;&lt;del&gt;标签表示一些被从文档中删除的文字内容。比如可以在需要显示修改记录或者源代码差异的情况使用这个标签。&lt;ins&gt;标签的作用恰恰于此相反：表示文档中添加的内容。 &lt;del&gt;和 &lt;ins&gt;一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线。 1&lt;p&gt;My favorite color is &lt;del&gt;blue&lt;/del&gt; &lt;ins&gt;red&lt;/ins&gt;!&lt;/p&gt; 12&lt;p&gt;&lt;del&gt;This text has been deleted&lt;/del&gt;, here is the rest of the paragraph.&lt;/p&gt;&lt;del&gt;&lt;p&gt;This paragraph has been deleted.&lt;/p&gt;&lt;/del&gt; &lt;details&gt;&lt;details&gt;元素可创建一个组件，仅在被切换成展开状态时，它才会显示内含的信息。&lt;summary&gt;元素可为该部件提供概要或者标签。 展现组件通常在屏幕上使用一个小三角形，旋转（或扭转）以表示打开/关闭的状态，三角形旁边有一个标签。&lt;summary&gt; 元素的内容被用来作为展示小部件的标签。 一个 &lt;details&gt; 小组件可以处于两种状态之一。默认的关闭状态只显示三角形和&lt;summary&gt;内的标签（如果没有 &lt;summary&gt; 则显示用户代理定义的默认字符串）。 1234&lt;details&gt; &lt;summary&gt;Details&lt;/summary&gt; Something small enough to escape casual notice.&lt;/details&gt; &lt;dfn&gt;定义元素 &lt;dfn&gt; 表示术语的一个定义。 &lt;dialog&gt;&lt;dialog&gt; 元素表示一个对话框或其他交互式组件，例如一个可关闭警告、检查器或者窗口。 &lt;div&gt;&lt;div&gt;元素 (或 HTML 文档分区元素) 是一个通用型的流内容容器，在不使用CSS的情况下，其对内容或布局没有任何影响。 &lt;dl&gt;：描述列表&lt;dl&gt; 元素（或HTML描述列表元素）是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键 - 值对列表)。 1234567&lt;dl&gt; &lt;dt&gt;Firefox&lt;/dt&gt; &lt;dd&gt; A free, open source, cross-platform, graphical web browser developed by the Mozilla Corporation and hundreds of volunteers. &lt;/dd&gt;&lt;/dl&gt; 描述列表使用与其他列表类型不同的闭合标签——&lt;dl&gt;；此外，每一项都用 &lt;dt&gt;（description term）元素闭合。每个描述都用 &lt;dd&gt;（description definition）元素闭合。 1234567891011121314&lt;dl&gt; &lt;dt&gt;内心独白&lt;/dt&gt; &lt;dd&gt; 戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。 &lt;/dd&gt; &lt;dt&gt;语言独白&lt;/dt&gt; &lt;dd&gt; 戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。 &lt;/dd&gt; &lt;dt&gt;旁白&lt;/dt&gt; &lt;dd&gt; 戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。 &lt;/dd&gt;&lt;/dl&gt; 浏览器的默认样式会在描述列表的术语及其定义之间产生缩进。 &lt;dt&gt;&lt;dt&gt; 元素 （或 HTML 术语定义元素）用于在一个定义列表中声明一个术语。该元素仅能作为 &lt;dl&gt; 的子元素出现。通常在该元素后面会跟着 &lt;dd&gt; 元素，然而，多个连续出现的&lt;dt&gt; 元素都将由出现在它们后面的第一个 &lt;dd&gt; 元素定义。 &lt;em&gt;着重元素&lt;em&gt;标记出需要用户着重阅读的内容，&lt;em&gt;元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。 1234&lt;p&gt; In HTML 5, what was previously called &lt;em&gt;block-level&lt;/em&gt; content is now called &lt;em&gt;flow&lt;/em&gt; content.&lt;/p&gt; &lt;embed&gt;&lt;embed&gt; 元素将外部内容嵌入文档中的指定位置。此内容由外部应用程序或其他交互式内容源（如浏览器插件）提供。 1&lt;embed type=&quot;video/quicktime&quot; src=&quot;movie.mov&quot; width=&quot;640&quot; height=&quot;480&quot; /&gt; &lt;fieldset&gt;&lt;fieldset&gt; 元素用于对表单中的控制元素进行分组（也包括 label 元素）。 1234567&lt;form action=&quot;#&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Simple fieldset&lt;/legend&gt; &lt;input type=&quot;radio&quot; id=&quot;radio&quot; /&gt; &lt;label for=&quot;radio&quot;&gt;Spirit of radio&lt;/label&gt; &lt;/fieldset&gt;&lt;/form&gt; 12345678910111213&lt;form action=&quot;#&quot;&gt; &lt;fieldset disabled&gt; &lt;legend&gt;Disabled fieldset&lt;/legend&gt; &lt;div&gt; &lt;label for=&quot;name&quot;&gt;Name: &lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; value=&quot;Chris&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=&quot;pwd&quot;&gt;Archetype: &lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;pwd&quot; value=&quot;Wookie&quot; /&gt; &lt;/div&gt; &lt;/fieldset&gt;&lt;/form&gt; &lt;figcaption&gt;&lt;figcaption&gt; 元素是与其相关联的图片的说明/标题，用？于描述其父节点 &lt;figure&gt; 元素里的其他数据。这意味着 &lt;figcaption&gt; 在&lt;figure&gt; 块里是第一个或最后一个。同时 HTML Figcaption 元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明/标题。 &lt;figure&gt;&lt;figure&gt; 元素代表一段独立的内容，可能包含 &lt;figcaption&gt; 元素定义的说明元素。该插图、标题和其中的内容通常作为一个独立的引用单元。 通常，&lt;figure&gt;的内容为图像、插图、图表、代码片段等，在文档的主内容流中引用，但可以移动到文档的另一部分或附录而不影响主内容流。 &lt;footer&gt;&lt;footer&gt;元素表示最近一个章节内容或者根节点（sectioning root）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。 &lt;footer&gt;元素内的作者信息应包含在&lt;address&gt; 元素中。 &lt;form&gt;&lt;form&gt; 元素表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。 1234567&lt;form&gt; &lt;label &gt;Name: &lt;input name=&quot;submitted-name&quot; autocomplete=&quot;name&quot; /&gt; &lt;/label&gt; &lt;button&gt;Save&lt;/button&gt;&lt;/form&gt; &lt;h1&gt;&lt;h1&gt;–&lt;h6&gt; 标题 (Heading) 元素呈现了六个不同的级别的标题，&lt;h1&gt; 级别最高，而 &lt;h6&gt; 级别最低。 避免跳过某级标题：始终要从 &lt;h1&gt;开始，接下来依次使用 &lt;h2&gt; 等等。 &lt;head&gt;&lt;head&gt; 元素规定文档相关的配置信息（元数据），包括文档的标题，引用的文档样式和脚本等。 &lt;header&gt;&lt;header&gt; 元素用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素。它可能包含一些标题元素，但也可能包含其他元素，比如 Logo、搜索框、作者名称，等等。 1234&lt;header&gt; &lt;h1&gt;主页标题&lt;/h1&gt; &lt;img src=&quot;mdn-logo-sm.png&quot; alt=&quot;MDN logo&quot; /&gt;&lt;/header&gt; &lt;hgroup&gt;&lt;hgroup&gt;HTML 元素代表文档标题和与标题相关联的内容，它将一个 &lt;h1&gt;–&lt;h6&gt;元素与一个或多个 &lt;p&gt; 元素组合在一起。 1234&lt;hgroup&gt; &lt;h1&gt;Frankenstein&lt;/h1&gt; &lt;p&gt;Or: The Modern Prometheus&lt;/p&gt;&lt;/hgroup&gt; &lt;hr&gt;&lt;hr&gt; 元素表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。 &lt;html&gt;&lt;html&gt; 元素表示一个 HTML 文档的根（顶级元素），所以它也被称为根元素。所有其他元素必须是此元素的后代。 123456789&lt;!doctype html&gt;&lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;!-- … --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- … --&gt; &lt;/body&gt;&lt;/html&gt; &lt;i&gt;：斜体元素&lt;i&gt;用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。 1234&lt;p&gt; The Latin phrase &lt;i class=&quot;latin&quot;&gt;Veni, vidi, vici&lt;/i&gt; is often mentioned in music, art, and literature&lt;/p&gt; 使用 &lt;em&gt; 表示强调或重读。 使用 &lt;strong&gt; 表示重要性。 使用 &lt;mark&gt; 表示相关性。 使用 &lt;cite&gt; 标记著作名，如一本书、剧本或是一首歌。 使用 &lt;dfn&gt; 标记术语的定义实例。 最好的经验法则是：只有在没有更合适的元素时，才适合使用 &lt;b&gt;、&lt;i&gt; 或 &lt;u&gt; 来表达传统上用粗体、斜体或下划线表达的意思；而通常情况下是有更合适的元素可供使用的。&lt;strong&gt;、&lt;em&gt;、&lt;mark&gt; 或 &lt;span&gt;可能是更加合适的选择。 &lt;i&gt; 被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想…… &lt;b&gt;被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句…… &lt;u&gt; 被用来传达传统上用下划线表达的意义：专有名词，拼写错误…… &lt;iframe&gt;内联框架元素&lt;iframe&gt;表示嵌套的browsing context。它能够将另一个 HTML 页面嵌入到当前页面中。 123456&lt;iframe src=&quot;https://example.org&quot; title=&quot;iframe Example 1&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;&lt;/iframe&gt; &lt;img&gt;&lt;img&gt;元素将一张图像嵌入文档。 src 属性是必须的，它包含了你想嵌入的图片的路径。 alt 属性包含一条对图像的文本描述，这不是强制性的，但对无障碍而言，它难以置信地有用。 搜索引擎通过 alt 属性，得知图片的内容。—— 最主要的作用。 当图片无法展示时候，有些浏览器会呈现 alt 属性的值。 盲人阅读器会朗读 alt 属性的值。 在支持 srcset 的用户代理中，当使用 w 描述符时，src 属性会被忽略。当匹配了媒体条件 (max-width: 600px) 时，将加载 200 像素宽的图像（最匹配的图像），否则将加载另一幅图像。 12345&lt;img src=&quot;clock-demo-200px.png&quot; alt=&quot;Clock&quot; srcset=&quot;clock-demo-200px.png 200w, clock-demo-400px.png 400w&quot; sizes=&quot;(max-width: 600px) 200px, 50vw&quot; /&gt; &lt;input&gt;&lt;input&gt; 元素用于为基于 Web 的表单创建交互式控件，以便接受来自用户的数据。取决于设备和用户代理不同，表单可以使用各种类型的输入数据和控件。&lt;input&gt; 元素是目前是 HTML 中最强大、最复杂的元素之一，因为它有大量的输入类型和属性组合。 &lt;ins&gt;&lt;ins&gt;元素定义已经被插入文档中的文本。 &lt;del&gt; 和 &lt;ins&gt;一起使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线。 &lt;kbd&gt;键盘输入元素 &lt;kbd&gt; 用于表示用户输入，它将产生一个行内元素，以浏览器的默认 monospace 字体显示。 123456&lt;p&gt; Type the following in the Run dialog: &lt;kbd&gt;cmd&lt;/kbd&gt;&lt;br /&gt;Then click the OK button.&lt;/p&gt;&lt;p&gt;Save the document by pressing &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;S&lt;/kbd&gt;&lt;/p&gt; &lt;label&gt;&lt;label&gt; 元素（标签）表示用户界面中某个元素的说明。 &lt;legend&gt; &lt;legend&gt; 元素用于表示其父元素 &lt;fieldset&gt; 的内容标题。 123456789101112&lt;fieldset&gt; &lt;legend&gt;Choose your favorite monster&lt;/legend&gt; &lt;input type=&quot;radio&quot; id=&quot;kraken&quot; name=&quot;monster&quot; value=&quot;K&quot; /&gt; &lt;label for=&quot;kraken&quot;&gt;Kraken&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;radio&quot; id=&quot;sasquatch&quot; name=&quot;monster&quot; value=&quot;S&quot; /&gt; &lt;label for=&quot;sasquatch&quot;&gt;Sasquatch&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;radio&quot; id=&quot;mothman&quot; name=&quot;monster&quot; value=&quot;M&quot; /&gt; &lt;label for=&quot;mothman&quot;&gt;Mothman&lt;/label&gt;&lt;/fieldset&gt; &lt;li&gt;&lt;li&gt;元素（或称 HTML 列表条目元素）用于表示列表里的条目。它必须包含在一个父元素里：一个有序列表 (&lt;ol&gt;)，一个无序列表 (&lt;ul&gt;)，或者一个菜单 (&lt;menu&gt;)。在菜单或者无序列表里，列表条目通常用点排列显示；在有序列表里，列表条目通常在左边显示按升序排列的计数，例如数字或者字母。 &lt;link&gt;外部资源链接元素 (&lt;link&gt;) 规定了当前文档与外部资源的关系。该元素最常用于链接样式表，此外也可以被用来创建站点图标 (比如 PC 端的“favicon”图标和移动设备上用以显示在主屏幕的图标) 。 href 属性设置外部资源的路径。 &lt;main&gt;&lt;main&gt; 元素呈现了文档的 &lt;body&gt; 或应用的主体部分。主体部分由与文档直接相关，或者扩展于文档的中心主题、应用的主要功能部分的内容组成。 &lt;map&gt;&lt;map&gt;属性与 &lt;area&gt; 属性一起使用来定义一个图像映射 (一个可点击的链接区域). name 属性 给 map 一个名字用来查询，这个属性是必须的，值必须不能为空并且不能带空格。 1234&lt;map name=&quot;example-map-1&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;200,250,25&quot; href=&quot;another.htm&quot; /&gt; &lt;area shape=&quot;default&quot; /&gt;&lt;/map&gt; &lt;mark&gt;标记文本元素 (&lt; Mark &gt;) 表示为引用或符号目的而标记或突出显示的文本，这是由于标记的段落在封闭上下文中的相关性或重要性造成的。 1&lt;p&gt;&amp;lt;mark&amp;gt; 元素用于 &lt;mark&gt;高亮&lt;/mark&gt; 文本&lt;/p&gt; &lt;menu&gt;&lt;menu&gt; 元素呈现了一组用户可执行或激活的命令。这既包含了可能出现在屏幕顶端的列表菜单，也包含了那些隐藏在按钮之下、当点击按钮后显示出来的文本菜单。 &lt;menu&gt; 和 &lt;ul&gt; 元素都呈现了无序列表元素。最主要的区别是，&lt;ul&gt;主要是为了展示选项，而 &lt;menu&gt;则是为了交互。 12345678&lt;button type=&quot;menu&quot; menu=&quot;popup-menu&quot;&gt;Dropdown&lt;/button&gt;&lt;menu type=&quot;context&quot; id=&quot;popup-menu&quot;&gt; &lt;menuitem&gt;Action&lt;/menuitem&gt; &lt;menuitem&gt;Another action&lt;/menuitem&gt; &lt;hr /&gt; &lt;menuitem&gt;Separated action&lt;/menuitem&gt;&lt;/menu&gt; &lt;meta&gt;&lt;meta&gt; 元素表示那些不能由其他 HTML 元相关（meta-related）元素表示的元数据信息。如：&lt;base&gt;、&lt;link&gt;、&lt;script&gt;、&lt;style&gt; 或&lt;title&gt;。 1&lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meter&gt;&lt;meter&gt;元素用来显示已知范围的标量值或者分数值。 123&lt;p&gt; Heat the oven to &lt;meter min=&quot;200&quot; max=&quot;500&quot; value=&quot;350&quot;&gt;350 degrees&lt;/meter&gt;.&lt;/p&gt; 高低值区间示例：注意本例中 min 属性被省略，这是允许的，默认值为 0。 123&lt;p&gt; He got a &lt;meter low=&quot;69&quot; high=&quot;80&quot; max=&quot;100&quot; value=&quot;84&quot;&gt;B&lt;/meter&gt; on the exam.&lt;/p&gt; &lt;nav&gt;&lt;nav&gt;元素表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接。导航部分的常见示例是菜单，目录和索引。 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;noscript&gt;如果页面上的脚本类型不受支持或者当前在浏览器中关闭了脚本，则在 HTML &lt;noscript&gt; 元素中定义脚本未被执行时的替代内容。 &lt;object&gt;：引入一个外部资源&lt;object&gt; 元素（或者称作 HTML 嵌入对象元素）表示引入一个外部资源，这个资源可能是一张图片，一个嵌入的浏览上下文，亦或是一个插件所使用的资源。 1234567&lt;object type=&quot;application/pdf&quot; data=&quot;/media/examples/In-CC0.pdf&quot; width=&quot;250&quot; height=&quot;200&quot;&gt;&lt;/object&gt;&lt;object data=&quot;move.swf&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt; &lt;ol&gt;：有序列表&lt;ol&gt;元素表示有序列表，通常渲染为一个带编号的列表。 1234567&lt;ol&gt; &lt;li&gt;沿这条路走到头&lt;/li&gt; &lt;li&gt;右转&lt;/li&gt; &lt;li&gt;直行穿过第一个十字路口&lt;/li&gt; &lt;li&gt;在第三个十字路口处左转&lt;/li&gt; &lt;li&gt;继续走 300 米，学校就在你的右手边&lt;/li&gt;&lt;/ol&gt; &lt;optgroup&gt;元素 &lt;optgroup&gt; 为&lt;select&gt; 元素中的选项创建分组。 1234567891011121314&lt;select&gt; &lt;optgroup label=&quot;Group 1&quot;&gt; &lt;option&gt;Option 1.1&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;Group 2&quot;&gt; &lt;option&gt;Option 2.1&lt;/option&gt; &lt;option&gt;Option 2.2&lt;/option&gt; &lt;/optgroup&gt; &lt;optgroup label=&quot;Group 3&quot; disabled&gt; &lt;option&gt;Option 3.1&lt;/option&gt; &lt;option&gt;Option 3.2&lt;/option&gt; &lt;option&gt;Option 3.3&lt;/option&gt; &lt;/optgroup&gt;&lt;/select&gt; &lt;option&gt;元素 &lt;option&gt;用于定义在 &lt;select&gt;, &lt;optgroup&gt; 或&lt;datalist&gt;元素中包含的项。&lt;option&gt; 可以在弹出窗口和 HTML 文档中的其他项目列表中表示菜单项。 1234567891011&lt;label for=&quot;pet-select&quot;&gt;Choose a pet:&lt;/label&gt;&lt;select id=&quot;pet-select&quot;&gt; &lt;option value=&quot;&quot;&gt;--Please choose an option--&lt;/option&gt; &lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt; &lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt; &lt;option value=&quot;hamster&quot;&gt;Hamster&lt;/option&gt; &lt;option value=&quot;parrot&quot;&gt;Parrot&lt;/option&gt; &lt;option value=&quot;spider&quot;&gt;Spider&lt;/option&gt; &lt;option value=&quot;goldfish&quot;&gt;Goldfish&lt;/option&gt;&lt;/select&gt; &lt;output&gt;：计算结果&lt;output&gt; 标签表示计算或用户操作的结果。 12345&lt;form oninput=&quot;result.value=parseInt(a.value)+parseInt(b.value)&quot;&gt; &lt;input type=&quot;range&quot; name=&quot;b&quot; value=&quot;50&quot; /&gt; + &lt;input type=&quot;number&quot; name=&quot;a&quot; value=&quot;10&quot; /&gt; = &lt;output name=&quot;result&quot;&gt;&lt;/output&gt;&lt;/form&gt; &lt;p&gt;：段落&lt;p&gt;元素表示文本的一个段落。在视觉媒体中，段落通常表现为用空行和/或首行缩进与相邻段落分隔的文本块，但 HTML 段落可以是相关内容的任何结构分组，如图像或表格字段。 段落是块级元素，如果在关闭的&lt;/p&gt; 标签之前解析了另一个块级元素，则该标签将自动关闭。 &lt;picture&gt;根据屏幕匹配的不同尺寸显示不同图片，如果没有匹配到或浏览器不支持 picture 属性则使用 img 元素。 picture 元素允许我们在不同的设备上显示不同的图片，一般用于响应式。 HTML5 引入了 &lt;picture&gt; 元素，该元素可以让图片资源的调整更加灵活。 &lt;picture&gt; 元素零或多个&lt;source&gt; 元素和一个 &lt;img&gt;元素，每个 &lt;source&gt; 元素匹配不同的设备并引用不同的图像源，如果没有匹配的，就选择 &lt;img&gt; 元素的 src 属性中的 url。 注意:&lt;img&gt; 元素是放在最后一个 &lt;picture&gt; 元素之后，如果浏览器不支持该属性则显示&lt;img&gt; 元素的的图片。 1234&lt;picture&gt; &lt;source srcset=&quot;mdn-logo-wide.png&quot; media=&quot;(min-width: 600px)&quot; /&gt; &lt;img src=&quot;mdn-logo-narrow.png&quot; alt=&quot;MDN&quot; /&gt;&lt;/picture&gt; media 属性允许你提供一个用于给用户代理作为选择 &lt;source&gt;元素的依据的媒体条件 (media condition)（类似于媒体查询）。如果这个媒体条件匹配结果为 false，那么这个&lt;source&gt;元素会被跳过。 1234&lt;picture&gt; &lt;source srcset=&quot;mdn-logo.svg&quot; type=&quot;image/svg+xml&quot; /&gt; &lt;img src=&quot;mdn-logo.png&quot; alt=&quot;MDN&quot; /&gt;&lt;/picture&gt; type 属性允许你为 &lt;source&gt;元素的 srcset 属性指向的资源指定一个 MIME 类型。如果用户代理不支持指定的类型，那么这个 &lt;source&gt; 元素会被跳过。 &lt;pre&gt;&lt;pre&gt; 元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 &lt;pre&gt; 开始标签后的换行符也会被省略) 123456789101112131415161718&lt;pre&gt; L TE A A C V R A DOU LOU REUSE QUE TU PORTES ET QUI T' ORNE O CI VILISÉ OTE- TU VEUX LA BIEN SI RESPI RER - Apollinaire&lt;/pre&gt; &lt;progress&gt;&lt;progress&gt; 元素用来显示一项任务的完成进度。虽然规范中没有规定该元素具体如何显示，浏览器开发商可以自己决定，但通常情况下，该元素都显示为一个进度条形式。 1&lt;progress value=&quot;70&quot; max=&quot;100&quot;&gt;70 %&lt;/progress&gt; &lt;q&gt;引用标签 (&lt;q&gt;) 表示一个封闭的并且是短的行内引用的文本。这个标签是用来引用短的文本，所以请不要引入换行符; 对于长的文本的引用请使用 &lt;blockquote&gt; 替代。 123456&lt;p&gt; Everytime Kenny is killed, Stan will announce &lt;q cite=&quot;http://en.wikipedia.org/wiki/Kenny_McCormick#Cultural_impact&quot;&gt; Oh my God, you/they killed Kenny! &lt;/q &gt;.&lt;/p&gt; &lt;rp&gt;&lt;rp&gt;元素用于为那些不能使用 &lt;ruby&gt; 元素展示 ruby 注解的浏览器，提供随后的圆括号。 123&lt;ruby&gt; 漢 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt; 字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;rt&gt;&lt;rt&gt;元素包含字符的发音，字符在 ruby 注解中出现，它用于描述东亚字符的发音。这个元素始终在 &lt;ruby&gt; 元素中使用。 &lt;ruby&gt;&lt;ruby&gt; 元素被用来展示东亚文字注音或字符注释。 123&lt;ruby&gt; 漢 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt; 字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; &lt;s&gt;&lt;s&gt; 元素使用删除线来渲染文本。使用&lt;s&gt;元素来表示不再相关，或者不再准确的事情。但是当表示文档编辑时，不提倡使用 &lt;s&gt; ；为此，提倡使用 &lt;del&gt;和 &lt;ins&gt; 元素。 123&lt;s&gt;Today's Special: Salmon&lt;/s&gt; SOLD OUT&lt;br&gt;&lt;span style=&quot;text-decoration:line-through;&quot;&gt;Today's Special: Salmon&lt;/span&gt; SOLD OUT &lt;samp&gt;&lt;samp&gt; 元素用于标识计算机程序输出，通常使用浏览器缺省的 monotype 字体。 1&lt;p&gt;Regular text. &lt;samp&gt;This is sample text.&lt;/samp&gt; Regular text.&lt;/p&gt; &lt;script&gt;&lt;script&gt;元素用于嵌入可执行代码或数据，这通常用作嵌入或者引用 JavaScript 代码。&lt;script&gt; 元素也能在其他语言中使用，比如 WebGL 的 GLSL 着色器语言和 JSON。 &lt;section&gt;&lt;section&gt; 元素表示 HTML 文档中一个通用独立章节，它没有更具体的语义元素来表示。一般来说会包含一个标题。 1234&lt;section&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;p&gt;Bunch of awesome content&lt;/p&gt;&lt;/section&gt; &lt;select&gt;&lt;select&gt; 元素表示一个提供选项菜单的控件。 12345&lt;select name=&quot;select&quot;&gt; &lt;option value=&quot;value1&quot;&gt;Value 1&lt;/option&gt; &lt;option value=&quot;value2&quot; selected&gt;Value 2&lt;/option&gt; &lt;option value=&quot;value3&quot;&gt;Value 3&lt;/option&gt;&lt;/select&gt; &lt;slot&gt;&lt;slot&gt; 元素，作为 Web Component 技术套件的一部分，是 Web 组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充，这样你就可以创建单独的 DOM 树，并将它与其他的组件组合在一起。 &lt;small&gt;&lt;small&gt;元素將使文本的字体变小一号。(例如从大变成中等，从中等变成小，从小变成超小)。在 HTML5 中，除了它的样式含义，这个元素被重新定义为表示边注释和附属细则，包括版权和法律文本。 12345678&lt;p&gt;MDN Web Docs is a learning platform for Web technologies and the software that powers the Web.&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;&lt;small&gt;The content is licensed under a Creative Commons Attribution-ShareAlike 2.5 Generic License.&lt;/small&gt;&lt;/p&gt;small { font-size: 0.7em;} &lt;span&gt;&lt;span&gt;元素是短语内容的通用行内容器，并没有任何特殊语义。可以使用它来编组元素以达到某种样式意图（通过使用类或者 Id 属性），或者这些元素有着共同的属性，比如lang。应该在没有其他合适的语义元素时才使用它。&lt;span&gt; 与 &lt;div&gt; 元素很相似，但 &lt;div&gt; 是一个 块元素 而 &lt;span&gt; 则是 行内元素。 &lt;strong&gt;：粗体元素&lt;strong&gt;表示文本十分重要，一般用粗体显示。 &lt;style&gt;&lt;style&gt;元素包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是CSS的格式。 &lt;sub&gt;：下标元素&lt;sub&gt; 元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更低并且更小。 1&lt;p&gt;The chemical formula of water: H&lt;sub&gt;2&lt;/sub&gt;O&lt;/p&gt; &lt;summary&gt;&lt;summary&gt; 元素指定了 &lt;details&gt; 元素展开盒子的内容的摘要，标题或图例。点击 &lt;summary&gt; 元素可以切换父元素 &lt;details&gt; 开启和关闭的状态。 12345678&lt;details open&gt; &lt;summary&gt;概况&lt;/summary&gt; &lt;ol&gt; &lt;li&gt;手上的现钱：$500.00&lt;/li&gt; &lt;li&gt;当前发票：$75.30&lt;/li&gt; &lt;li&gt;到期日：5/6/19&lt;/li&gt; &lt;/ol&gt;&lt;/details&gt; &lt;sup&gt;：上标元素&lt;sup&gt;元素定义了一个文本区域，出于排版的原因，与主要的文本相比，应该展示得更高并且更小 1&lt;p&gt;This text is &lt;sup&gt;superscripted&lt;/sup&gt;&lt;/p&gt; &lt;table&gt;&lt;table&gt;元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。 允许的内容——按照这个顺序： 一个可选的 &lt;caption&gt; 元素 零个或多个的 &lt;colgroup&gt; 元素 一个可选的 &lt;thead&gt; 元素 下列任意一个： 零个或多个 &lt;tbody&gt; 零个或多个 &lt;tr&gt; 零个或多个 &lt;td&gt; rowspan ：指定要跨的行数。 colspan ：指定要跨的列数。 一个可选的 &lt;tfoot&gt; 元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;p&gt;含有表头的表格&lt;/p&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓&lt;/th&gt; &lt;th&gt;名&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jane&lt;/td&gt; &lt;td&gt;Doe&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;含有表头、表尾和表格主体的表格&lt;/p&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头内容 1&lt;/th&gt; &lt;th&gt;表头内容 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格主体内容 1&lt;/td&gt; &lt;td&gt;表格主体内容 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;表尾内容 1&lt;/td&gt; &lt;td&gt;表尾内容 2&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;p&gt;有列组的表格&lt;/p&gt;&lt;table&gt; &lt;colgroup span=&quot;4&quot;&gt;&lt;/colgroup&gt; &lt;tr&gt; &lt;th&gt;国家&lt;/th&gt; &lt;th&gt;首都&lt;/th&gt; &lt;th&gt;人口数量&lt;/th&gt; &lt;th&gt;语言&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;美国&lt;/td&gt; &lt;td&gt;华盛顿&lt;/td&gt; &lt;td&gt;3.09 亿&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;瑞典&lt;/td&gt; &lt;td&gt;斯德哥尔摩&lt;/td&gt; &lt;td&gt;900 万&lt;/td&gt; &lt;td&gt;瑞典语&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;有列组和列的表格&lt;/p&gt;&lt;table&gt; &lt;colgroup&gt; &lt;col style=&quot;background-color: #0f0&quot; /&gt; &lt;col span=&quot;2&quot; /&gt; &lt;/colgroup&gt; &lt;tr&gt; &lt;th&gt;青柠&lt;/th&gt; &lt;th&gt;柠檬&lt;/th&gt; &lt;th&gt;橘子&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;绿色&lt;/td&gt; &lt;td&gt;黄色&lt;/td&gt; &lt;td&gt;橙色&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;p&gt;有标题的简单表格&lt;/p&gt;&lt;table&gt; &lt;caption&gt; 美妙的标题 &lt;/caption&gt; &lt;tr&gt; &lt;td&gt;美妙的数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;tbody&gt;&lt;tbody&gt; HTML 元素封装了一系列表格的行（&lt;tr&gt; 元素），代表了它们是表格（&lt;table&gt;）主要内容的组成部分。 1234567891011121314151617181920212223242526table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;学生 ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;专业&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;3741255&lt;/td&gt; &lt;td&gt;Jones, Martha&lt;/td&gt; &lt;td&gt;计算机科学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3971244&lt;/td&gt; &lt;td&gt;Nim, Victor&lt;/td&gt; &lt;td&gt;俄国文学&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;4100332&lt;/td&gt; &lt;td&gt;Petrov, Alexandra&lt;/td&gt; &lt;td&gt;天体物理学&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; &lt;template&gt;内容模板&lt;template&gt;元素是一种用于保存客户端内容机制，该内容在加载页面时不会呈现，但随后可以在运行时使用 JavaScript 实例化。 将模板视为一个可存储在文档中以便后续使用的内容片段。虽然解析器在加载页面时确实会处理 &lt;template&gt; 元素的内容，但这样做只是为了确保这些内容有效；但元素内容不会被渲染。 123456&lt;template id=&quot;productrow&quot;&gt; &lt;tr&gt; &lt;td class=&quot;record&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/template&gt; 页面不会被渲染但是在开发者工具中可以看到。 &lt;textarea&gt;：多行纯文本编辑控件&lt;textarea&gt;元素表示一个多行纯文本编辑控件，当你希望用户输入一段相当长的、不限格式的文本，例如评论或反馈表单中的一段意见时，这很有用。 1&lt;textarea name=&quot;textarea&quot; rows=&quot;10&quot; cols=&quot;50&quot;&gt;Write something here&lt;/textarea&gt; &lt;tfoot&gt;HTML 元素&lt;tfoot&gt; 定义了一组表格中各列的汇总行。 &lt;th&gt;HTML &lt;th&gt; 元素定义表格内的表头单元格。这部分特征是由 scope 和 headers 属性准确定义的。 &lt;thead&gt;HTML 的 &lt;thead&gt;元素定义了一组定义表格的列头的行。 &lt;time&gt;标签 &lt;time&gt; 用来表示 24 小时制时间或者公历日期，若表示日期则也可包含时间和时区。 123&lt;p&gt; The concert took place on &lt;time datetime=&quot;2001-05-15 19:00&quot;&gt;May 15&lt;/time&gt;.&lt;/p&gt; &lt;title&gt;&lt;title&gt; 元素定义文档的标题，显示在浏览器的标题栏或标签页上。它只应该包含文本，若是包含有标签，则它包含的任何标签都将被忽略。 &lt;title&gt;元素始终在页面的 &lt;head&gt; 块内使用。 1&lt;title&gt;Amazing！&lt;/title&gt; &lt;tr&gt;：表格中的行&lt;tr&gt;元素定义表格中的行。同一行可同时出现&lt;td&gt;和&lt;th&gt;元素。 &lt;track&gt;&lt;track&gt; 元素被当作媒体元素&lt;audio&gt; 和 &lt;video&gt;的子元素来使用。它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕。字幕格式有 WebVTT 格式(en-US)（.vtt格式文件）— Web 视频文本字幕格式，以及指时序文本标记语言（TTML）格式。 123456789101112131415161718&lt;video controls poster=&quot;/images/sample.gif&quot;&gt; &lt;source src=&quot;sample.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;sample.ogv&quot; type=&quot;video/ogv&quot;&gt; &lt;track kind=&quot;captions&quot; src=&quot;sampleCaptions.vtt&quot; srclang=&quot;en&quot;&gt; &lt;track kind=&quot;descriptions&quot; src=&quot;sampleDescriptions.vtt&quot; srclang=&quot;en&quot;&gt; &lt;track kind=&quot;chapters&quot; src=&quot;sampleChapters.vtt&quot; srclang=&quot;en&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;sampleSubtitles_de.vtt&quot; srclang=&quot;de&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;sampleSubtitles_en.vtt&quot; srclang=&quot;en&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;sampleSubtitles_ja.vtt&quot; srclang=&quot;ja&quot;&gt; &lt;track kind=&quot;subtitles&quot; src=&quot;sampleSubtitles_oz.vtt&quot; srclang=&quot;oz&quot;&gt; &lt;track kind=&quot;metadata&quot; src=&quot;keyStage1.vtt&quot; srclang=&quot;en&quot; label=&quot;Key Stage 1&quot;&gt; &lt;track kind=&quot;metadata&quot; src=&quot;keyStage2.vtt&quot; srclang=&quot;en&quot; label=&quot;Key Stage 2&quot;&gt; &lt;track kind=&quot;metadata&quot; src=&quot;keyStage3.vtt&quot; srclang=&quot;en&quot; label=&quot;Key Stage 3&quot;&gt;&lt;/video&gt; &lt;u&gt;：未阐明的注释（下划线）元素&lt;u&gt;元素表示行内文本拥有一个非文本形式的注释，该注释需要以某种方式渲染出来。默认情况下渲染为一个实线下划线，可以用 CSS 替换。 1&lt;p&gt;You could use this element to highlight &lt;u&gt;speling&lt;/u&gt; mistakes, so the writer can &lt;u&gt;corect&lt;/u&gt; them.&lt;/p&gt; &lt;ul&gt;：无序列表&lt;ul&gt; 元素表示一系列无序的列表项目，通常渲染为项目符号列表。 123456&lt;ul&gt; &lt;li&gt;豆浆&lt;/li&gt; &lt;li&gt;油条&lt;/li&gt; &lt;li&gt;豆汁&lt;/li&gt; &lt;li&gt;焦圈&lt;/li&gt;&lt;/ul&gt; &lt;var&gt;&lt;var&gt;元素表示数学表达式或编程上下文中的变量名称。尽管该行为取决于浏览器，但通常使用当前字体的斜体形式显示。 1&lt;p&gt;一个简单的方程式：&lt;var&gt;x&lt;/var&gt; = &lt;var&gt;y&lt;/var&gt; + 2&lt;/p&gt; &lt;video&gt;&lt;video&gt; 元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 &lt;video&gt; 标签用于音频内容，但是 &lt;audio&gt; 元素可能在用户体验上更合适。 浏览器并不是都支持相同的视频格式(en-US)，所以你可以在 &lt;source&gt;(en-US) 元素里提供多个视频源，然后浏览器将会使用它所支持的第一个源。 12345678&lt;video controls&gt; &lt;source src=&quot;myVideo.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;source src=&quot;myVideo.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt; Your browser doesn't support HTML5 video. Here is a &lt;a href=&quot;myVideo.mp4&quot;&gt;link to the video&lt;/a&gt; instead. &lt;/p&gt;&lt;/video&gt; &lt;wbr&gt;&lt;wbr&gt; 元素：一个文本中的位置，其中浏览器可以选择来换行，虽然它的换行规则可能不会在这里换行。 123&lt;p&gt; http://this&lt;wbr /&gt;.is&lt;wbr /&gt;.a&lt;wbr /&gt;.really&lt;wbr /&gt;.long&lt;wbr /&gt;.example&lt;wbr /&gt;.com/With&lt;wbr /&gt;/deeper&lt;wbr /&gt;/level&lt;wbr /&gt;/pages&lt;wbr /&gt;/deeper&lt;wbr /&gt;/level&lt;wbr /&gt;/pages&lt;wbr /&gt;/deeper&lt;wbr /&gt;/level&lt;wbr /&gt;/pages&lt;wbr /&gt;/deeper&lt;wbr /&gt;/level&lt;wbr /&gt;/pages&lt;wbr /&gt;/deeper&lt;wbr /&gt;/level&lt;wbr /&gt;/pages&lt;/p&gt;","link":"/2019/11/02/%E5%89%8D%E7%AB%AF/HTML/HTML%E5%85%83%E7%B4%A0/"},{"title":"JavaScript对象基础","text":"对象基础对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）。 12345678910const person = { name: [&quot;Bob&quot;, &quot;Smith&quot;], age: 32, bio() { console.log(`${this.name[0]} ${this.name[1]} 现在 ${this.age} 岁了。`); }, introduceSelf() { console.log(`你好！我是 ${this.name[0]}。`); },}; 一个如上所示的对象被称之为对象字面量（object literal）——手动的写出对象的内容来创建一个对象。 当你想要传输一系列结构化的相关的数据项（例如，服务器发起请求以存储一些数据到数据库）时，常见的方式是使用字面量来创建一个对象。 点表示法使用点表示法（dot notation）来访问对象的属性和方法。对象的名字表现为一个命名空间（namespace）。当你想访问对象内部的属性或方法时，命名空间必须写在第一位。然后输入一个点，紧接着是你想要访问的目标——可以是简单属性的名字，或者是数组属性的一个子元素，又或者是对象的方法调用。如下所示： 12person.age;person.bio(); 子命名空间用一个对象来做另一个对象成员的值。例如将 name 成员 123456const person = { name: { first: &quot;Bob&quot;, last: &quot;Smith&quot;, },}; 需要访问这些属性，只需要链式的再使用一次点表示法，像这样： 12person.name.first;person.name.last; 括号表示法另外一种访问对象属性的方式是使用括号表示法（bracket notation） 12345person.age;person.name.first;person[&quot;age&quot;];person[&quot;name&quot;][&quot;first&quot;]; 这看起来很像访问一个数组的元素，并且基本上是相同的——使用关联了值的名称，而不是索引来选择元素。因此对象有时被称为关联数组——对象将字符串映射到值，而数组将数字映射到值。 点表示法通常优于括号表示法，因为它更简洁且更易于阅读。然而，在某些情况下你必须使用括号。例如，如果对象属性名称保存在变量中，则不能使用点表示法访问该值，但可以使用括号表示法访问该值。 在下面的示例中，logProperty() 函数可以使用 person[propertyName] 来检索 propertyName 中指定的属性的值。 12345678910111213const person = { name: [&quot;Bob&quot;, &quot;Smith&quot;], age: 32,};function logProperty(propertyName) { console.log(person[propertyName]);}logProperty(&quot;name&quot;);// [&quot;Bob&quot;, &quot;Smith&quot;]logProperty(&quot;age&quot;);// 32 设置对象成员目前我们仅仅看到了如何查询（或获取）对象成员，而且也可以通过声明设置（更新）对象成员的值（使用点表示法或括号表示法），像这样： 12person.age = 45;person[&quot;name&quot;][&quot;last&quot;] = &quot;Cratchit&quot;; 设置成员并不意味着你只能更新已经存在的属性的值和方法，你也可以创建新的成员。 1234person[&quot;eyes&quot;] = &quot;hazel&quot;;person.farewell = function () { console.log(&quot;再见！&quot;);}; 括号表示法一个有用的地方是它不仅可以动态的去设置对象成员的值，还可以动态的去设置成员的名字。假设我们想让用户能够通过在两个文本输入框中键入成员名称和值，在他们的人员数据中存储自定义的值类型。我们可以像这样获取这些值： 1234const myDataName = nameInput.value;const myDataValue = nameValue.value;person[myDataName] = myDataValue; 这是使用点表示法无法做到的，点表示法只能接受字面量的成员的名字，不接受表示名称的变量。 this 的含义当你只需要创建一个对象字面量时，this 就不是那么有用。但是如果你创建多个对象时，this 可以让你对每一个创建的对象都使用相同的方法定义。 12345678910111213const person1 = { name: &quot;Chris&quot;, introduceSelf() { console.log(`你好！我是 ${this.name}。`); },};const person2 = { name: &quot;Deepti&quot;, introduceSelf() { console.log(`你好！我是 ${this.name}。`); },}; 在本例中，尽管两个实例的方法代码完全相同，但 person1.introduceSelf() 输出“你好！我是 Chris。”，而 person2.introduceSelf() 输出“你好！我是 Deepti”。当你手工编写对象字面量时，这并不是很有用，但是当我们开始使用构造函数从单个对象定义创建多个对象时，这将是必不可少的。 this 的规则： 通过 new 创建的对象，this 指向 new 创建的对象。 call/apply/bind 方法可以操作我们给定的对象，显示绑定。 this 放在方法中，this 指向调用这个方法的对象，隐式绑定。 以上三种都不是，严格模式下 this 指向undefined，非严格模式下 this 指向 window。 箭头函数没有 this，this 从外部获取。 this 指向 在绝大多数情况下，函数的调用方式决定了 this 的值。this 不能在执行期间被赋值，并且在每次函数被调用时 this 的值也可能会不同。 当前执行上下文的一个属性，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。 无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。 12345// 在浏览器中，window 对象同时也是全局对象：console.log(this === window); // truea = 37;console.log(window.a); // 37 在函数内部，this的值取决于函数被调用的方式。 因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象，浏览器中就是 window。 12345678function f1(){ return this;}//在浏览器中：f1() === window; //在浏览器中，全局对象是 window//在 Node 中：f1() === globalThis; 然而，在严格模式下，如果进入执行环境时没有设置 this 的值，this 会保持为 undefined，如下： 123456function f2(){ &quot;use strict&quot;; // 这里是严格模式 return this;}f2() === undefined; // true 如果要想把 this 的值从一个环境传到另一个，就要用 call 或者 apply 方法。 12345678910111213// 对象可以作为 bind 或 apply 的第一个参数传递，并且该参数将绑定到该对象。var obj = {a: 'Custom'};// 声明一个变量，并将该变量作为全局对象 window 的属性。var a = 'Global';function whatsThis() { return this.a; // this 的值取决于函数被调用的方式}whatsThis(); // 'Global' 因为在这个函数中 this 没有被设定，所以它默认为 全局/ window 对象whatsThis.call(obj); // 'Custom' 因为函数中的 this 被设置为 objwhatsThis.apply(obj); // 'Custom' 因为函数中的 this 被设置为 obj 在非严格模式下使用 call 和 apply 时，如果用作 this 的值不是对象，则会被尝试转换为对象。 null 和 undefined 被转换为全局对象。 1234567function bar() { console.log(Object.prototype.toString.call(this));}bar.call(7); // [object Number]bar.call('foo'); // [object String]bar.call(undefined); // [object global] 当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。 12345678var o = { prop: 37, f: function() { return this.prop; }};console.log(o.f()); // 37 对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。 12345678910var o = { f: function() { return this.a + this.b; }};var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 构造函数构造函数只是使用 new 关键字调用的函数。当你调用构造函数时，它将： 创建一个新对象 将 this 绑定到新对象，以便你可以在构造函数代码中引用 this 运行构造函数中的代码 返回新对象 构造函数以大写字母开头，并且以它们创建的对象类型命名。 1234567891011121314151617function Person(name) { this.name = name; this.introduceSelf = function () { console.log(`你好！我是 ${this.name}。`); };}//将 Person() 作为构造函数调用const salva = new Person(&quot;Salva&quot;);salva.name;salva.introduceSelf();// &quot;你好！我是 Salva。&quot;const frankie = new Person(&quot;Frankie&quot;);frankie.name;frankie.introduceSelf();// &quot;你好！我是 Frankie。&quot; 对象原型原型链JavaScript 中所有的对象都有一个内置属性，称为它的 prototype（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成了原型链。原型链终止于拥有 null 作为其原型的对象上。 注： 指向对象原型的属性并不是 prototype。它的名字不是标准的，但实际上所有浏览器都使用 __proto__。访问对象原型的标准方法是 Object.getPrototypeOf()。 myObject 的原型是什么？为了找到答案，我们可以使用 Object.getPrototypeOf() 函数： 1Object.getPrototypeOf(myObject); // Object { } 有个对象叫 Object.prototype，它是最基础的原型，所有对象默认都拥有它。Object.prototype 的原型是 null，所以它位于原型链的终点： 一个对象的原型并不总是 Object.prototype，试试这段代码： 1234567891011const myDate = new Date();let object = myDate;do { object = Object.getPrototypeOf(object); console.log(object);} while (object);// Date.prototype// Object { }// null 这段代码创建了 Date 对象，然后遍历了它的原型链，记录并输出了原型。从中我们知道 myDate 的原型是 Date.prototype 对象，它（Date.prototype）的原型是 Object.prototype。 属性遮蔽如果你在一个对象中定义了一个属性，而在该对象的原型中定义了一个同名的属性，会发生什么？ 123456789const myDate = new Date(1995, 11, 17);console.log(myDate.getYear()); // 95myDate.getYear = function () { console.log(&quot;别的东西！&quot;);};myDate.getYear(); // '别的东西！' 鉴于对原型链的描述，这应该是可以预测的。当我们调用 getYear() 时，浏览器首先在 myDate 中寻找具有该名称的属性，如果 myDate 没有定义该属性，才检查原型。因此，当我们给 myDate 添加 getYear() 时，就会调用 myDate 中的版本。这个方法会遮蔽掉原型链上的同名方法，这叫做属性的“遮蔽”。 设置原型在 JavaScript 中，有多种设置对象原型的方法，这里我们将介绍两种：Object.create() 和构造函数。 使用 Object.createObject.create() 方法创建一个新的对象，并允许你指定一个将被用作新对象原型的对象。 12345678const personPrototype = { greet() { console.log(&quot;hello!&quot;); },};const carl = Object.create(personPrototype);carl.greet(); // hello! 这里我们创建了一个 personPrototype 对象，它有一个 greet() 方法。然后我们使用 Object.create() 来创建一个以 personPrototype 为原型的新对象。现在我们可以在新对象上调用 greet()，而原型提供了它的实现。 使用构造函数在 JavaScript 中，所有的函数都有一个名为 prototype 的属性。当你调用一个函数作为构造函数时，这个属性被设置为新构造对象的原型（按照惯例，在名为 proto 的属性中）。 因此，如果我们设置一个构造函数的 prototype，我们可以确保所有用该构造函数创建的对象都被赋予该原型： 12345678910111213const personPrototype = { greet() { console.log(`你好，我的名字是 ${this.name}！`); },};function Person(name) { this.name = name;}Object.assign(Person.prototype, personPrototype);// 或// Person.prototype.greet = personPrototype.greet; 创建了一个 personPrototype 对象，它具有 greet() 方法 创建了一个 Person() 构造函数，它初始化了要创建人物对象的名字 使用 Object.assign 将 personPrototype 中定义的方法绑定到 Person 函数的 prototype 属性上。 在这段代码之后，使用 Person() 创建的对象将获得 Person.prototype 作为其原型，其中自动包含 greet 方法。 12const reuben = new Person(&quot;Reuben&quot;);reuben.greet(); // 你好，我的名字是 Reuben！ 自有属性我们使用上面的 Person 构造函数创建的对象有两个属性： name 属性，在构造函数中设置，在 Person 对象中可以直接看到 greet() 方法，在原型中设置 我们经常看到这种模式，即方法是在原型上定义的，但数据属性是在构造函数中定义的。这是因为方法通常对我们创建的每个对象都是一样的，而我们通常希望每个对象的数据属性都有自己的值（就像这里每个人都有不同的名字）。 直接在对象中定义的属性，如这里的name，被称为自有属性，你可以使用静态方法 Object.hasOwn() 检查一个属性是否是自有属性： 1234const irma = new Person(&quot;Irma&quot;);console.log(Object.hasOwn(irma, &quot;name&quot;)); // trueconsole.log(Object.hasOwn(irma, &quot;greet&quot;)); // false 注： 你也可以在这里使用非静态方法 Object.hasOwnProperty()，但我们推荐尽可能使用 Object.hasOwn() 方法。 面向对象类与实例类的定义包括了属性和方法。 1234567class Professor properties name teaches methods grade(paper) introduceSelf() 类可以创建实例。（我们称这样创建出来的具体的人为类的实例）。 类创建实例的过程是由一个特别的函数——构造函数所完成的。 通常来说，需要将构造函数作为类定义的一部分明确声明，并且构造函数通常具有和类名相同的函数名。 123456789class Professor properties name teaches constructor Professor(name, teaches) methods grade(paper) introduceSelf() 通常使用 new 关键字来表示执行构造函数。 12345678walsh = new Professor(&quot;沃尔什&quot;, &quot;心理学&quot;);lillian = new Professor(&quot;丽莲&quot;, &quot;诗歌&quot;);walsh.teaches; // '心理学'walsh.introduceSelf(); // '我是沃尔什，我是你们的心理学老师。'lillian.teaches; // '丽莲'lillian.introduceSelf(); // '我是丽莲，我是你们的诗歌老师' 这段代码中我们创建了两个对象，这两个对象都是 Professor 类的实例。 继承容易注意到教授和学生都是人，而人是具有姓名，并且可以介绍自己的。我们可以将人定义为一个新类，即 Person 类，在 Person 类中，我们可以定义所有作为人的通用属性。接下来，我们可以定义 Professor 类和 Student 类由 Person 类派生（derive）而来，在伪代码中定义如下： 123456789101112131415161718192021222324class Person properties name constructor Person(name) methods introduceSelf()class Professor : extends Person properties teaches constructor Professor(name, teaches) methods grade(paper) introduceSelf()class Student : extends Person properties year constructor Student(name, year) methods introduceSelf() 在这种情况下，我们称 Person 类是 Professor 类和 Student 类的超类（superclass）或父类（parent class）。 反之，我们称 Professor 类和 Student 类是 Person 类的子类（subclass 或 child class）。 你可能注意到了我们在三个类中都定义了 introduceSelf() 方法。这么做的原因如下：尽管所有人都想要介绍他们自己，但是他们可能会以不同的方式去做这件事。 12345walsh = new Professor(&quot;沃尔什&quot;, &quot;心理学&quot;);walsh.introduceSelf(); // '我是沃尔什，我是你们的心理学老师。'summers = new Student(&quot;萨摩斯&quot;, 1);summers.introduceSelf(); // '我是萨摩斯，我是一年级的学生。' 我们可能会为那些不是教授或学生的人设定一个默认的打招呼方式： 12pratt = new Person(&quot;普拉特&quot;);pratt.introduceSelf(); // '我是普拉特。' 当一个方法拥有相同的函数名，但是在不同的类中可以具有不同的实现时，我们称这一特性为多态（polymorphism）。当一个方法在子类中替换了父类中的实现时，我们称之为子类重写/重载（override）了父类中的实现。 封装当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为封装（encapsulation）。 封装的好处在于，当程序员需要修改一个对象的某个操作时，程序员只需要修改对象对应方法的内部实现即可，而不需要在所有代码中找出该方法的所有实现，并逐一修改。某种意义上来说，封装在对象内部和对象外部设立了一种特别的“防火墙”。 在许多面向对象编程语言中，我们可以使用 private 关键字标记对象的私有部分，也就是外部代码无法直接访问的部分。如果一个属性在被标记为 private 的情况下，外部代码依旧尝试访问该属性，那么通常来说，计算机会抛出一个错误。 1234567891011class Student : extends Person properties private year constructor Student(name, year) methods introduceSelf() canStudyArchery() { return this.year &gt; 1 }student = new Student('Weber', 1)student.year // 错误：'year'是学生类的私有属性 也有部分语言并不采用强制措施阻止外部代码访问对象的私有属性，在这种情况下，程序员们通常会采用一些约定俗称的命名方式来标记对象的私有部分，例如将以下划线开头的变量名看作是对象的私有部分。 面向对象编程与 JavaScript 构造函数：在 JavaScript 中，构造函数可以实现类的定义，帮助我们在一个地方描述类的“形状”，包括定义类的方法。不过，原型也可以用于实现类的定义。例如，如果一个方法定义于构造函数的 prototype 属性中，那么所有由该构造函数创造出来的对象都可以通过原型使用该方法，而我们也不再需要将它定义在构造函数中。 原型链：原型链很自然地实现了继承特性。例如，如果我们由 Person 原型构造了一个 Student 类，那么我们可以继承 Person 类的 name 属性，重写 introduceSelf() 方法。 理解 JavaScript 的这一对特性与基于类的面向对象编程之间有什么不同，这一点也是十分重要的，这里我们将简要探讨二者的区别。 首先，在基于类的面向对象编程中，类与对象是两个不同的概念，对象通常是由类创造出来的实例。由此，定义类的方式（定义类的语法）和实例化对象的方式（构造函数）也是不同的。而在 JavaScript 中，我们经常会使用函数或对象字面量创建对象，也就是说，JavaScript 可以在没有特定的类定义的情况下创建对象。相对于基于类的面向对象编程来说，这种方式更为轻量，帮助我们更为方便地使用对象。 其次，尽管原型链看起来很像是继承的层级结构，并且在某些方面，原型链的行为与继承的行为也很类似，但是在其他方面，二者之间仍然存在区别。在继承方式下，当一个子类完成继承时，由该子类所创建的对象既具有其子类中单独定义的属性，又具有其父类中定义的属性（以及父类的父类，依此类推）。而在原型链中，每一个层级都代表了一个不同的对象，不同的对象之间通过 proto 属性链接起来。原型链的行为并不太像是继承，而更像是委派（delegation）。委派同样是对象中的一种编程模式。当我们要求对象执行某项任务时，在委派模式下，对象可以自己执行该项任务，或者要求另一个对象（委派的对象）以其自己的方式执行这项任务。在许多方面，相对于继承来说，委派可以更为灵活地在许多对象之间建立联系（例如，委派模式可以在程序运行时改变、甚至完全替换委派对象）。 尽管如此，构造函数和原型仍然可以在 JavaScript 中实现基于类的面向对象编程特性。但是直接使用构造函数和原型去实现这些特性（例如继承）仍是棘手的，因此，JavaScript 提供了一些额外的特性，这些特性在原型这一模型之上又抽象出一层模型，将基于类的面向对象编程中的概念映射到原型中，从而能够更为直接地在 JavaScript 中使用基于类的面向对象编程中的概念。 JavaScript 中的类类和构造函数你可以使用 class 关键字声明一个类。 1234567891011class Person { name; constructor(name) { this.name = name; } introduceSelf() { console.log(`Hi! I'm ${this.name}`); }} 在这个 Person 类的声明中，有： 一个 name 属性。 一个需要 name 参数的构造函数，这一参数用于初始化新的对象的 name 属性。 一个 introduceSelf() 方法，使用 this 引用了对象的属性。 name; 这一声明是可选的：你可以省略它，因为在构造函数中的 this.name = name; 这行代码会在初始化 name 属性前自动创建它。但是，在类声明中明确列出属性可以方便阅读代码的人更容易确定哪些属性是这个类的一部分。 你也可以在声明属性时，为其初始化一个默认值。就像这样：name = ‘’;。 构造函数使用 constructor 关键字来声明。就像在类声明外的构造函数一样，它会： 创建一个新的对象 将 this 绑定到这个新的对象，你可以在构造函数代码中使用 this 来引用它 执行构造函数中的代码 返回这个新的对象 如上文中给出的类声明的代码，你可以像这样创建和使用一个新的 Person 实例： 123const giles = new Person(&quot;Giles&quot;);giles.introduceSelf(); // Hi! I'm Giles 注意，我们使用类的名字来调用构造函数，即示例中的 Person。 如果你不需要任何特殊的初始化内容，你可以省略构造函数，默认的构造函数会被自动生成 继承使用 extends 关键字来声明这个类继承自另一个类。 12345678910111213141516171819class Professor extends Person { teaches; constructor(name, teaches) { super(name); this.teaches = teaches; } introduceSelf() { console.log( `My name is ${this.name}, and I will be your ${this.teaches} professor.`, ); } grade(paper) { const grade = Math.floor(Math.random() * (5 - 1) + 1); console.log(grade); }} 我们为 Professor 类添加了一个新的属性 teaches，就像声明的那样。 因为我们想在创建新的 Professor 时设置 teaches，我们需要声明一个需要 name 和 teaches 参数的构造函数。构造函数中需要做的第一件事是使用 super() 调用父类的构造函数，并传递 name 参数。父类的构造函数会设置 name 属性。然后 Professor 的构造函数接着设置 teaches 属性。 注： 如果子类有任何自己的初始化内容需要完成，它也必须先使用 super() 来调用父类的构造函数，并传递父类构造函数期望的任何参数。 封装12345678910111213141516class Student extends Person { #year; constructor(name, year) { super(name); this.#year = year; } introduceSelf() { console.log(`Hi! I'm ${this.name}, and I'm in year ${this.#year}.`); } canStudyArchery() { return this.#year &gt; 1; }} 在这个类的声明中，#year 是一个私有数据属性。我们可以构造一个 Student 对象，然后在内部使用 #year，但如果在类的外部尝试访问 #year，浏览器将会抛出错误： 123456const summers = new Student(&quot;Summers&quot;, 2);summers.introduceSelf(); // Hi! I'm Summers, and I'm in year 2.summers.canStudyArchery(); // truesummers.#year; // SyntaxError 私有数据属性必须在类的声明中声明，而且其名称需以 # 开头。 与私有数据属性一样，你也可以声明私有方法。而且名称也是以 # 开头，只能在类自己的方法中调用： 123456789101112131415class Example { somePublicMethod() { this.#somePrivateMethod(); } #somePrivateMethod() { console.log(&quot;You called me?&quot;); }}const myExample = new Example();myExample.somePublicMethod(); // 'You called me?'myExample.#somePrivateMethod(); // SyntaxError JSON什么是 JSON？JavaScript 对象表示法（JSON）是用于将结构化数据表示为 JavaScript 对象的标准格式，通常用于在网站上表示和传输数据（例如从服务器向客户端发送一些数据，因此可以将其显示在网页上）。 JSON 是一种按照 JavaScript 对象语法的数据格式，这是道格拉斯·克罗克福特推广的。虽然它是基于 JavaScript 语法，但它独立于 JavaScript，这也是为什么许多程序环境能够读取（解读）和生成 JSON。 JSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。这不是一个大事件——JavaScript 提供一个全局的 可访问的 JSON 对象来对这两种数据进行转换。 注： 将字符串转换为原生对象称为反序列化（deserialization），而将原生对象转换为可以通过网络传输的字符串称为序列化（serialization）。 一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 .json，还有 application/json。 JSON 结构JSON 是一个字符串，其格式非常类似于 JavaScript 对象字面量的格式。 可以在 JSON 中包含与标准 JavaScript 对象相同的基本数据类型——字符串、数字、数组、布尔值和其他对象字面量。 12345678910111213141516171819202122232425262728293031323334353637{ &quot;squadName&quot;: &quot;Super hero squad&quot;, &quot;homeTown&quot;: &quot;Metro City&quot;, &quot;formed&quot;: 2016, &quot;secretBase&quot;: &quot;Super tower&quot;, &quot;active&quot;: true, &quot;members&quot;: [ { &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] }, { &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] }, { &quot;name&quot;: &quot;Eternal Flame&quot;, &quot;age&quot;: 1000000, &quot;secretIdentity&quot;: &quot;Unknown&quot;, &quot;powers&quot;: [ &quot;Immortality&quot;, &quot;Heat Immunity&quot;, &quot;Inferno&quot;, &quot;Teleportation&quot;, &quot;Interdimensional travel&quot; ] } ]} 如果我们把字符串加载到 JavaScript 程序中，并将其解析到一个名为 superHeroes 的变量，那么我们就可以使用点/括号表示法来访问其中的数据。例如： 12superHeroes.hometown;superHeroes[&quot;active&quot;]; 为了访问层次结构中更深层次的数据，必须将所需的属性名和数组索引链接在一起。例如，访问 members 数组第二个英雄的第三个超能力，可以这样做： 1superHeroes[&quot;members&quot;][1][&quot;powers&quot;][2]; JSON 数组JSON 文本基本上看起来像字符串中的 JavaScript 对象。我们也可以将数组与 JSON 相互转换。下面也是有效的 JSON，例如： 123456789101112131415161718[ { &quot;name&quot;: &quot;Molecule Man&quot;, &quot;age&quot;: 29, &quot;secretIdentity&quot;: &quot;Dan Jukes&quot;, &quot;powers&quot;: [&quot;Radiation resistance&quot;, &quot;Turning tiny&quot;, &quot;Radiation blast&quot;] }, { &quot;name&quot;: &quot;Madame Uppercut&quot;, &quot;age&quot;: 39, &quot;secretIdentity&quot;: &quot;Jane Wilson&quot;, &quot;powers&quot;: [ &quot;Million tonne punch&quot;, &quot;Damage resistance&quot;, &quot;Superhuman reflexes&quot; ] }] 上面是完全合法的 JSON。你只需要通过数组索引就可以访问数组元素，如 [0][“powers”][0]。 JSON 是一种纯数据格式，它只包含属性，没有方法。 JSON 要求在字符串和属性名称周围使用双引号。单引号无效。 甚至一个错位的逗号或分号就可以导致 JSON 文件出错。你应该小心的检查你想使用的数据（虽然计算机生成的 JSON 很少出错，只要生成程序正常工作）。你可以通过像 JSONLint 这样的应用程序来验证 JSON。 JSON 实际上可以是任何可以有效包含在 JSON 中的数据类型的形式。比如，单个字符串或者数字就是有效的 JSON 对象。 与 JavaScript 代码中对象属性可以不加引号不同，JSON 中只有带引号的字符串可以用作属性。 对象和文本间的转换 parse()：以文本字符串形式接受 JSON 对象作为参数，并返回相应的对象。(字符串——&gt;对象：反序列化) stringify()：接收一个对象作为参数，返回一个对应的 JSON 字符串。(对象——&gt;字符串：序列化)","link":"/2019/10/09/%E5%89%8D%E7%AB%AF/JavaScript/javaScript%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"},{"title":"JavaScript语法","text":"变量变量的定义： 变量是存储值的容器。 使用关键字 let 或 var。 结尾加分号。 当需要输出的变量从未声明过，或声明过但没有赋值，最终显示出来的都是undefined字样。 变量的数据类型： 变量 解释 示例 String 字符串：使用引号括起来。 let myName = ‘冷冷’; Number 数字：无需引号。 let myAge = 25; Boolean 布尔值：无需引号。 let myCar = true; Array 数组：用于在单一引用中存储多个值的结构。 let myHouse = [1,’Jeep’,3];元素引用方法：myHouse[0],myHouse[1]… Object 对象：一切皆对象，一切皆可存储在变量里。 let a = document.querySelector(‘h1’);以及上面所有示例都是对象。 let 与 var的区别：let 是 es6 中新增命令let 和 var 的区别体现在作用域上。var 的作用域被规定为一个函数作用域，而 let 则被规定为块作用域，块作用域要比函数作用域小一些，但是如果两者既没在函数中，也没在块作用域中定义，那么两者都属于全局作用域。 全局作用域var 和 let 声明的变量在全局作用域中被定义时，两者非常相似 12let bar = 'hehe'; var baz = 'lala'; 但是，被let声明的变量不会作为全局对象window的属性，而被var声明的变量却可以 12console.log(window.bar); //undefined console.log(window.baz); // 'able' 函数作用域var 和 let 在函数作用域中声明一个变量，两个变量的意义是相同的。 123function aFun(){ let bar = 'hehe'; // 函数作用域中的变量 var baz = 'lala'; // 函数作用域中的变量 } 块作用域在块作用域中两者的区别较为明显， let只在for()循环中可用，而 var是对于包围for循环的整个函数可用 12345678910111213function aFun1(){ // i 对于for循环外的范围是不可见的(i is not defined) for(let i = 1; i&lt;5; i++){ // i只有在这里是可见的 } // i 对于for循环外的范围是不可见的(i is not defined) } function aFun2(){ // i 对于for循环外的范围是可见的 for(var i = 1;i&lt;5; i++){ // i 在for 在整个函数体内都是可见的 } // i 对于for循环外的范围是可见的 } let 和 var 重复声明var允许在同一作用域中声明同名的变量，而let不可以。 12345let me = 'foo';let me = 'bar'; //SyntaxError: Identifier 'me' has already been declaredvar me = 'foo';var me = 'bar'; //这里me被替代了，是可以重复声明的 es6 中还有一个声明变量的命令 const，const 和 let 都是在声明的块作用域中有效，但是 let 声明的变量可变，值和类型都可以改变，没有限制。const 声明额变量不能改变，所以，const 一旦声明一个变量，就必须马上初始化，不能留到以后赋值 1234const hehe; //报错，Missing initializer in const declarationconst a = 3;a = 5; //报错，Uncaught TypeError: Assignment to constant variable. 以上就是let和var在不同作用域下的区别 那么在什么情况下要用到 let 呢？let 在块作用域中有效，有的时候，我们为了降低变量污染的风险，在块作用域中使用let来代替var，这样不会污染块作用域的外部作用域，降低 bug率，使代码更安全。 在代码中尽可能多地使用 let，而不是 var。因为没有理由使用 var，除非你需要用代码支持旧版本的 Internet Explorer (它直到第 11 版才支持 let ，现代的 Windows Edge 浏览器支持的很好)。 变量提升：JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 12console.log(a);var a = 1; 上面代码首先使用console.log方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。 123var a;console.log(a);a = 1; 最后的结果是显示undefined，表示变量a已声明，但还未赋值。 但提升操作不再适用于 let 。如果将上面例子中的 var 替换成 let 将不起作用并引起一个错误。 变量作用域： 一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。合法的标识符示例：Number_hits，temp99，$credit 和_name。 var：声明一个局部变量和全局变量，可选初始化一个值。 let：声明一个块作用域的局部变量，可选初始化一个值。 const：声明一个块作用域的只读常量。 用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined。 如果访问一个未声明的变量会导致抛出一个引用错误异常。 数值类型环境中 undefined 值会被转换为 NaN。 当对一个 null 变量求值时，空值 null 在数值类型环境中会被当作 0 来对待，而布尔类型环境中会被当作 false。 对象属性被赋值为常量是不受保护的，数组的被定义为常量也是不受保护的。 在函数之外声明的变量，叫做***全局**变量，因为它可被当前文档中的任何其他代码所访问。在函数内部声明的变量，叫做**局部***变量，因为它只能在当前函数的内部访问。 ES6 前没有语句块，使用的是 var，作用域是全局范围。 ES6 中： 1234if (true) { let y = 5;}console.log(y); // ReferenceError: y 没有被声明 变量提升： JavaScript 变量的另一个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升。 JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。 关于变量命名的规则：可以给变量赋任何你喜欢的名字，但有一些限制。一般你应当坚持使用拉丁字符 (0-9,a-z,A-Z) 和下划线字符。 不应当使用规则之外的其他字符，因为它们可能引发错误，或对国际用户来说难以理解。 变量名不要以下划线开头——以下划线开头的被某些 JavaScript 设计为特殊的含义，因此可能让人迷惑。 变量名不要以数字开头。这种行为是不被允许的，并且将引发一个错误。 一个可靠的命名约定叫做 “小写驼峰命名法”，用来将多个单词组在一起，小写整个命名的第一个字母然后大写剩下单词的首字符。 让变量名直观，它们描述了所包含的数据。不要只使用单一的字母/数字，或者长句。 变量名大小写敏感——因此myage与myAge是 2 个不同的变量。 最后也是最重要的一点——应当避免使用 JavaScript 的保留字给变量命名。保留字，即是组成 JavaScript 的实际语法的单词！因此诸如 var、function、let 和 for 等，都不能被作为变量名使用。浏览器将把它们识别为不同的代码项，因此将得到错误。 数据类型字符串在 JavaScript 中，你可以选择单引号（’）、双引号（”）或反引号（`）来包裹字符串。 123const single = &quot;单引号&quot;;const double = &quot;双引号&quot;;const backtick = `反引号`; 使用反引号声明的字符串是一种特殊字符串，被称为模板字面量。在大多数情况下，模板字面量与普通字符串类似，但它具有一些特殊的属性： 你可以在其中嵌入 JavaScript 使用 ${ } 中包装 JavaScript 变量或表达式，其结果将被包含在字符串中： 12345678910111213141516const name = &quot;克里斯&quot;;const greeting = `你好，${name}`;console.log(greeting); // &quot;你好，克里斯&quot;const one = &quot;你好，&quot;;const two = &quot;请问最近如何？&quot;;const joined = `${one}${two}`;console.log(joined); // &quot;你好，请问最近如何？&quot;const song = &quot;青花瓷&quot;;const score = 9;const highestScore = 10;const output = `我喜欢歌曲《${song}》。我给它打了 ${ (score / highestScore) * 100} 分。`;console.log(output); // &quot;我喜欢歌曲《青花瓷》。我给它打了 90 分。&quot; 你可以声明多行的模板字面量 12345678const newline = `终于有一天，你知道了必须做的事情，而且开始……`;console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/ 数字与字符串如果有一个数字变量，你想将其转换为字符串，或者你想将一个字符串变量转换为数字，可以使用以下两个结构： 如果可以的话，Number() 函数会将其参数转换为数字。 1234const myString = &quot;123&quot;;const myNum = Number(myString);console.log(typeof myNum);// number 相反，String() 函数将其参数转换为字符串。 1234const myNum2 = 123;const myString2 = String(myNum2);console.log(typeof myString2);// string 这些结构在某些情况下非常有用。例如，如果用户在表单的文本字段中输入一个数字，那么它就是一个字符串。然而，如果你想将这个数字与某个值相加，则需要它是一个数字，因此你可以通过 Number() 来处理它。 比较字符串一、大于(&gt;)，小于(&lt;)运算符 javascript字符串在进行大于(小于)比较时，会根据第一个不同的字符的ascii值码进行比较，当数字(number)与字符串(string)进行比较大小时，会强制的将数字(number)转换成字符串(string)然后再进行比较。 1234567(function(){ console.log('13'&gt;'3'); // 输出：false console.log('5&gt;'6'); // 输出： false console.log('d'&gt;'ABDC') // 输出： true console.log('19&gt;'ssf') // 输出 false console.log('A'&gt;'abcdef') // 输出 false})() 二、相等(==)，严格相等(===)运算符 在进行相等(==)运算比较时，如果一边是字符，一边是数字，会先将字符串转换成数字再进行比较；严格相等(===)则不会进行类型转换，会比较类型是否相等。 注：NaN与任何值比较时都是false 12345678(function(){ console.log('6'==6) // true console.log('6'===6) // false console.log(6===6) // true console.log('abc'==2) // false console.log('abc'=='abc') // true console.log('abc'==='abc') // true})() 一些特殊值的相等与严格相等比较： 12345678910(function(){ console.log(null==undefined) // 输出：true console.log(null===undefined) // 输出：false console.log(null===null) // 输出：true console.log(undefined===undefined) // 输出：true console.log(NaN==undefined) // 输出：false console.log(NaN==null) // 输出：false console.log(NaN==NaN) // 输出：false console.log(NaN===NaN) // 输出：false})() 字符串比大小时会左对齐然后从左往右依次比较，只要不相同能分出胜负就停下。在字母相同的情况下JavaScript是区分大小写的，同一个字母的小写大于大写。 数组数组是一个包含了多个值的对象。 数组对象可以存储在变量中，并且能用和其他任何类型的值完全相同的方式处理，区别在于我们可以单独访问列表中的每个值，并使用列表执行一些有用和高效的操作，如循环——它对数组中的每个元素都执行相同的操作。 创建数组数组由方括号构成，其中包含用逗号分隔的元素列表。 假设想在一个数组中存储一个购物清单 1let shopping = [&quot;bread&quot;, &quot;milk&quot;, &quot;cheese&quot;, &quot;hummus&quot;, &quot;noodles&quot;]; 在这种情况下，数组中的每个项目都是一个字符串，但请记住，可以将任何类型的元素存储在数组中（字符串，数字，对象，另一个变量，甚至另一个数组）。也可以混合和匹配项目类型，它们并不都是数字，字符串等。 12let sequence = [1, 1, 2, 3, 5, 8, 13];let random = [&quot;tree&quot;, 795, [0, 1, 2]]; 字符串和数组之间的转换join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。如果数组只有一个元素，那么将返回该元素而不使用分隔符。使用 join() 可以指定不同的分隔符。 1234const elements = ['Fire', 'Air', 'Water'];console.log(elements.join('-'));// Expected output: &quot;Fire-Air-Water&quot; toString() 方法返回一个字符串，表示指定的数组及其元素。toString() 可以比 join() 更简单，因为它不需要一个参数，但更有限制。 12let dogNames = [&quot;Rocket&quot;, &quot;Flash&quot;, &quot;Bella&quot;, &quot;Slugger&quot;];dogNames.toString(); //Rocket,Flash,Bella,Slugger 添加和删除数组项使用 push() 添加一个或多个要添加到数组末尾的元素。 从数组中删除最后一个元素的话直接使用 pop() 就可以。 unshift() 和 shift() 从功能上与 push() 和 pop() 完全相同，只是它们分别作用于数组的开始，而不是结尾。 条件语句if…else 语句12345if (condition) { /* 条件为真时运行的代码 */} else { /* 否则，运行其他的代码 */} 如果（if）条件（condition）返回 true，运行代码 A，否则（else）运行代码 B 在这种情况下，第二段代码不被条件语句控制，所以它总会运行，不管条件返回的是 true 还是 false 12345if (condition) { /* 条件为真时运行的代码 */}/* 运行其他的代码 */ 任何不是 false、undefined、null、0、NaN、或一个空字符串（’’）在作为条件语句进行测试时实际返回 true，因此可以简单地使用变量名称来测试它是否为真，甚至是否存在（即它不是 undefined 的）。 12345678let cheese = &quot;Cheddar&quot;;if (cheese) { console.log(&quot;耶！这里有一些制作奶酪吐司的奶酪。&quot;);} else { console.log(&quot;今天你的吐司上没有奶酪了。&quot;);}//耶！这里有一些制作奶酪吐司的奶酪。 switch 语句switch语句以单个表达式/值作为输入，然后查看多个选项，直到找到与该值相匹配的选项，执行与之相关的代码。 1234567891011121314switch (表达式) { case 选择1: 运行这段代码 break; case 选择2: 否则，运行这段代码 break; // 包含尽可能多的情况 default: 实际上，仅仅运行这段代码} default 部分不是必须的——如果表达式不可能存在未知值，则可以安全地省略它。然而，如果有这样的机会，你需要包括它来处理未知的情况。 三元运算符三元运算符用于测试一个条件，并返回一个值/表达式，如果它是 true 则返回其中一个，否则（false）返回另外一个。 1condition ? 运行这段代码 : 否则，运行这段代码 循环一段循环通常需要一个或多个条件： 一个开始条件，它被初始化为一个特定的值，这是循环的起点 。 一个结束条件，这是循环停止的标准，通常计数器达到一定值。 一个迭代器，这通常在每个连续循环上递增少量的计数器，直到达到退出条件。 123456789loop(food = 0; foodNeeded = 10) { if (food = foodNeeded) { exit loop; // 我们有足够的食物了，回家吧。 } else { food += 2; // 花一个小时多收集两个食物。 // 循环将会继续执行。 }} for 循环123for (initializer; exit-condition; final-expression) { // code to run} 关键字for，后跟一些括号。 在括号内，我们有三个项目，以分号分隔： 一个初始化器initializer - 这通常是一个设置为一个数字的变量，它被递增来计算循环运行的次数。它也有时被称为计数变量。 一个退出条件exit-condition - 如前面提到的，这个定义循环何时停止循环。这通常是一个表现为比较运算符的表达式，用于查看退出条件是否已满足的测试。 一个最终条件final-expression - 这总是被判断（或运行），每个循环已经通过一个完整的迭代消失时间。它通常用于增加（或在某些情况下递减）计数器变量，使其更接近退出条件值。 一些包含代码块的花括号 - 每次循环迭代时都会运行这个代码。 使用 break 退出循环如果要在所有迭代完成之前退出循环，可以使用 break 语句。 使用 continue 跳过迭代continue 语句以类似的方式工作，而不是完全跳出循环，而是跳过当前循环而执行下一个循环。 while 语句和 do … while 语句123456789101112初始化器initializerwhile (退出条件exit-condition) { // code to run 最终条件final-expression}初始化器initializerdo { // code to run 最终条件final-expression} while (退出条件exit-condition) 这里的区别在于退出条件是一切都包含在括号中，而后面是一个 while 关键字。在 do … while 循环中，花括号中的代码总是在检查之前运行一次，以查看是否应该再次执行（在 while 和 for 中，检查首先出现，因此代码可能永远不会执行）。 运算符运算符的定义： 运算符是一类数学符号，可以根据两个值（或变量）产生结果。 注： 这里说“根据两个值（或变量）产生结果”是不严谨的，计算两个变量的运算符称为“二元运算符”，还有一元运算符和三元运算符，“取非”就是一元运算符。 运算符种类：算数运算符： 运算符 解释 符号 示例 加 将两个数字相加，或拼接两个字符串。 + 6 + 9; “Hello “ + “world!”; 减、乘、除 这些运算符操作与基础算术一致。只是乘法写作星号，除法写作斜杠。 -, *, / 9 - 3; 8 * 2; //乘法在 JS 中是一个星号 9 / 3; 求余 (有时候也叫取模) 在你将左边的数分成同右边数字相同的若干整数部分后，返回剩下的余数 % 8 % 3 (返回 2，8 除以 3 的倍数，余下 2。) 幂 取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。 ** 5 ** 5 (返回 3125，相当于 5 * 5 * 5 * 5 * 5 。) 比较运算符： 运算符 解释 符号 示例 全等 测试两个值是否相等，并返回一个 true/false （布尔）值。 === 5 === 2 + 4 // false ‘Chris’ === ‘Bob’ // false 5 === 2 + 3 // true 2 === ‘2’ // false；数字与字符串不相等 不等于 和等于运算符相反，测试两个值是否不相等，并返回一个 true/false （布尔）值。 !== 5 !== 2 + 4 // true ‘Chris’ !== ‘Bob’ // true 5 !== 2 + 3 // false 2 !== ‘2’ // true；数字与字符串不相等 赋值运算符： 运算符 解释 符号 示例 赋值运算符 为变量赋值 = let myVariable = ‘冷冷’; 逻辑运算符： 运算符 解释 符号 示例 逻辑与 允许你把两个或多个表达式连在一起，这样所有的表达式都必须单独评估为 true，整个表达式才能返回 true。 &amp;&amp; var a1 = true &amp;&amp; true; // t &amp;&amp; t returns true var a2 = true &amp;&amp; false; // t &amp;&amp; f returns false var a3 = false &amp;&amp; true; // f &amp;&amp; t returns false var a4 = false &amp;&amp; 3 == 4; // f &amp;&amp; f returns false var a5 = “Cat” &amp;&amp; “Dog”; // t &amp;&amp; t returns Dog var a6 = false &amp;&amp; “Cat”; // f &amp;&amp; t returns false var a7 = “Cat” &amp;&amp; false; // t &amp;&amp; f returns false 逻辑或 允许你把两个或多个表达式连在一起，其中一个或多个表达式必须单独评估为 true，整个表达式才能返回 true。 || var o1 = true || true; // t || t returns true var o2 = false || true; // f || t returns true var o3 = true || false; // t || f returns true var o4 = false || 3 == 4; // f || f returns false var o5 = “Cat” || “Dog”; // t|| t returns Cat var o6 = false || “Cat”; // f || t returns Cat var o7 = “Cat” || false; // t || f returns Cat 取非 返回逻辑相反的值，比如当前值为真，则返回 false。 ! var n1 = !true; // !t returns false var n2 = !false; // !f returns true var n3 = !”Cat”; // !t returns false 运算符优先级JavaScript 中的运算符优先级与学校的数学课程相同——乘法和除法总是先完成，然后是加法和减法（总是从左到右进行计算）。 如果想要改变计算优先级，可以把想要优先计算的部分用括号围住。 函数函数：函数用来封装可复用的功能。如果没有函数，一段特定的操作过程用几次就要重复写几次，而使用函数则只需写下函数名和一些简短的信息。 注： return 语句告诉浏览器当前函数返回 result 变量。这是一点很有必要，因为函数内定义的变量只能在函数内使用。这叫做变量的作用域。 匿名函数主要使用匿名函数来运行负载的代码以响应事件触发（如点击按钮）——使用事件处理程序。 创建一个没有名称的函数： 123function() { alert('hello');} 这个函数叫做匿名函数——它没有函数名！它也不会自己做任何事情。你通常将匿名函数与事件处理程序一起使用，例如，如果单击相关按钮，以下操作将在函数内运行代码： 12345var myButton = document.querySelector(&quot;button&quot;);myButton.onclick = function () { alert(&quot;hello&quot;);}; 还可以将匿名函数分配为变量的值，还可以将该函数分配为多个变量的值，但这只会令人费解，所以不要这样做！例如： 1234567891011var myGreeting = function () { alert(&quot;hello&quot;);};var anotherGreeting = function () { alert(&quot;hello&quot;);};//可以使用以下任一方法调用此函数myGreeting();anotherGreeting(); 注：匿名函数也称为函数表达式。函数表达式与函数声明有一些区别。函数声明会进行声明提升（declaration hoisting），而函数表达式不会。 闭包闭包是一个函数中包含内层函数+引用的外层函数变量组成的。 12345678function fn() { let count = 1 return function() { count++ console.log(count) }}const f = fn() 闭包实现了数据的私有，例如：节流防抖、Vue3、React 中都使用了闭包。 闭包不一定要 return，需要使用内部变量时再return。 闭包不一定会引起内存泄漏，只有在外部使用了内存变量时才有可能内存泄漏。 事件事件是在浏览器窗口内触发的，并倾向于附加到驻留在其中的特定项目。这可能是一个单一的元素，一组元素，当前标签中加载的 HTML 文档，或整个浏览器窗口。有许多不同类型的事件可以发生。 例如： 用户选择、点击或将光标悬停在某一元素上。 用户在键盘中按下某个按键。 用户调整浏览器窗口的大小或者关闭浏览器窗口。 网页结束加载。 表单提交。 视频播放、暂停或结束。 发生错误。 为了对一个事件做出反应，你要给它附加一个事件处理器。事件处理器有时候被叫做事件监听器——从我们的用意来看这两个名字是相同的，尽管严格地来说这块代码既监听也处理事件。监听器留意事件是否发生，处理器对事件发生做出回应。 事件监听器事件能为网页添加真实的交互能力。它可以捕捉浏览器操作并运行一些代码做为响应。最简单的事件是点击事件，鼠标的点击操作会触发该事件，定义了一个 addEventListener() 函数。 要传入两个参数： 字符串 “click”，表示我们要监听点击事件。按钮可以触发很多其他的事件，比如当用户将鼠标移到按钮上时（“mouseover” 事件），或者当用户按下一个键并且按钮被聚焦时（“keydown” 事件）。 当事件发生时所调用的函数。 123document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () { alert(&quot;别戳我，我怕疼。&quot;);}); 传递给 addEventListener() 的函数被称为匿名函数，因为它没有名字。匿名函数还有另一种我们称之为箭头函数的写法，箭头函数使用 () =&gt; 代替 function ()： 123document.querySelector('button').addEventListener('click', () =&gt; { alert('别戳我，我怕疼。');}); 如果你使用 addEventListener() 添加了一个事件处理器，你可以使用 removeEventListener() 方法再次删除它。例如，这将删除 changeBackground() 事件处理器： 1btn.removeEventListener(&quot;click&quot;, changeBackground); 事件处理器也可以通过传递 AbortSignal 到 addEventListener()，然后在拥有 AbortSignal 的控制器上调用abort()，从而删除事件处理器。例如，要添加一个可以使用 AbortSignal 来删除的事件处理器，可以这样做： 123456789const controller = new AbortController();btn.addEventListener(&quot;click&quot;, () =&gt; { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; document.body.style.backgroundColor = rndCol; }, { signal: controller.signal } // 向该处理器传递 AbortSignal); 然后可以像这样删除上面代码创建的事件处理器： 1controller.abort(); // 移除任何/所有与该控制器相关的事件处理器 其他事件监听器机制推荐使用 addEventListener() 来注册事件处理器。这是最强大的方法，在更复杂的程序中，它的扩展性最好。然而，还有两种注册事件处理器的方法：事件处理器属性和内联事件处理器。 事件处理器属性可以触发事件的对象（如按钮）通常也有属性，其名称是 on，后面是事件的名称。例如，元素有一个属性 onclick。这被称为事件处理器属性。为了监听事件，你可以将处理函数分配给该属性。 以像这样重写随机颜色示例： 12345678910const btn = document.querySelector(&quot;button&quot;);function random(number) { return Math.floor(Math.random() * (number + 1));}btn.onclick = () =&gt; { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; document.body.style.backgroundColor = rndCol;}; 也可以将处理器属性分配给具名函数： 123456789101112const btn = document.querySelector(&quot;button&quot;);function random(number) { return Math.floor(Math.random() * (number + 1));}function bgChange() { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; document.body.style.backgroundColor = rndCol;}btn.onclick = bgChange; 对于事件处理器属性，不能为一个事件添加一个以上的处理程序。 例如，你可以在一个元素上多次调用 addEventListener(‘click’, handler)，并在第二个参数中指定不同的函数： 12element.addEventListener(&quot;click&quot;, function1);element.addEventListener(&quot;click&quot;, function2); 对于事件处理器属性来说，这是不可能的，因为任何后续尝试都会覆写较早设置的属性： 12element.onclick = function1;element.onclick = function2; 内联事件处理器——不要使用**永远不应该使用 HTML 事件处理器属性,**使用它们是不好的做法。 123456&lt;button onclick=&quot;bgChange()&quot;&gt;按下我&lt;/button&gt;function bgChange() { const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`; document.body.style.backgroundColor = rndCol;} 事件对象有时候在事件处理函数内部，你可能会看到一个固定指定名称的参数，例如 event、evt 或 e。这被称为事件对象，它被自动传递给事件处理函数，以提供额外的功能和信息。 阻止默认行为有时，会遇到一些情况，希望事件不执行它的默认行为。最常见的例子是 Web 表单，例如自定义注册表单。当你填写详细信息并按提交按钮时，自然行为是将数据提交到服务器上的指定页面进行处理，并将浏览器重定向到某种“成功消息”页面。 当用户没有正确提交数据时，麻烦就来了——作为开发人员，你希望停止提交信息给服务器，并给他们一个错误提示，告诉他们什么做错了，以及需要做些什么来修正错误。 在 submit 事件（表单提交时触发提交事件）的处理程序中实现一个非常简单的检查，测试文本字段是否为空。如果是这样，我们就在事件对象上调用 preventDefault() 函数，停止表单提交，然后在我们的表单下面的段落中显示错误信息，告诉用户出了什么问题： 1234567891011const form = document.querySelector(&quot;form&quot;);const fname = document.getElementById(&quot;fname&quot;);const lname = document.getElementById(&quot;lname&quot;);const para = document.querySelector(&quot;p&quot;);form.addEventListener(&quot;submit&quot;, (e) =&gt; { if (fname.value === &quot;&quot; || lname.value === &quot;&quot;) { e.preventDefault(); para.textContent = &quot;You need to fill in both names!&quot;; }}); 事件冒泡事件冒泡描述了浏览器如何处理针对嵌套元素的事件。 在父元素上设置监听器12345678910111213&lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt;&lt;/div&gt;&lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;const output = document.querySelector(&quot;#output&quot;);function handleClick(e) { output.textContent += `你在 ${e.currentTarget.tagName} 元素上进行了点击\\n`;}const container = document.querySelector(&quot;#container&quot;);container.addEventListener(&quot;click&quot;, handleClick);//你在 DIV 元素上进行了点击 这里有一个在其他元素（&lt;div&gt;）内部的按钮，可以说这里的&lt;div&gt;元素是其中包含元素的父元素。 按钮在 &lt;div&gt; 里面，所以当你点击按钮的时候，你也隐含地点击了它所在的元素。 如果在按钮及其父元素上同时添加事件处理器，如果给按钮、它的父元素（&lt;div&gt;）以及包含它们的&lt;body&gt;元素添加点击事件处理器： 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt; &lt;/div&gt; &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;&lt;/body&gt;const output = document.querySelector(&quot;#output&quot;);function handleClick(e) { output.textContent += `你在 ${e.currentTarget.tagName} 元素上进行了点击\\n`;}const container = document.querySelector(&quot;#container&quot;);const button = document.querySelector(&quot;button&quot;);document.body.addEventListener(&quot;click&quot;, handleClick);container.addEventListener(&quot;click&quot;, handleClick);button.addEventListener(&quot;click&quot;, handleClick);你在 BUTTON 元素上进行了点击你在 DIV 元素上进行了点击你在 BODY 元素上进行了点击 在这种情况下： 最先触发按钮上的单击事件 然后是按钮的父元素（ &lt;div&gt; 元素） 然后是 &lt;div&gt;的父元素（&lt;body&gt;元素） 可以这样描述：事件从被点击的最里面的元素冒泡而出。 事件冒泡有时会产生问题，但有一种方法可以防止这些问题。Event对象有一个可用的函数，叫做 stopPropagation()，当在一个事件处理器中调用时，可以防止事件向任何其他元素传递。 事件捕获事件传播的另一种形式是事件捕获。这就像事件冒泡，但顺序是相反的：事件不是先在最内层的目标元素上发生，然后在连续较少的嵌套元素上发生，而是先在最小嵌套元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标。 事件捕获默认是禁用的，你需要在 addEventListener() 的 capture 选项中启用它。 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;button&gt;点我！&lt;/button&gt; &lt;/div&gt; &lt;pre id=&quot;output&quot;&gt;&lt;/pre&gt;&lt;/body&gt;const output = document.querySelector(&quot;#output&quot;);function handleClick(e) { output.textContent += `你在 ${e.currentTarget.tagName} 元素上进行了点击\\n`;}const container = document.querySelector(&quot;#container&quot;);const button = document.querySelector(&quot;button&quot;);document.body.addEventListener(&quot;click&quot;, handleClick, { capture: true });container.addEventListener(&quot;click&quot;, handleClick, { capture: true });button.addEventListener(&quot;click&quot;, handleClick);你在 BODY 元素上进行了点击你在 DIV 元素上进行了点击你在 BUTTON 元素上进行了点击 在这种情况下，消息出现的顺序发生了颠倒：&lt;body&gt; 事件处理器首先触发，然后是 &lt;div&gt; 的，最后是 &lt;button&gt; 的。 默认情况下，几乎所有的事件处理程序都是在冒泡阶段注册的，这在大多数情况下更有意义。 事件委托事件冒泡可以实现事件委托。在这种做法中，当我们想在用户与大量的子元素中的任何一个互动时运行一些代码时，我们在它们的父元素上设置事件监听器，让发生在它们身上的事件冒泡到它们的父元素上，而不必在每个子元素上单独设置事件监听器。","link":"/2020/09/05/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript%E8%AF%AD%E6%B3%95/"},{"title":"前后端数据请求","text":"post 请求三种格式：application/x-www-form-urlencoded 12345//有兼容性问题const params = new URLSearchParams();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); 1234567891011121314//qs 插件const qs = require('qs');axios.post('/foo', qs.stringify({ 'bar': 123 }));//es6 方式import qs from 'qs';const data = { 'bar': 123 };const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url,};axios(options); application/json12345678910axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); multipart/form-data（文件上传）1234const params = new FormData();params.append('param1', 'value1');params.append('param2', 'value2');axios.post('/foo', params); get 请求四种格式：基本的 GET 请求12345678910111213// 引入 axiosconst axios = require('axios');// 发起 GET 请求axios.get('https://api.example.com/data') .then(response =&gt; { // 请求成功处理 console.log(response.data); }) .catch(error =&gt; { // 请求失败处理 console.error(error); }); 带参数的 GET 请求（直接拼接在 URL 上）(query)1234567891011121314const axios = require('axios');// 假设有两个参数：id 和 categoryconst id = 123;const category = 'electronics';// 使用模板字符串将参数拼接在 URL 上axios.get(`https://api.example.com/data?id=${id}&amp;category=${category}`) .then(response =&gt; { console.log(response.data); }) .catch(error =&gt; { console.error(error); }); 带参数的 GET 请求（使用 params 对象）12345678910111213141516const axios = require('axios');// 定义 params 对象const params = { id: 123, category: 'electronics'};// 将 params 对象传递给 GET 请求axios.get('https://api.example.com/data', { params }) .then(response =&gt; { console.log(response.data); }) .catch(error =&gt; { console.error(error); }); RESTful 风格的 GET 请求（params）12345678910111213const axios = require('axios');// 假设需要获取 id 为 123 的商品信息const productId = 123;// 使用 RESTful 风格传递参数axios.get(`https://api.example.com/products/${productId}`) .then(response =&gt; { console.log(response.data); }) .catch(error =&gt; { console.error(error); }); params 和 query 区别与联系 参数用途： “params”（路径参数）用于指定路由的一部分，通常用于标识特定资源。例如，在RESTful API中，可以使用路径参数指定要操作的资源ID，如/users/{id}，其中{id}就是一个路径参数。 “query”（查询参数）用于向服务器请求附加信息。查询参数以键值对的形式出现在URL的问号之后，例如：https://example.com/search?query=example，其中query=example就是一个查询参数。 参数传递方式： “params”参数通过URL路径的一部分传递。例如，如果要请求用户名为”john”的用户信息，可以使用路径参数的方式：/users/john。 “query”参数以键值对的形式出现在URL的查询字符串中。例如，要搜索关键字为”example”的产品，可以使用查询参数的方式：/products?search=example。 总体来说，两者都是用于向服务器传递参数，但使用的方式和场景略有不同。选择何种方式取决于你的具体需求和项目约定。如果要标识特定资源，通常使用”params”；如果要传递附加信息或进行搜索过滤，通常使用”query”。需要注意的是，不同的后端框架和语言可能对这两种方式有不同的实现方式和约定。 使用场景 “params”（路径参数）的使用场景： 标识资源：当需要在URL中标识特定资源时，可以使用路径参数。例如，在一个博客应用中，使用路径参数来指定文章ID：/articles/{id}，其中{id}就是路径参数。 RESTful API：在设计RESTful API时，路径参数常用于指定特定资源的操作。例如，GET /users/{id}可以获取特定用户的信息。 “query”（查询参数）的使用场景： 附加信息：当需要向服务器传递附加信息时，可以使用查询参数。例如，在一个电子商务网站中，需要***向服务器传递用户的搜索关键字来获取相应产品列表***，可以使用查询参数：/products?search=keyword。 过滤和排序：查询参数还常用于过滤和排序结果。比如，对于商品列表页面，可以使用查询参数来指定排序方式、过滤条件等：/products?sort=price&amp;category=electronics。 路径参数用于直接标识资源或操作，而查询参数则用于传递附加信息、过滤和排序结果等。根据具体需求和项目约定，选择适合的参数传递方式以实现预期功能。","link":"/2019/09/05/%E5%89%8D%E7%AB%AF/JavaScript/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"},{"title":"Vue 相关知识","text":"computed（计算属性）计算属性用来描述依赖响应式状态的复杂逻辑。 1234567891011121314151617181920212223//在模板中放入太多的逻辑会让模板过重且难以维护。&lt;div id=&quot;example&quot;&gt; {{ message.split('').reverse().join('') }}&lt;/div&gt;//换成使用计算属性&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { // 计算属性的 getter reversedMessage: function () { // `this` 指向 vm 实例 return this.message.split('').reverse().join('') } }}) Vue 的计算属性会自动追踪响应式依赖。 计算属性的 getter 应只做计算而没有任何其他的副作用，这使它更易于测试和理解。不要在 getter 中做异步请求或者更改 DOM！ 计算属性缓存与方法的区别：将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。 然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 计算属性缓存是一种属性，而方法是一种函数。计算属性缓存返回一个值，而方法执行一些操作并可以返回一个值。 计算属性缓存的值是在第一次访问该属性时计算的，并且该值会被缓存起来，以便在后续访问该属性时能够更快地获取该值。相比之下，每次调用方法时都会执行其中的代码。 计算属性缓存适用于需要频繁访问并且计算成本较高的属性。当该属性值不发生变化时，缓存的值可以被重复使用，从而提高性能。相比之下，方法通常用于执行一些具有副作用的操作或者需要每次重新计算的值。 计算属性缓存可以被设置为可读可写，也就是说可以通过 setter 方法修改其值。相比之下，方法通常是只读的，不会修改对象的状态。 为什么需要缓存？ 假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性与侦听属性的区别： 计算属性：计算属性是根据其他属性的值计算而来的，它本身并不存储数据，只有当依赖的数据发生变化时才会重新计算。计算属性通常用于复杂的逻辑计算和数据筛选等场景，可以让模板代码更简洁清晰。 侦听属性：侦听属性是用来监听某个属性的变化并做出相应的操作，可以自定义一个回调函数来响应数据的变化。侦听属性通常用于数据变化后需要执行异步操作或者复杂的业务逻辑等场景。 简单来说，计算属性适用于对数据的处理和计算，而侦听属性适用于数据变化后需要执行的操作和副作用。 watch（侦听器）需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。可以使用 watch 函数在每次响应式状态发生变化时触发回调函数。 123456789101112131415161718192021222324252627&lt;script setup&gt;import { ref, watch } from 'vue'const question = ref('')const answer = ref('Questions usually contain a question mark. ;-)')// 可以直接侦听一个 refwatch(question, async (newQuestion, oldQuestion) =&gt; { if (newQuestion.indexOf('?') &gt; -1) { answer.value = 'Thinking...' try { const res = await fetch('https://yesno.wtf/api') answer.value = (await res.json()).answer } catch (error) { answer.value = 'Error! Could not reach the API. ' + error } }})&lt;/script&gt;&lt;template&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=&quot;question&quot; /&gt; &lt;/p&gt; &lt;p&gt;{{ answer }}&lt;/p&gt;&lt;/template&gt; watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组。 注：不能直接侦听响应式对象的属性值。 123456789101112131415const obj = reactive({ count: 0 })// 错误，因为 watch() 得到的参数是一个 numberwatch(obj.count, (count) =&gt; { console.log(`count is: ${count}`)})//需要用一个返回该属性的 getter 函数// 提供一个 getter 函数watch( () =&gt; obj.count, (count) =&gt; { console.log(`count is: ${count}`) }) 侦听器是一个强大的特性，但也有可能导致性能问题，特别是当监听的数据非常复杂或监听的回调函数执行的操作很耗费性能时。 指令（v-model ，v-bind，v-for，v-if）v-model：用于实现双向数据绑定。它通常用于表单元素，例如 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 等，可以将表单元素的值与 Vue 实例中的数据属性绑定在一起，实现数据的自动同步。 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;message&quot; /&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { message: '' } }}&lt;/script&gt; v-model 指令只能用于支持 value 属性或 checked 属性的表单元素上。 对于其他元素，需要使用事件绑定或自定义指令来实现类似的功能。 同时，使用v-model指令时，需要注意避免出现循环更新或无限递归等问题，这些问题可能会导致性能问题和程序崩溃。 v-bind：v-bind：用于动态地绑定 HTML 属性或组件属性到 Vue 实例中的数据属性或表达式上。简写是『 ：』。如果绑定内容需要进行动态拼接，需要需要使用 ‘’ 进行拼接。 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;img v-bind:src=&quot;imageUrl&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { imageUrl: 'https://example.com/image.png' } }}&lt;/script&gt; v-for：v-for 指令基于一个数组来渲染一个列表。 v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。 可以用 of 替代 in 作为分隔符。 1234567891011121314151617&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.message&quot;&gt; {{ item.message }} &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue({ el: '#example-1', data: { items: [ { message: 'Foo' }, { message: 'Bar' } ] }})// ·FOO// ·Bar v-for 还支持一个可选的第二个参数，即当前项的索引。 123456789101112131415161718&lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; {{ parentMessage }} - {{ index }} - {{ item.message }} &lt;/li&gt;&lt;/ul&gt;var example2 = new Vue({ el: '#example-2', data: { parentMessage: 'Parent', items: [ { message: 'Foo' }, { message: 'Bar' } ] }})// ·Parent - 0 - FOO// ·Parent - 1 - Bar 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key。 2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的。 v-ifv-if 指令将根据表达式属性的值的真假来插入/移除 &lt;p&gt; 元素。 v-if 与 v-show 的区别： v-show: 控制的元素无论是true还是false，都被渲染出来了，通过display：none控制元素隐藏。 v-if: 控制的元素是true，进行渲染，如果是false不渲染，根本在dom树结构中不显示。 应用： v-show: 适合使用在切换频繁显示/隐藏的元素上。v-if: 适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上。 父子组件传值（冒泡）父组件向子组件传值父组件向子组件传值是通过属性的方式 传值，传的值可以是任意类型，甚至可以是父组件的方法或者父组件对象本身。 在父组件中引入子组件；并在components中注册子组件。 通过属性向子组件中传值。 父组件向子组件传值使用 v-bind。 子组件使用 props 接受父组件传来的值。子组件在 props 中创建一个属性，用以接收父组件传过来的值。 1234567891011121314151617181920212223242526272829303132333435363738394041//子组件 &lt;template&gt; &lt;div&gt; //调用父组件的属性 &lt;h1&gt;{{title.name}}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;test&quot;, data() { return { message: &quot;hello world 子组件&quot;, } }, props: { father: { //属性 type: Object, required: true, default: 100, }, },&lt;/script&gt;//父组件&lt;div&gt; &lt;test :father=&quot;title&quot;&gt;&lt;/test&gt;&lt;/div&gt;&lt;script&gt;import test from &quot;./Comps/test&quot;;export default { name: &quot;index&quot;, data() { return { title: { name: &quot;angula&quot;, }, }; }&lt;/script&gt; 父组件调用子组件的属性和方法利用 ref 属性获取到子组件的属性或者方法。 父调子组件，利用ref、$refs。 12345&lt;test ref=&quot;test&quot;&gt;&lt;/test&gt;&lt;button @click=&quot;handle&quot;&gt;点击&lt;/button&gt;handle() { this.$refs.test.message = &quot;study&quot;;}, 子组件向父组件传值子组件向父组件传值是通过自定义事件的方式向父组件传值。利用 $emit()。 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件。 将需要传的值作为 $emit 的第二个参数，该值将作为实参传给响应自定义事件的方法。 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听。 123456789101112//子组件&lt;button class=&quot;btn&quot; @click=&quot;sendData&quot;&gt;点击向父组件传值&lt;/button&gt;sendData() { this.$emit(&quot;sendChild&quot;, this.message);},//父组件&lt;test @sendChild=&quot;recieveChilds&quot; &gt;&lt;/test&gt;methods: { recieveChilds(payload) { this.message = payload;} 子组件调用父组件的属性或方法主要利用 $parent 属性获取父组件对象，从而调用父组件的属性或者方法。 子调父组件，只需要 $parent。 1234&lt;button @click=&quot;sendData&quot;&gt;点击&lt;/button&gt;sendData() { console.log(this.$parent.title.name);}, 事件修饰符事件修饰符是通过『 : 』来修饰。 .stop ： 阻止事件冒泡。js 中事件会以冒泡的形式由内到外的向上传递。由最内层点击元素向外扩散到最外层元素，激活外层元素注册的相应事件，这就是事件冒泡。 .prevent：阻止提交，form 表单组件和 a 链接组件都会导致页面刷新和跳转。如果不希望页面刷新，则可以加上 .prevent 以阻止这种默认的刷新操作。注意：.prevent 只对form 和 a 标签有效。 .capture：作用是优先触发。 .self：只当事件是从侦听器绑定的元素本身触发时才触发回调，使用下面的条件判断进行代替。 .once：表示只触发一次。 修饰符 前缀 .passive &amp; .capture ! .once ~ .capture.once或.once.capture ~! 插槽（slot）Vue 的插槽是一种用于组件之间通信的机制。通过插槽，可以在父组件中将子组件的内容嵌入到指定的位置上。 &lt;slot&gt; 元素是一个插槽出口，标示了父元素提供的插槽内容将在哪里被渲染。 父组件可以在使用子组件的时候，通过插槽将任意内容插入到子组件中。这样可以让子组件更加灵活，因为子组件可以接受不同的内容来显示。 插槽有两种类型：具名插槽和默认插槽。默认插槽没有名称，用于接收未命名的内容，而具名插槽可以指定名称，用于接收特定的内容。 具名插槽可以通过在组件模板中使用 v-slot 指令来定义。父组件还可以使用简写语法 # 来定义具名插槽。 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;header&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt; //父组件&lt;template&gt; &lt;my-component&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Header content&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;Default slot content&lt;/p&gt; //使用简写语法 # 来定义具名插槽 &lt;template #footer&gt; &lt;p&gt;Footer content&lt;/p&gt; &lt;/template&gt; &lt;/my-component&gt;&lt;/template&gt; 除了具名插槽和默认插槽，Vue 还支持作用域插槽，可以将父组件的数据传递给子组件中的插槽，以便子组件可以使用这些数据来渲染插槽中的内容。作用域插槽可以通过在插槽中定义一个带有参数的函数来实现。 123456789101112131415161718192021222324//组件包含一个具名插槽，用于渲染列表项。//通过 :item=&quot;item&quot; 将当前项传递给插槽。&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;slot name=&quot;item&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;//父组件可以使用 v-slot 指令来定义作用域插槽//通过 v-slot:item=&quot;slotProps&quot; 定义了一个作用域插槽，//并将当前项传递给 slotProps.item。//在插槽中可以使用 slotProps.item 来访问当前项的属性。&lt;template&gt; &lt;my-component&gt; &lt;template v-slot:item=&quot;slotProps&quot;&gt; &lt;span&gt;{{ slotProps.item.title }}&lt;/span&gt; &lt;p&gt;{{ slotProps.item.description }}&lt;/p&gt; &lt;/template&gt; &lt;/my-component&gt;&lt;/template&gt; 插槽还支持默认内容和作用域插槽的组合使用。 12345678910111213//父组件没有使用作用域插槽来定义 item 插槽，那么默认的内容就会被显示出来。&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &lt;slot name=&quot;item&quot; :item=&quot;item&quot;&gt; &lt;span&gt;{{ item.title }}&lt;/span&gt; &lt;p&gt;{{ item.description }}&lt;/p&gt; &lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; 混入(mixin)mixin 是一种可重用的代码模块，它可以在多个组件之间共享。Mixin 可以包含任意组件选项，例如 data、methods、computed、watch 等等，它们会被合并到组件的选项中。当多个组件混入同一个 Mixin 时，它们会共享 Mixin 中的选项，这样可以大大减少重复代码，提高代码复用率。 如果 Mixin 和组件中的选项发生了冲突，会按照一定的规则进行合并。 例如，对于 data 选项，如果组件和 Mixin 都定义了同一个属性，那么最终的值将是组件中定义的值。 而对于 methods 选项，则会将 Mixin 中的方法合并到组件中的方法之前，这样组件中的方法可以覆盖 Mixin 中的方法。 123456789101112131415161718192021// 定义一个 Mixinconst myMixin = { data() { return { message: 'Hello, world!' } }, methods: { sayHello() { console.log(this.message) } }}// 定义一个组件并混入 MixinVue.component('my-component', { mixins: [myMixin], mounted() { this.sayHello() // 输出 'Hello, world!' }}) 注：Mixin 可能会造成命名冲突，因此应该避免在 Mixin 中定义太多的全局变量和方法。此外，Mixin 的使用也应该谨慎，不要滥用，以免造成混乱和不可维护的代码。如果使用的是 ES6 模块的导出方式，需要使用 import 语句将 Mixin 导入，不能使用全局变量的方式来使用 Mixin。 生命周期每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。 beforecreate： 没有data和method created：可以使用data和method beforemount：虚拟dom mounted：变成真实dom，这里不要去操作dom beforeupdate：当数据改变时执行，数据是新的，页面是旧的 updated：数据和页面都是新的 beforeDestroy：vm还在，dom已经销毁 Destroyed：销毁实例 beforeCreate( 创建前 )在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据。 created ( 创建后 ）实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成 beforeMount挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。 mounted挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。 beforeUpdate在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程。 updated（更新后）在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用。 beforeDestroy（销毁前）在实例销毁之前调用，实例仍然完全可用， 这一步还可以用 this 来获取实例。 一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的 dom 事件。 destroyed（销毁后）在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用。","link":"/2021/10/09/%E5%89%8D%E7%AB%AF/Vue/Vue/"},{"title":"JavaScript异步","text":"异步编程定义：异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。 异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。 浏览器提供的许多功能（尤其是最有趣的那一部分）可能需要很长的时间来完成，因此需要异步完成，例如： 使用 fetch() 发起 HTTP 请求 使用 getUserMedia() 访问用户的摄像头和麦克风 使用 showOpenFilePicker() 请求用户选择文件以供访问 回调 事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。 回调函数曾经是 JavaScript 中实现异步函数的主要方式。但是存在「回调地狱」使代码更难阅读和调试，所以现在大多数现代异步 API 都不使用回调。 1234567doSomething(function(result) { doSomethingElse(result, function(newResult) { doThirdThing(newResult, function(finalResult) { console.log('Got the final result: ' + finalResult); }, failureCallback); }, failureCallback);}, failureCallback); Promise 本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。 12345678910111213141516// 成功的回调函数function successCallback(result) { console.log(&quot;音频文件创建成功：&quot; + result);}// 失败的回调函数function failureCallback(error) { console.log(&quot;音频文件创建失败：&quot; + error);}createAudioFileAsync(audioSettings, successCallback, failureCallback)//现代写法：const promise = createAudioFileAsync(audioSettings);promise.then(successCallback, failureCallback);//简写为:createAudioFileAsync(audioSettings).then(successCallback, failureCallback); 在本轮 事件循环 运行完成之前，回调函数是不会被调用的。 即使异步操作已经完成（成功或失败），在这之后通过 then() 添加的回调函数也会被调用。 过多次调用 then() 可以添加多个回调函数，它们会按照插入顺序进行执行。 链式调用：then() 函数会返回一个和原来不同的新的 Promise。 之前多重的异步操作导致经典的「回调地狱」，现在就可以把回调绑定到返回的 Promise 上，形成一个 Promise 链。 123456789101112131415161718192021222324252627282930313233doSomething().then(function(result) { return doSomethingElse(result);}).then(function(newResult) { return doThirdThing(newResult);}).then(function(finalResult) { console.log('Got the final result: ' + finalResult);}).catch(failureCallback);//then 里的参数是可选的，//catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。//箭头函数表示法：doSomething().then(result =&gt; doSomethingElse(result)).then(newResult =&gt; doThirdThing(newResult)).then(finalResult =&gt; { console.log(`Got the final result: ${finalResult}`);}).catch(failureCallback);//async/await 语法糖表示法:async function foo() { try { const result = await doSomething(); const newResult = await doSomethingElse(result); const finalResult = await doThirdThing(newResult); console.log(`Got the final result: ${finalResult}`); } catch(error) { failureCallback(error); }} 使用一个 catch 对于在链式操作中抛出一个失败之后，再次进行新的操作会很有用。 12345678910111213141516new Promise((resolve, reject) =&gt; { console.log('初始化');//初始化 resolve();}).then(() =&gt; { throw new Error('有哪里不对了'); console.log('执行「这个」”');//不执行，因为抛出了错误}).catch(() =&gt; { console.log('执行「那个」');//执行“那个”}).then(() =&gt; { console.log('执行「这个」，无论前面发生了什么');//执行“这个”，无论前面发生了什么}); async/await 语法糖async 函数是使用async关键字声明的函数。async 函数是 AsyncFunction 构造函数的实例，并且其中允许使用 await 关键字。 async 和 await 关键字让我们可以用一种更简洁的方式写出基于 Promise 的异步行为，而无需刻意地链式调用 promise。 语法： 123456789async function name(param0) { statements}async function name(param0, param1) { statements}async function name(param0, param1, /* … ,*/ paramN) { statements} 返回值：一个 Promise，这个 promise 要么会通过一个由 async 函数返回的值被解决，要么会通过一个从 async 函数中抛出的（或其中没有被捕获到的）异常被拒绝。 一个 Promise 必然处于以下几种状态之一： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。 已兑现（fulfilled）：意味着操作成功完成。 已拒绝（rejected）：意味着操作失败。 Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。 12345678910async function foo() { try { const result = await doSomething(); const newResult = await doSomethingElse(result); const finalResult = await doThirdThing(newResult); console.log(`Got the final result: ${finalResult}`); } catch(error) { failureCallback(error); }} async 函数可能包含 0 个或者多个 await 表达式。 await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。 promise 的解决值会被当作该 await 表达式的返回值。使用 async/await 关键字就可以在异步代码中使用普通的 try/catch 代码块。 await 关键字只在 async 函数内有效。如果你在 async 函数体之外使用它，就会抛出语法错误 SyntaxError 。 async 函数一定会返回一个 promise 对象。如果一个 async 函数的返回值看起来不是 promise，那么它将会被隐式地包装在一个 promise 中。 1234567async function foo() { return 1;}//等价function foo() { return Promise.resolve(1);} async 函数的函数体可以被看作是由 0 个或者多个 await 表达式分割开来的。 从第一行代码直到（并包括）第一个 await 表达式（如果有的话）都是同步运行的。这样的话，一个不含 await 表达式的 async 函数是会同步运行的。然而，如果函数体内有一个 await 表达式，async 函数就一定会异步执行。 1234567async function foo() { await 1;}//等价function foo() { return Promise.resolve(1).then(() =&gt; undefined);} 宏任务、微任务script是一个宏任务 在一个宏任务中，先执行同步代码，再执行微任务，再执行下一个宏任务。 同步编程1234const name = &quot;Miriam&quot;;const greeting = `Hello, my name is ${name}!`;console.log(greeting);// &quot;Hello, my name is Miriam!&quot; 这段代码： 声明了一个叫做 name 的字符串常量 声明了另一个叫做 greeting 的字符串常量（并使用了 name 常量的值） 将 greeting 常量输出到 JavaScript 控制台中。 我们应该注意的是，实际上浏览器是按照我们书写代码的顺序一行一行地执行程序的。浏览器会等待代码的解析和工作，在上一行完成后才会执行下一行。这样做是很有必要的，因为每一行新的代码都是建立在前面代码的基础之上的。 这也使得它成为一个同步程序。 事实上，调用函数的时候也是同步的，就像这样： 1234567function makeGreeting(name) { return `Hello, my name is ${name}!`;}const name = &quot;Miriam&quot;;const greeting = makeGreeting(name);console.log(greeting);// &quot;Hello, my name is Miriam!&quot; 在这里 makeGreeting() 就是一个同步函数，因为在函数返回之前，调用者必须等待函数完成其工作。 耗时同步函数的问题：当调用函数时长过久时，程序完全没有反应，用户不能输入任何东西，也不能点击任何东西，或做任何其他事情。 这就是耗时的同步函数的基本问题。在这里我们想要的是一种方法，以让的程序可以： 通过调用一个函数来启动一个长期运行的操作 让函数开始操作并立即返回，这样我们的程序就可以保持对其他事件做出反应的能力 当操作最终完成时，通知我们操作的结果。 这就是异步函数为我们提供的能力。 事件处理程序我们刚才看到的对异步函数的描述可能会让你想起事件处理程序，这么想是对的。事件处理程序实际上就是异步编程的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。 一些早期的异步 API 正是以这种方式来使用事件的。XMLHttpRequest API 可以让你用 JavaScript 向远程服务器发起 HTTP 请求。由于这样的操作可能需要很长的时间，所以它被设计成异步 API，你可以通过给 XMLHttpRequest 对象附加事件监听器来让程序在请求进展和最终完成时获得通知。 下面的例子展示了这样的操作。点击“点击发起请求”按钮来发送一个请求。我们将创建一个新的 XMLHttpRequest 并监听它的 loadend 事件。而我们的事件处理程序则会在控制台中输出一个“完成！”的消息和请求的状态代码。 我们在添加了事件监听器后发送请求。注意，在这之后，我们仍然可以在控制台中输出“请求已发起”，也就是说，我们的程序可以在请求进行的同时继续运行，而我们的事件处理程序将在请求完成时被调用。 1234567891011121314151617181920212223&lt;button id=&quot;xhr&quot;&gt;点击发起请求&lt;/button&gt;&lt;button id=&quot;reload&quot;&gt;重载&lt;/button&gt;&lt;pre readonly class=&quot;event-log&quot;&gt;&lt;/pre&gt;const log = document.querySelector(&quot;.event-log&quot;);document.querySelector(&quot;#xhr&quot;).addEventListener(&quot;click&quot;, () =&gt; { log.textContent = &quot;&quot;; const xhr = new XMLHttpRequest(); xhr.addEventListener(&quot;loadend&quot;, () =&gt; { log.textContent = `${log.textContent}完成！状态码：${xhr.status}`; }); xhr.open( &quot;GET&quot;, &quot;https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json&quot;, ); xhr.send(); log.textContent = `${log.textContent}请求已发起\\n`;});document.querySelector(&quot;#reload&quot;).addEventListener(&quot;click&quot;, () =&gt; { log.textContent = &quot;&quot;; document.location.reload();}); 这就像我们在以前的模块中遇到的事件处理程序，只是这次的事件不是像点击按钮那样的用户行为，而是某个对象的状态变化。 回调事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。 然而，当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。当你需要执行一些分解成一系列异步函数的操作时，这将变得十分常见。例如下面这种情况： 1234567891011121314151617function doStep1(init) { return init + 1;}function doStep2(init) { return init + 2;}function doStep3(init) { return init + 3;}function doOperation() { let result = 0; result = doStep1(result); result = doStep2(result); result = doStep3(result); console.log(`结果：${result}`);}doOperation(); 现在我们有一个被分成三步的操作，每一步都依赖于上一步。在这个例子中，第一步给输入的数据加 1，第二步加 2，第三步加 3。从输入 0 开始，最终结果是 6（0+1+2+3）。作为同步代码，这很容易理解。但是如果我们用回调来实现这些步骤呢？ 12345678910111213141516171819202122function doStep1(init, callback) { const result = init + 1; callback(result);}function doStep2(init, callback) { const result = init + 2; callback(result);}function doStep3(init, callback) { const result = init + 3; callback(result);}function doOperation() { doStep1(0, (result1) =&gt; { doStep2(result1, (result2) =&gt; { doStep3(result2, (result3) =&gt; { console.log(`结果：${result3}`); }); }); });}doOperation(); 因为必须在回调函数中调用回调函数，我们就得到了这个深度嵌套的 doOperation() 函数，这就更难阅读和调试了。在一些地方这被称为“回调地狱”或“厄运金字塔”（因为缩进看起来像一个金字塔的侧面）。 面对这样的嵌套回调，处理错误也会变得非常困难：你必须在“金字塔”的每一级处理错误，而不是在最高一级一次完成错误处理。 由于以上这些原因，大多数现代异步 API 都不使用回调。事实上，JavaScript 中异步编程的基础是 Promise。 PromisePromise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。 使用 fetch() APIfetch() API，一个现代的、基于 Promise 的、用于替代 XMLHttpRequest 的方法。 一个处理函数传递给 Promise 的 then() 方法。当（如果）获取操作成功时，Promise 将调用我们的处理函数，传入一个包含服务器的响应的 Response 对象。 123456789101112131415const fetchPromise = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);console.log(fetchPromise);fetchPromise.then((response) =&gt; { console.log(`已收到响应：${response.status}`);});console.log(&quot;已发送请求……&quot;);//Promise { &lt;state&gt;: &quot;pending&quot; }//已发送请求……//已收到响应：200 请注意，已发送请求…… 的消息在我们收到响应之前就被输出了。与同步函数不同，fetch() 在请求仍在进行时返回，这使我们的程序能够保持响应性。响应显示了 200（OK）的状态码，意味着我们的请求成功了。 链式使用 Promise在你通过 fetch() API 得到一个 Response 对象的时候，你需要调用另一个函数来获取响应数据。这次，我们想获得 JSON 格式的响应数据，所以我们会调用 Response 对象的 json() 方法。事实上，json() 也是异步的，因此我们必须连续调用两个异步函数。 12345678910const fetchPromise = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);fetchPromise.then((response) =&gt; { const jsonPromise = response.json(); jsonPromise.then((json) =&gt; { console.log(json[0].name); });}); 在这个示例中，就像我们之前做的那样，我们给 fetch() 返回的 Promise 对象添加了一个 then() 处理程序。但这次我们的处理程序调用 response.json() 方法，然后将一个新的 then() 处理程序传递到 response.json() 返回的 Promise 中。 但 Promise 的优雅之处在于 then() 本身也会返回一个 Promise，这个 Promise 将指示 then() 中调用的异步函数的完成状态。这意味着我们可以（当然也应该）把上面的代码改写成这样： 1234567891011const fetchPromise = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);fetchPromise .then((response) =&gt; { return response.json(); }) .then((json) =&gt; { console.log(json[0].name); }); 不必在第一个 then() 的处理程序中调用第二个 then()，我们可以直接返回 json() 返回的 Promise，并在该返回值上调用第二个 “then()”。这被称为 Promise 链，意味着当我们需要连续进行异步函数调用时，我们就可以避免不断嵌套带来的缩进增加。 错误捕获Promise 对象提供了一个 catch() 方法来支持错误处理。这很像 then()：你调用它并传入一个处理函数。然后，当异步操作成功*时，传递给 then() 的处理函数被调用，而当异步操作**失败***时，传递给 catch() 的处理函数被调用。 使用 catch() 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。 123456789101112131415161718const fetchPromise = fetch( &quot;bad-scheme://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);fetchPromise .then((response) =&gt; { if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } return response.json(); }) .then((json) =&gt; { console.log(json[0].name); }) .catch((error) =&gt; { console.error(`无法获取产品列表：${error}`); });//无法获取产品列表：TypeError: Failed to fetch Promise 术语Promise 有三种状态： 待定（pending）：初始状态，既没有被兑现，也没有被拒绝。这是调用 fetch() 返回 Promise 时的状态，此时请求还在进行中。 已兑现（fulfilled）：意味着操作成功完成。当 Promise 完成时，它的 then() 处理函数被调用。 已拒绝（rejected）：意味着操作失败。当一个 Promise 失败时，它的 catch() 处理函数被调用。 有时用 已敲定（settled） 这个词来同时表示 已兑现（fulfilled） 和 已拒绝（rejected） 两种情况。 如果一个 Promise 处于已决议（resolved）状态，或者它被“锁定”以跟随另一个 Promise 的状态，那么它就是 已兑现（fulfilled）。 合并使用多个 Promise有时你需要所有的 Promise 都得到实现，但它们并不相互依赖。在这种情况下，将它们一起启动然后在它们全部被兑现后得到通知会更有效率。这里需要 Promise.all() 方法。它接收一个 Promise 数组，并返回一个单一的 Promise。 由Promise.all()返回的 Promise： 当且仅当数组中所有的 Promise 都被兑现时，才会通知 then() 处理函数并提供一个包含所有响应的数组，数组中响应的顺序与被传入 all() 的 Promise 的顺序相同。 会被拒绝——如果数组中有*任何一个* Promise 被拒绝。此时，catch() 处理函数被调用，并提供被拒绝的 Promise 所抛出的错误。 12345678910111213141516171819const fetchPromise1 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);const fetchPromise2 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;,);const fetchPromise3 = fetch( &quot;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;,);Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) =&gt; { for (const response of responses) { console.log(`${response.url}：${response.status}`); } }) .catch((error) =&gt; { console.error(`获取失败：${error}`); }); 这里我们向三个不同的 URL 发出三个 fetch() 请求。如果它们都被兑现了，我们将输出每个请求的响应状态。如果其中任何一个被拒绝了，我们将输出失败的情况。 根据我们提供的 URL，应该所有的请求都会被兑现，尽管因为第二个请求中请求的文件不存在，服务器将返回 404（Not Found）而不是 200（OK）。所以输出应该是： 123https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json：200https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found：404https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json：200 如果我们用一个错误编码的 URL 尝试同样的代码，就像这样： 12345678910111213141516171819const fetchPromise1 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);const fetchPromise2 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;,);const fetchPromise3 = fetch( &quot;bad-scheme://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;,);Promise.all([fetchPromise1, fetchPromise2, fetchPromise3]) .then((responses) =&gt; { for (const response of responses) { console.log(`${response.url}：${response.status}`); } }) .catch((error) =&gt; { console.error(`获取失败：${error}`); }); ……然后 catch() 处理程序将被运行，我们应该看到像这样的输出： 1获取失败：TypeError: Failed to fetch 有时，你可能需要等待一组 Promise 中的某一个 Promise 的执行，而不关心是哪一个。在这种情况下，你需要 Promise.any()。这就像 Promise.all()，不过在 Promise 数组中的任何一个被兑现时它就会被兑现，如果所有的 Promise 都被拒绝，它也会被拒绝。 1234567891011121314151617const fetchPromise1 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;,);const fetchPromise2 = fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/not-found&quot;,);const fetchPromise3 = fetch( &quot;https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json&quot;,);Promise.any([fetchPromise1, fetchPromise2, fetchPromise3]) .then((response) =&gt; { console.log(`${response.url}：${response.status}`); }) .catch((error) =&gt; { console.error(`获取失败：${error}`); }); 值得注意的是，在这种情况下，我们无法预测哪个获取请求会先被兑现。 这两个用于组合多个承诺的函数只是额外的 Promise 函数中的两个。 async 和 awaitasync 关键字为你提供了一种更简单的方法来处理基于异步 Promise 的代码。在一个函数的开头添加 async，就可以使其成为一个异步函数。 123async function myFunction() { // 这是一个异步函数} 在异步函数中，你可以在调用一个返回 Promise 的函数之前使用 await 关键字。这使得代码在该点上等待，直到 Promise 被完成，这时 Promise 的响应被当作返回值，或者被拒绝的响应被作为错误抛出。 这使你能够编写像同步代码一样的异步函数。例如，我们可以用它来重写我们的 fetch 示例。 1234567891011121314151617181920async function fetchProducts() { try { // 在这一行之后，我们的函数将等待 `fetch()` 调用完成 // 调用 `fetch()` 将返回一个“响应”或抛出一个错误 const response = await fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;, ); if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } // 在这一行之后，我们的函数将等待 `response.json()` 的调用完成 // `response.json()` 调用将返回 JSON 对象或抛出一个错误 const json = await response.json(); console.log(json[0].name); } catch (error) { console.error(`无法获取产品列表：${error}`); }}fetchProducts(); 这里我们调用 await fetch()，我们的调用者得到的并不是 Promise，而是一个完整的 Response 对象，就好像 fetch() 是一个同步函数一样。 我们甚至可以使用 try…catch 块来处理错误，就像我们在写同步代码时一样。 但请注意，这个写法只在异步函数中起作用。 异步函数总是返回一个 Pomise，所以你不能做这样的事情： 1234567891011121314151617async function fetchProducts() { try { const response = await fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;, ); if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } const json = await response.json(); return json; } catch (error) { console.error(`无法获取产品列表：${error}`); }}const json = fetchProducts();console.log(json[0].name); // json 是一个 Promise 对象，因此这句代码无法正常工作 相反，你需要做一些事情，比如： 1234567891011121314151617async function fetchProducts() { try { const response = await fetch( &quot;https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json&quot;, ); if (!response.ok) { throw new Error(`HTTP 请求错误：${response.status}`); } const json = await response.json(); return json; } catch (error) { console.error(`无法获取产品列表：${error}`); }}const jsonPromise = fetchProducts();jsonPromise.then((json) =&gt; console.log(json[0].name)); 你可能会在需要使用 Promise 链地方使用 async 函数，这也使得 Promise 的工作更加直观。 请记住，就像一个 Promise 链一样，await 强制异步操作以串联的方式完成。如果下一个操作的结果取决于上一个操作的结果，这是必要的，但如果不是这样，像 Promise.all() 这样的操作会有更好的性能。 实现基于 Promise 的 API讨论了如何使用返回 promises 的 APIs。在本文中，我们将研究另一方面——如何实现返回 promises 的 APIs。跟使用基于 promise 的 APIs 相比，这是一个不太常见的任务，但它仍然值得了解。 通常情况下，当你实现一个基于 promise 的 API 时，你会使用事件、普通回调，或者消息传递模型来包裹一个异步操作。你将会使用一个 Promise 对象来合理的处理操作的成功或者失败。 实现 alarm() API在这个示例中我们将会实现一个基于 promise 的 alarm API，叫做 alarm() 。它将以被唤醒人的名字和一个在人被唤醒前以毫秒为单位的延迟作为参数。在延迟之后，本函数将会发送一个包含需要被唤醒人名字的 “Wake up!” 消息。 用 setTimeout() 包裹我们将会使用 setTimeout() 来实现 alarm() 函数。setTimeout() 以一个回调函数和一个以毫秒为单位的延迟作为参数。当调用 setTimeout() 时，它将启动一个设置为给定延迟的计时器，当时间过期时，它就会调用给定的回调函数。 12345678910111213&lt;button id=&quot;set-alarm&quot;&gt;Set alarm&lt;/button&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;const output = document.querySelector(&quot;#output&quot;);const button = document.querySelector(&quot;#set-alarm&quot;);function setAlarm() { window.setTimeout(() =&gt; { output.textContent = &quot;Wake up!&quot;; }, 1000);}button.addEventListener(&quot;click&quot;, setAlarm); Promise() 构造器alarm() 函数返回一个在定时器过期时才会被兑现的 Promise。它将会传递一个 “Wake up!” 消息到 then() 处理器中，也会在当调用者提供一个负延迟值时拒绝这个 promise。 这里的关键组件是 Promise() 构造器。Promise() 构造器使用单个函数作为参数。我们把这个函数称作执行器（executor）。当你创建一个新的 promise 的时候你需要实现这个执行器。 这个执行器本身采用两个参数，这两个参数都是函数，通常被称作 resolve 和 reject。在你的执行器实现里，你调用原始的异步函数。如果异步函数成功了，就调用 resolve，如果失败了，就调用 reject。如果执行器函数抛出了一个错误，reject 会被自动调用。你可以将任何类型的单个参数传递到 resolve 和 reject 中。 12345678910function alarm(person, delay) { return new Promise((resolve, reject) =&gt; { if (delay &lt; 0) { throw new Error(&quot;Alarm delay must not be negative&quot;); } window.setTimeout(() =&gt; { resolve(`Wake up, ${person}!`); }, delay); });} 此函数创建并且返回一个新的 Promise。对于执行器中的 promise，我们： 检查 delay（延迟）是否为负数，如果是的话就抛出一个错误。 调用 window.setTimeout()，传递一个回调函数和 delay（延迟）。当计时器过期时回调会被调用，在回调函数内，我们调用了 resolve，并且传递了 “Wake up!” 消息。 使用 alarm() API123456789101112131415161718192021const name = document.querySelector(&quot;#name&quot;);const delay = document.querySelector(&quot;#delay&quot;);const button = document.querySelector(&quot;#set-alarm&quot;);const output = document.querySelector(&quot;#output&quot;);function alarm(person, delay) { return new Promise((resolve, reject) =&gt; { if (delay &lt; 0) { throw new Error(&quot;Alarm delay must not be negative&quot;); } window.setTimeout(() =&gt; { resolve(`Wake up, ${person}!`); }, delay); });}button.addEventListener(&quot;click&quot;, () =&gt; { alarm(name.value, delay.value) .then((message) =&gt; (output.textContent = message)) .catch((error) =&gt; (output.textContent = `Couldn't set alarm: ${error}`));}); 在 alarm() API 上使用 async 和 await自从 alarm() 返回了一个 Promise，我们可以对它做任何我们可以对其他任何 promise 做的事情：Promise.all()，和 async / await： 123456789101112131415161718192021222324const name = document.querySelector(&quot;#name&quot;);const delay = document.querySelector(&quot;#delay&quot;);const button = document.querySelector(&quot;#set-alarm&quot;);const output = document.querySelector(&quot;#output&quot;);function alarm(person, delay) { return new Promise((resolve, reject) =&gt; { if (delay &lt; 0) { throw new Error(&quot;Alarm delay must not be negative&quot;); } window.setTimeout(() =&gt; { resolve(`Wake up, ${person}!`); }, delay); });}button.addEventListener(&quot;click&quot;, async () =&gt; { try { const message = await alarm(name.value, delay.value); output.textContent = message; } catch (error) { output.textContent = `Couldn't set alarm: ${error}`; }}); worker在本模块的第一篇文章中，我们看到了当在你的程序中具有一个长期运行的的同步任务时发生了什么 ── 整个窗口变得完全没有响应。从根本上讲，出现这种情况的原因是程序是单线程的。一个线程是程序遵循的一系列指令。因为程序由一个线程组成，它在同一时间只能做一件事情：所以如果它正在等待我们的长期运行的同步调用返回，它就不能做其他任何事情。 Workers 给了你在不同线程中运行某些任务的能力，因此你可以启动任务，然后继续其他的处理（例如处理用户操作）。 但是这是要付出代价的。对于多线程代码，你永远不知道你的线程什么时候将会被挂起，其他线程将会得到运行的机会。因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化，这将导致很难发现的 Bug。 为了避免 Web 中的这些问题，你的主代码和你的 worker 代码永远不能直接访问彼此的变量。Workers 和主代码运行在完全分离的环境中，只有通过相互发送消息来进行交互。特别是，这意味着 workers 不能访问 DOM（窗口、文档、页面元素等等）。 有三种不同类型的 workers： dedicated workers shared workers service workers 使用 web workers（dedicated workers）用 worker 进行质数生成： 目录下有四个文件： index.html style.css main.js generate.js 12345678910111213141516171819202122&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot; defer&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;label for=&quot;quota&quot;&gt;Number of primes:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;quota&quot; name=&quot;quota&quot; value=&quot;1000000&quot; /&gt; &lt;button id=&quot;generate&quot;&gt;Generate primes&lt;/button&gt; &lt;button id=&quot;reload&quot;&gt;Reload&lt;/button&gt; &lt;textarea id=&quot;user-input&quot; rows=&quot;5&quot; cols=&quot;62&quot;&gt; Try typing in here immediately after pressing &quot;Generate primes&quot;&lt;/textarea &gt; &lt;div id=&quot;output&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234textarea { display: block; margin: 1rem 0;} “main.js” 和 “generate.js” 文件是空的。我们将向 “main.js” 中添加主代码，向 “generate.js” 中添加 worker 代码。 首先，我们可以看到 worker 代码被保存在一个与主代码隔离的脚本中。我们还可以看到，在上面的 “index.html” 中，只有主代码被包含在 &lt;script&gt; 标签中。 123456789101112131415161718192021222324// 在 &quot;generate.js&quot; 中创建一个新的 workerconst worker = new Worker(&quot;./generate.js&quot;);// 当用户点击 &quot;Generate primes&quot; 时，给 worker 发送一条消息。// 消息中的 command 属性是 &quot;generate&quot;, 还包含另外一个属性 &quot;quota&quot;，即要生成的质数。document.querySelector(&quot;#generate&quot;).addEventListener(&quot;click&quot;, () =&gt; { const quota = document.querySelector(&quot;#quota&quot;).value; worker.postMessage({ command: &quot;generate&quot;, quota: quota, });});// 当 worker 给主线程回发一条消息时，为用户更新 output 框，包含生成的质数（从 message 中获取）。worker.addEventListener(&quot;message&quot;, (message) =&gt; { document.querySelector(&quot;#output&quot;).textContent = `Finished generating ${message.data} primes!`;});document.querySelector(&quot;#reload&quot;).addEventListener(&quot;click&quot;, () =&gt; { document.querySelector(&quot;#user-input&quot;).value = 'Try typing in here immediately after pressing &quot;Generate primes&quot;'; document.location.reload();}); 首先，我们使用 Worker() 构造函数创建 worker。我们传递一个指向 worker 脚本的 URL。只要 worker 被创建了，worker 脚本就会执行。 其次，与同步版本一样，我们向 “Generate primes” 按钮添加一个 click 事件处理器。但是现在，我们不再调用 generatePrimes() 函数，而是使用 worker.postMessage() 向 worker 发送一条消息。这条消息可以携带一个参数，在本示例中我们传递一个包含两个属性的 JSON 对象： command：一个用于标识我们希望 worker 所做事情的字符串（以防我们的 worker 可以做多个事情）。 quota：要生成的质数的数量。 然后，我们向 worker 添加一个 message 消息处理器。这样 worker 就能告诉我们它是什么时候完成的，并且传递给我们任何结果数据。我们的处理器从消息的 data 属性获取数据，然后将其写入 output 元素（数据与 quota 是完全相同的，这虽然没有意义，但是这展示了其中原理）。 最后，我们为 “Reload” 按钮实现了 click 事件处理器。这与同步版本完全相同。 1234567891011121314151617181920212223242526272829303132// 监听主线程中的消息。// 如果消息中的 command 是 &quot;generate&quot;，则调用 `generatePrimse()`addEventListener(&quot;message&quot;, (message) =&gt; { if (message.data.command === &quot;generate&quot;) { generatePrimes(message.data.quota); }});// 生成质数 (非常低效)function generatePrimes(quota) { function isPrime(n) { for (let c = 2; c &lt;= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const primes = []; const maximum = 1000000; while (primes.length &lt; quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } // 完成后给主线程发送一条包含我们生成的质数数量的消息消息。 postMessage(primes.length);} 请记住，只要主脚本创建 worker，“generate.js”这些代码就会运行。 worker 要做的第一件事情就是开始监听来自主脚本的消息。这通过使用 addEventListener() 实现，它在 worker 中是一个全局函数。在 message 事件处理器内部，事件的 data 属性包含一个来自主脚本的参数的副本。如果主脚本传递 generate 命令，我们就调用 generatePrimes()，传入来自消息事件的 quota 值。 generatePrimes() 函数与同步版本类似，只不过我们在完成后向主脚本发送一条消息，而不是返回一个值。我们对此使用 postMessage() 函数，就像在 worker 中 addEventListener是全局函数一样。如我们所见，主脚本正在监听这条消息并且将会在收到消息后更新 DOM。 其他类型的 worker其他类型的 worker： SharedWorker 可以由运行在不同窗口中的多个不同脚本共享。 Service worker 的行为就像代理服务器，缓存资源以便于 web 应用程序可以在用户离线时工作。他们是渐进式 Web 应用的关键组件。","link":"/2019/11/09/%E5%89%8D%E7%AB%AF/JavaScript/javaScript%E5%BC%82%E6%AD%A5/"},{"title":"Ant Design 组件二次封装","text":"为什么需要二次封装： 减少重复工作量 统一风格 补充需求功能 方便一键式更改（如果样式变更，减少工作量） 二次封装的原则：1. 暴露组件库本身的属性： 绑定$attrs暴露props 123&lt;template&gt; &lt;a-table v-bind=&quot;$attrs&quot;&gt;&lt;/a-table&gt;&lt;/template&gt; 把子组件的props赋给当前组件的props 1234567891011121314&lt;template&gt; &lt;a-table v-bind=&quot;$props&quot;&gt;&lt;/a-table&gt;&lt;/template&gt; &lt;script&gt;import {Table} from 'ant-design-vue'export default { props: { ...Table.props, ...myProps } }&lt;/script&gt; 2. 暴露组件库本身的事件： 绑定$listeners暴露事件 123&lt;template&gt; &lt;a-table v-on=&quot;$listeners&quot;&gt;&lt;/a-table&gt;&lt;/template&gt; v-on=“$listeners“与重写事件有冲突，会执行两次：第一个是v-on=”$listeners”，第二个是@change=”onSelectChange 123456789101112131415161718//change 事件重写，返回更多的参数//组件&lt;template&gt; &lt;a-table @change=&quot;changeSelect&quot; v-on=&quot;$listeners&quot;&gt;&lt;/a-table&gt;&lt;/template&gt;&lt;script&gt; method: { changeSelect(val) { this.$emit('change', val) } }&lt;/script&gt;//父组件&lt;template&gt; &lt;MyTable @change=&quot;selectChange&quot;&gt;&lt;/MyTable&gt;&lt;/template&gt; 解决：去掉 @change=“changeSelect”， 使用 new$listeners 继承原有属性，并覆盖原有事件。 12345678910111213141516171819&lt;template&gt; &lt;a-table v-on=&quot;new$listeners&quot;&gt;&lt;/a-table&gt;&lt;/template&gt;&lt;script&gt; computed: { new$listeners() { return Object.assign(this.$listeners, { //在这里覆盖原有的change事件 change: this.changeSelect }) } }, method: { changeSelect(val) { this.$emit('change', val) } }&lt;/script&gt; 3. 绑定slots和scopedSlots暴露插槽：12345678910111213141516171819202122232425&lt;template&gt; &lt;a-table&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 处理 scopedSlots --&gt; &lt;template v-for=&quot;slotName of scopedSlotsKeys&quot; :slot=&quot;slotName&quot;&gt; &lt;slot :name=&quot;slotName&quot;&gt;&lt;/slot&gt; &lt;/template&gt; &lt;!-- 处理 slots --&gt; &lt;template v-for=&quot;slotName of slotsKeys&quot; v-slot:[slotName]&gt; &lt;slot :name=&quot;slotName&quot;&gt;&lt;/slot&gt; &lt;/template&gt; &lt;/a-table&gt;&lt;/template&gt;&lt;script&gt; computed: { slotsKeys() { return Object.keys(this.$slots).filter((key) =&gt; !this.usedSlots.includes(key)) }, scopedSlotsKeys() { return Object.keys(this.$scopedSlots).filter((key) =&gt; !this.usedSlots.includes(key)) }, },&lt;/script&gt; 4. 暴露实例的方法123456789101112131415161718//组件methods:{ getRefTable(){ return this.$refs.refTable } }} //父组件methods:{ loadData(){ this.$nextTick(() =&gt; { //只要拿到这个实例，this.$refs.child.getRefTable()，想调方法后面跟链式调用即可 this.$refs.child.getRefTable().getCheckedNodes() }) } }} 二次封装的注意点： 不要修改props的数据 如果业务接口更新的是props中的数据，那就不要这段业务代码，放到父组件去做更好。 不要在vue文件里封装多个数据入口 当一个组件要耦合多个数据入口时，就不要把请求写在子组件里面，而是把这个组件改造为纯展示组件，跟业务解耦，把业务请求交给父组件。 组件里面最好都用静态。 载体分离原则 载体是展示的方式，例如弹窗、抽屉等等，最好把内容和载体分离，便于修改和维护。 实现双向绑定，简化事件处理 封装输入框、复选框这种组件的时候，需要保留 v-model 。 修改组件库的样式 修改单个文件的样式，可以使用 /deep/ 来深度选择到你要修改的样式（能省去一大串的类名）。 修改全局的样式，可以在全局样式文件中写样式覆盖，引入到 main.js 中即可全局生效。","link":"/2023/04/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/Ant%20Design%20%E7%BB%84%E4%BB%B6%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"},{"title":"低代码简介","text":"什么是底码低代码开发平台是一种允许用户使用图形化界面和少量的手动编码来快速构建应用程序的工具。通过低代码平台，开发人员可以使用预先构建好的模块和组件来创建应用程序，而无需从头开始编写代码。 低代码的定义低代码是一种通过图形化界面创建应用程序的开发方式，它允许用户使用预先构建好的模块和组件来创建应用程序，而无需从头开始编写代码。 低代码开发平台是一种允许用户使用图形化界面和少量的手动编码来快速构建应用程序的工具。通过低代码平台，开发人员可以使用预先构建好的模块和组件来创建应用程序，而无需从头开始编写代码。 低代码的定义低代码的优点 加速开发速度： 低代码平台提供了丰富的预构建组件和模块，开发人员可以通过拖拽、配置等简单的方式快速构建应用程序，大大加快了开发速度。 降低技术门槛： 低代码平台将复杂的编码过程简化为图形化界面操作，使非专业开发人员也能够参与应用程序的开发，降低了技术门槛，提高了开发的参与度。 灵活性和可定制性： 尽管低代码平台提供了丰富的预构建组件和模块，但用户仍然可以根据自己的需求进行定制和扩展，使应用程序更符合实际业务需求。 易于维护和更新： 由于低代码平台的模块化设计，应用程序的维护和更新变得更加容易。开发人员可以快速对组件进行修改和更新，而不会影响到整个应用程序的稳定性。 提高生产力和效率： 低代码平台使开发过程更加高效和自动化，大大提高了开发团队的生产力和工作效率。开发人员可以将更多的精力集中在业务逻辑和创新上，而不是底层的技术实现。 促进协作与沟通： 低代码平台为团队成员提供了一个统一的开发环境和工作平台，促进了团队之间的协作和沟通，有助于更好地管理项目和资源。 低代码技术分类完整的低码开发平台包含四大体系（BRWP），表单（B）、规则（R）、流程（W）、权限（P），这四大体系的相互关系如下： 四大体系内的组件与业务高度解耦，但又可以通过多种机制便捷高效的聚合。 表单：前端数据录入及展现体系，有丰富的数据交互组件和可视化组件，主要通过配置化方式实现业务所需的各种表单。 权限：包括功能权限和数据权限，功能权限是以用户角色（或岗位）为单元，管理用户安全访问和操作功能，管理单元可以延伸到按钮。数据权限是以用户所访问的数据对象（表或视图）为单元，通过授予用户管理的对象要素及要素内容实现对象内行级数据隔离访问。 流程：基于工作流引擎，结合行业应用特色，以可视化配置的方式，实现流程即配即用，多版本共存，与表单、权限、规则体系协同管控数据的流转及跟踪追溯。 规则：通过建立标准化的业务规则开发规范以及统一的规则触发机制，由规则引擎自动实现事前、事中、事后的动态校验和智能提醒。规则可以提前制定，限时生效。 上述四大体系基础上加上不断扩展的体系（如报表体系、帮助体系、接口体系等）形成BRWP+的产品研发技术体系。 主流的低代码钉钉宜搭 https://www.aliwork.com/ outsystems https://www.outsystems.com/ 简道云 https://www.jiandaoyun.com/ 低代码适用场景： 企业内部应用开发： 低代码平台可以帮助企业快速开发内部管理系统、人力资源系统、客户关系管理系统等企业级应用。这些应用通常具有一些共同的特征，例如标准化的业务流程、简单的数据管理需求等，适合使用低代码平台快速开发。 移动应用开发： 对于需要快速推出移动应用的场景，低代码平台提供了一种简单的开发方式。开发人员可以利用低代码平台快速构建移动应用的界面和功能，并在多个平台上进行部署，从而节省了开发时间和成本。 外部客户应用开发： 对于需要向外部客户提供定制化应用的服务提供商或软件开发公司，低代码平台可以帮助他们更快地响应客户需求，快速开发定制化的应用程序，并提供灵活的定制和扩展能力。 快速原型设计： 对于需要快速验证想法和设计原型的场景，低代码平台提供了一个快速、灵活的开发环境。开发人员可以利用低代码平台快速构建原型，演示和验证想法，从而加快产品上线的速度。 业务流程自动化： 低代码平台提供了丰富的工作流和自动化功能，适用于各种业务流程自动化场景。例如，审批流程、报销流程、订单处理流程等，都可以通过低代码平台快速实现自动化，提高工作效率。 低代码发展在低代码平台的发展过程中，与人工智能和大数据分析的结合也逐渐成为一个趋势。主要的方案： 一种是通过大模型技术生成符合低代码格式的低代码组件，同时生成相应的样式配置，最终通过低代码搭建平台进行二次编辑，但该方案在目前还是太超前，技术难点高，还没有商业化的案例。 一种方案是大模型核心负责页面样式、文案等配置，可提供针对不同领域场景的配色、主题方案，再由相应的桥阶层来转化为低代码的 json tree，最后再由 json tree 来结合相应的低代码组件渲染页面，相当于组件是确定的，但组件的样式等配置由大模型来生成。","link":"/2023/05/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"},{"title":"低代码设计器的实现原理","text":"什么是低代码设计器将组件以可视化交互方式编排成想要的布局和配置，并将配置结果以某种方式渲染出来。 低代码设计器的实现原理 关键技术方案：用来搭建的组件需要复用普通的前端组件，且配置面板的内容可以定制。 关键技术方案：实现可视化编排，编排结果能还原成页面。 一般需求：设计器整体UI框架、设计前面板机制、拖拽机制、设置面板配置和显示机制、画布机制、快捷键机制、产物直接渲染能力、产物转成代码的能力等。 关键技术方案：用来搭建的组件需要复用普通的前端组件，且配置面板的内容可以定制组件的分类：基础组件、业务组件、自定义组件 每个组件的设置面板配置： 配置项是配什么： 映射到源码如何使用组件开发： 组件属性(props) 组件回调函数(callback) 设置面板布局/显示相关： 以什么UI交互形式(下拉/输入/…)给属性/回调赋值 对设置面板进行调整,有些不需要展示的可以不展示(分组、是否显示某属性) 以什么格式： JSON 举例： 组件就是指物料。 JSON 是有规范的：写的人和用的人都需要知道。（《物理描述规范》） Setter-设置器：对组件的设置，例如不同组件样式等。给某一种值类型的prop去赋值的ui组件。每个prop是什么类型的可以用什么ui组件去赋值。例如有输入框、开关、选择框等 关键技术方案：实现可视化编排，编排结果能还原成页面。编排：如何推拽，如何放到合适的位置，如何存起来、还原等。 知识点：Drag and Drop API，一组 HTML 原生 API，用来将一个可拖拽(draggable)的元素拖到一个可以被放置(droppable)的位置。 拖拽是拖拽对组件的描述，画布是有一个结构描述，又称数据模型。画布的展示是对数据模型的反馈。数据模型的变动可以带来画布展示的变动。 当拖动发生时： \\1.组件被选中并移动，记录了一个draggable的元素。(例如 componentName:’Button’) \\2. 移动到画布区域后，拖拽引擎根据鼠标位置寻找最适合的插入位置。 \\3. 鼠标松开后，将 {componentName:’Button’}插入到画布的模型中，形成新的模型，并具象的将UI展示出来。 编排和渲染过程的基本原理： 设计过程：n * (组件+组件的配置) + 特定的顺序和层级结构 = 模型描述(JSON) 渲染过程：模型描述(JSON) ——&gt; 1.解析 2.加载依赖组件 3. 按顺序和层级渲染组件 ——&gt; 还原页面布局","link":"/2023/08/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"前端安全性","text":"一、前端有哪些安全性问题及危害 跨站脚本攻击（XSS）：XSS攻击发生在恶意用户将恶意脚本注入到网页中，然后用户在浏览器中运行这些脚本时会受到攻击。 危害：这些脚本可能会窃取用户的敏感信息，如cookie、session、密码等，或者篡改网页的内容和样式，或者执行一些恶意的操作，如弹出广告、重定向、下载木马等。 跨站请求伪造（CSRF）：CSRF攻击发生在恶意用户利用用户已经登录的网站的身份，向该网站发送一些请求。 危害：执行一些非法的操作，如转账、修改密码、删除数据等。用户可能不知道自己的身份被利用，或者被诱导点击一些链接或按钮，触发这些请求。 点击劫持（ClickJacking）：点击劫持攻击发生在恶意用户在一个网页上覆盖了另一个网页的一部分，让用户以为自己在点击原网页的内容，实际上却在点击被覆盖的网页的内容。 危害：会执行一些不知情的操作，如关注、点赞、授权等。 错误的内容推断（Content Sniffing）：内容推断攻击发生在浏览器在接收到服务器返回的内容时，没有正确地根据内容类型（Content-Type）来解析，而是根据内容的内容来猜测。 危害：导致一些非预期的结果，如将一些文本文件当作脚本文件来执行，或者将一些图片文件当作HTML文件来渲染。 中间人攻击（Man-in-the-Middle Attack）：中间人攻击发生在用户与服务器之间的通信被第三方截获。 危害：窃取或篡改通信的内容，如请求、响应、数据、证书等。这可能会导致用户的信息泄露，或者被欺骗访问一些假冒的网站。 HTTP劫持（HTTP Hijacking）：HTTP劫持攻击发生在用户访问一些没有使用HTTPS协议的网站时，第三方可以在用户与服务器之间插入一些恶意的代码或内容。 危害：影响用户的正常浏览，或者执行一些恶意的操作，如弹出广告、重定向、下载木马等。 DNS劫持（DNS Hijacking）：DNS劫持攻击发生在用户访问一些网站时，第三方可以修改DNS服务器的解析结果。 危害：将用户的请求导向一些假冒的网站，或者拦截用户的请求，从而影响用户的正常浏览，或者执行一些恶意的操作，如弹出广告、重定向、下载木马等。 SQL注入（SQL Injection）：SQL注入攻击发生在用户向服务器发送一些包含SQL语句的数据时，服务器没有正确地过滤或转义这些数据，而是直接拼接到SQL语句中执行。 危害：导致数据库的数据被泄露、修改、删除或破坏。 二、安全性检测工具 AWVS：AWVS是一款专注于Web应用程序的自动化扫描工具，它可以快速地识别和报告各种Web漏洞，如XSS、SQL注入、文件包含等。它还可以进行源代码分析、漏洞验证和报表生成等功能。 优点：扫描速度快、准确率高、漏洞规则库全面。 缺点：没有中文界面、功能单一、不能进行手动测试。 网站：https://www.acunetix.com IBM AppScan：IBM AppScan是一款由IBM开发的Web应用程序安全测试和漏洞扫描工具，它可以利用自动扫描、手动探测和混合模式来检测Web应用程序中的漏洞。它还可以进行代码审查、合规评估和风险管理等功能。 优点：功能强大、支持多种技术和协议、适合扫描大型和复杂的应用程序。 缺点：价格昂贵、扫描速度一般、操作复杂。 网站：https://www.hcltechsw.com/products/appscan Xray：Xray是一款由长亭科技开发的Web安全扫描工具，它可以利用被动扫描的方式来发现Web应用程序中的漏洞。它还可以利用自定义的POC来扫描特定的漏洞，或者利用内置的盲打平台来验证一些难以检测的漏洞。 优点：功能灵活、支持多种平台和语言、有社区版和高级版可供选择。 缺点：扫描范围有限、需要配合其他工具使用、误报率较高。 网站：https://xray.cool ESLint： 主要用于检测代码质量和潜在的安全问题，包括 XSS、CSRF 等。 优点：强大的插件系统，支持定制规则；广泛应用于前端项目。 缺点：无法覆盖所有安全问题，主要关注代码规范和质量。 网站：https://eslint.org/ OWASP ZAP：OWASP ZAP是一个开源的、跨平台的、易于使用的网络应用程序安全测试工具，可以帮助开发者和测试人员发现和修复网络应用程序的安全漏洞，如XSS、CSRF、SQL注入等。 优点：功能强大、支持多种模式和插件、支持自动化和集成、支持多种语言和平台、有活跃的社区和文档。 缺点：界面不够友好、有一定的学习成本、可能会产生一些误报或漏报。 网站：https://www.zaproxy.org/ Nmap：Nmap是一个开源的、跨平台的、命令行的网络探测和安全扫描工具，可以帮助开发者和测试人员发现和分析网络上的主机和服务，如端口、协议、操作系统、版本等。 优点：功能强大、支持多种扫描技术和脚本、支持自动化和集成、有丰富的文档和案例。 缺点：界面不够友好、有一定的学习成本、可能会被防火墙或入侵检测系统检测或阻止。 网站：https://nmap.org/ Retire.js：Retire.js是一个开源的、基于JavaScript的、浏览器或命令行的前端安全扫描工具，可以帮助开发者和测试人员发现和更新网页中使用的过时或有漏洞的JavaScript库，如jQuery、Angular、React等。 优点：功能简单、易于使用、支持多种浏览器和平台、有活跃的社区和文档。 缺点：功能单一、只能检测JavaScript库的漏洞、可能会产生一些误报或漏报。 网站：https://github.com/retirejs/retire.js/ SonarQube： 检测内容：代码质量审查，包括安全漏洞。 优点：集成到CI/CD流程，自动化审查。 缺点：配置和维护需要专业知识。 网站：https://www.sonarsource.com/products/sonarqube/ Snyk： 检测内容：依赖的安全性检查。 优点：易于使用，提供实时反馈。 缺点：在某些复杂的项目中可能不够深入。 网站：https://snyk.io/ 三、如何防范 防范XSS攻击：防范XSS攻击的主要方法是对用户输入的数据进行验证和编码，避免在网页中直接插入用户提供的内容，或者使用一些安全的模板引擎或框架来渲染网页。另外，还可以使用内容安全策略（CSP）来限制网页中可以执行的脚本的来源，或者使用HTTP头部的X-XSS-Protection来启用浏览器的XSS过滤器。 防范CSRF攻击：防范CSRF攻击的主要方法是对用户发送的请求进行验证，确保请求是由用户本人发起的，而不是被第三方诱导或伪造的。常用的验证方法有使用验证码、token、referer、origin等来检查请求的合法性，或者使用HTTP头部的SameSite属性来限制cookie的跨域发送。 防范点击劫持攻击：防范点击劫持攻击的主要方法是使用HTTP头部的X-Frame-Options来禁止网页被嵌入到其他网页中，或者使用JavaScript的framebusting技术来检测和跳出被嵌套的情况，或者使用可视化的提示或确认来提醒用户点击的内容。 防范内容推断攻击：防范内容推断攻击的主要方法是使用HTTP头部的X-Content-Type-Options来禁止浏览器对内容类型进行推断，或者使用正确的内容类型（Content-Type）和字符集（Charset）来标识服务器返回的内容，或者使用文件扩展名来区分不同类型的文件。 防范中间人攻击：防范中间人攻击的主要方法是使用HTTPS协议来加密用户与服务器之间的通信，或者使用数字证书来验证服务器的身份，或者使用HSTS（HTTP Strict Transport Security）来强制浏览器只使用HTTPS协议，或者使用HPKP（HTTP Public Key Pinning）来绑定服务器的公钥，或者使用DNSSEC（DNS Security Extensions）来保护DNS的完整性。 防范HTTP劫持攻击：防范HTTP劫持攻击的主要方法是使用HTTPS协议来加密用户与服务器之间的通信，或者使用CSP（Content Security Policy）来限制网页中可以加载的资源的来源，或者使用SRI（Subresource Integrity）来验证网页中加载的资源的完整性，或者使用HTTP头部的X-Content-Type-Options和X-XSS-Protection来禁止浏览器对内容类型进行推断和过滤XSS攻击。 防范DNS劫持攻击：防范DNS劫持攻击的主要方法是使用HTTPS协议来加密用户与服务器之间的通信，或者使用数字证书来验证服务器的身份，或者使用DNSSEC（DNS Security Extensions）来保护DNS的完整性，或者使用DNSCrypt来加密DNS的查询和响应，或者使用可信的DNS服务器，如Google Public DNS或Cloudflare DNS。 防范SQL注入攻击：防范SQL注入攻击的主要方法是对用户输入的数据进行验证和转义，避免在SQL语句中直接拼接用户提供的内容，或者使用参数化的查询或预编译的语句来执行SQL语句，或者使用ORM（Object Relational Mapping）框架来操作数据库，或者使用最小权限的用户来访问数据库，或者使用WAF（Web Application Firewall）来过滤恶意的请求。","link":"/2023/09/29/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7/"},{"title":"发布 npm 包","text":"创建 创建一个文件 —— 例：nocode 进入文件夹，运行npm init,生成 package.json 编写代码 发布 上传到 github 仓库进行版本控制(可选) —— 例：nocode 123456git initgit add .git commit -m &quot;first commit&quot;git branch -M mastergit remote add origin git@github.com:xxx/shang-utils.gitgit push -u origin master 检查 npm 源并切换到 npm 源 1234567// 查看npm镜像源地址npm config get registry// 设置npm默认源npm config set registry https://registry.npmjs.org/// 设置npm镜像源为淘宝镜像npm config set registry https://registry.npm.taobao.org/ 在项目文件夹命令行进行登录： 12345678910// 登陆npm login// 控制台会提示输入相关信息Log in on https://registry.npmjs.org/Username: // 用户名Password: // 密码Email: (this IS public) // 邮箱Enter one-time password: // 如果之前做过 双因素身份验证 (2FA)，需要生成一次性密钥Logged in as xxx on https://registry.npmjs.org/ 发布命令：npm publish 如果是一个 vue 项目或其他大项目需要写导出文件和打包项目再发布到npm。 使用 在项目中安装依赖：例：npm install nocode 可以在 node_modules 目录下看到 nocode 包文件 使用 更新版本选择(三选一)并发布： 12345678// patch：补丁号，修复bug，小变动，如 v1.0.0-&gt;v1.0.1npm version patch// minor：次版本号，增加新功能，如 v1.0.0-&gt;v1.1.0npm version minor// major：主版本号，不兼容的修改，如 v1.0.0-&gt;v2.0.0npm version major 12// 重新发布npm publish 案例： 12345// 控制台会返回下一个小版本号 如v1.0.1npm version patch// 重新发布npm publish","link":"/2023/06/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85/"},{"title":"移动端适配","text":"移动端适配是使应用在各种设备(不同设备的屏幕尺寸和分辨率差异较大)上都能良好地显示。 viewportviewport即视窗、视口，用于显示网页部分的区域，在PC端视口即是浏览器窗口区域，在移动端，为了让页面展示更多的内容，视窗的宽度默认不为设备的宽度，在移动端视窗有三个概念：布局视窗、视觉视窗、理想视窗。 布局视窗：移动设备上的浏览器会把自己默认的viewport设为980px或其他值，一般都比移动端浏览器可视区域大很多，会有横向滚动条。 视觉视窗：终端设备显示网页的区域。 理想视窗：终端屏幕的宽度，页面刚好全部展现在视窗内，不会出现横向滚动条。 通过设置 viewport 可以设置页面大小，在 meta 标签可以设置 viewport 信息： 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, minimum-sacle=1, maximum-scale=1&quot; &gt; 属性 含义 取值 width 定义视口的宽度，单位为像素 正整数或设备宽度device-width height 定义视口的高度，单位为像素 正整数或device-height initial-scale 定义网页初始缩放值 整数或小数，小数为缩小，反之放大 maximum-scale 定义缩放最大值 整数或小数 minimum-scale 定义缩放最小值 整数或小数 user-scalable 定义用户是否可以缩放 yes/no 适配方案rem 布局 rem单位是相对于字体大小的html元素，也称为根元素。 默认情况下，html元素的font-size为16px。所以此时1rem = 16px。 如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可（而em是相对于父元素的）。 rem响应式的布局思想： 一般不要给元素设置具体的宽度，但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值，设计稿有多大，我们就严格有多大 所有设置的固定值都用rem做单位（首先在HTML总设置一个基准值：px和rem的对应比例，然后在效果图上获取px值，布局的时候转化为rem值) js获取真实屏幕的宽度，让其除以设计稿的宽度，算出比例，把之前的基准值按照比例进行重新的设定，这样项目就可以在移动端自适应了 rem布局的缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，也就是说css样式和js代码有一定的耦合性，且必须将改变font-size的代码放在css样式之前。 123456789/*上述代码中将视图容器分为10份，font-size用十分之一的宽度来表示，最后在header标签中执行这段代码，就可以动态定义font-size的大小，从而1rem在不同的视觉容器中表示不同的大小，用rem固定单位可以实现不同容器内布局的自适应。*/function refreshRem() { var docEl = doc.documentElement; var width = docEl.getBoundingClientRect().width; var rem = width / 10; docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;}win.addEventListener('resize', refreshRem); rem布局也是目前多屏幕适配的最佳方式。默认情况下我们html标签的font-size为16px,利用媒体查询，设置在不同设备下的字体大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* pc width &gt; 1100px */html{ font-size: 100%;}body { background-color: yellow; font-size: 1.5rem;}/* ipad pro */@media screen and (max-width: 1024px) { body { background-color: #FF00FF; font-size: 1.4rem; }}/* ipad */@media screen and (max-width: 768px) { body { background-color: green; font-size: 1.3rem; }}/* iphone6 7 8 plus */@media screen and (max-width: 414px) { body { background-color: blue; font-size: 1.25rem; }}/* iphoneX */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 3) { body { background-color: #0FF000; font-size: 1.125rem; }}/* iphone6 7 8 */@media screen and (max-width: 375px) and (-webkit-device-pixel-ratio: 2) { body { background-color: #0FF000; font-size: 1rem; }}/* iphone5 */@media screen and (max-width: 320px) { body { background-color: #0FF000; font-size: 0.75rem; }} 1234567891011121314151617181920212223242526272829303132//动态为根元素设置字体大小function init () { // 获取屏幕宽度 var width = document.documentElement.clientWidth // 设置根元素字体大小。此时为宽的10等分 document.documentElement.style.fontSize = width / 10 + 'px'}//首次加载应用，设置一次init()// 监听手机旋转的事件的时机，重新设置window.addEventListener('orientationchange', init)// 监听手机窗口变化，重新设置window.addEventListener('resize', init)@media screen and (max-width: 414px) { html { font-size: 18px }}@media screen and (max-width: 375px) { html { font-size: 16px }}@media screen and (max-width: 320px) { html { font-size: 12px }} 媒体查询CSS 媒体查询（media query）是响应式设计的关键组成部分，你可以根据各种设备特征和参数是否存在以及对应的值来应用 CSS 样式。 123@media media-type and (media-feature-rule) { /* CSS rules go here */} 它由以下部分组成： 一个媒体类型，告诉浏览器这段代码是用在什么类型的媒体上的(例如印刷品或者屏幕)。可以指定的媒体类型为： all print screen speech 一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试。 一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。 媒体特征规则在指定了类型以后，你可以用一条规则指向一种媒体特征。 宽和高使用最小值和最大值对响应式设计有很多的用处，所以你会很少见到width或height 单独使用的情况。 12345@media screen and (min-width: 800px) { .container { margin: 1em 2em; }} 朝向一个受到良好支持的媒体特征是orientation，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。对朝向的测试可以帮你建立一个为竖放设备优化的布局。 12345@media (orientation: landscape) { body { color: rebeccapurple; }} 使用指点设备作为四级规范的一部分，hover****媒体特征被引入了进来。这种特征意味着你可以测试用户是否能在一个元素上悬浮，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。 12345@media (hover: hover) { body { color: rebeccapurple; }} 如果我们知道用户不能悬浮的话，我们可以默认显示一些交互功能。对于能够悬浮的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。 还是在四级规范中，出现了pointer媒体特征。它可取三个值：none、fine和coarse。fine指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。coarse指针是你在触摸屏上的手指。none值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。 使用pointer可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。 更复杂的媒体查询有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。 媒体查询中的“与”逻辑为了混合媒体特征，你可以以与在上面使用and很相同的方式，用and来混合媒体类型和特征。 例如，我们可能会想要测得min-width和orientation，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。 12345@media screen and (min-width: 400px) and (orientation: landscape) { body { color: blue; }} 媒体查询中的“或”逻辑如果你有一组查询，且要其中的任何一个都可以匹配的话，那么你可以使用逗号分开这些查询。 在下面的示例中，文本会在视口至少为 400 像素宽的时候或者设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。 12345@media screen and (min-width: 400px), screen and (orientation: landscape) { body { color: blue; }} 媒体查询中的“非”逻辑你可以用not操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。 12345@media not all and (orientation: landscape) { body { color: blue; }} 怎么选择断点可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到适应各式屏幕尺寸的最佳效果。引入媒体查询，以及样式改变时的点，被叫做***断点***（breakpoints）。 开发者工具中的响应式设计模式能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。 移动优先的响应式设计 使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为移动优先设计。 媒体查询的缺点也很明显，如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。 vw/vh 布局vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度。 任意层级元素，在使用vw单位的情况下，1vw都等于视图宽度的百分之一。使用 vw 和 vh 单位来定义页面元素的尺寸，从而实现响应式布局。与百分比布局很相似，但更好用。 1234.box { width: 50vw; /* 宽度为视口宽度的一半 */ height: 50vh; /* 高度为视口高度的一半 */} 百分比布局使用百分比来实现布局，但是需要特定宽度时，元素百分比参考的对象为父元素，元素嵌套较深时会有问题。不建议用%来做响应式布局。 123456789101112&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;cssCopy code.parent { width: 100%; /* 父元素宽度为屏幕宽度 */}.child { width: 50%; /* 宽度为父元素宽度的一半 */ height: 50%; /* 高度为父元素高度的一半 */} 响应式布局现代布局方式，例如多栏布局、伸缩盒和网格默认是响应式的。 多个列123456.container { column-count: 3;}.container { column-width: 10em;} 伸缩盒1234567.container { display: flex;}.item { flex: 1;} CSS 网格1234.container { display: grid; grid-template-columns: 1fr 1fr 1fr;} 使用第三方框架除了手动进行移动端适配外，还可以使用一些专门的移动端开发框架，如 Bootstrap、Ant Design、Element Ui等。这些框架提供了丰富的移动端组件和样式，可以大大简化移动应用的开发过程，并帮助开发者快速实现移动端适配。","link":"/2021/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"title":"设计模式","text":"定义：","link":"/2023/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"网络","text":"域名域名是为了解决 IP 地址难以记忆并为人们提供了方便记忆的地址。 域名的结构一个域名是由几部分（有可能只是一部分，也许是两部分，三部分…）组成的简单结构，它被点分隔，不同于中文书写顺序，它需要从右到左阅读。 TLD（Top-Level Domain，顶级域名），顶级域名可以告诉用户域名所提供的服务类型。最通用的顶级域名（.com, .org, .net）不需要 web 服务器满足严格的标准，但一些顶级域名则执行更严格的政策。比如： 地区的顶级域名，如.us，.fr，或.sh，可以要求必须提供给定语言的服务器或者托管在指定国家。这些 TLD 通常表明对应的网页服务从属于何种语言或哪个地区。 包含.gov 的顶级域名只能被政府部门使用。 .edu 只能为教育或研究机构使用。 顶级域名既可以包含拉丁字母，也可以包含特殊字符。顶级域名最长可以达到 63 个字符，不过为了使用方便，大多数顶级域名都是两到三个字符。 获取一个域名过程： 去域名注册商的网站。 通常那些网站上都有突出的”获得域名”宣传，点击它。 按要求仔细填表。一定要仔细检查你是否有将你想要的域名拼错。一旦你给错误域名付款了，便为时已晚！ 注册商将会在域名正确注册后通知你。数小时之内，所有 DNS 服务器都会收到你的 DNS 信息。 HTTPHTTP 是超文本传输协议。HTTP协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次HTTP请求。 HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，HTTP会立即将TCP连接断开，这个过程是很短的。 所以HTTP连接是一种短连接，是一种无状态的连接。 HTTP 常见的状态码有哪些？ 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。 TCP/IPTCP 概述TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。 建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。 Socket：由 IP 地址和端口号组成 序列号：用来解决乱序问题等 窗口大小：用来做流量控制 UDP 和 TCP 有什么区别呢？分别的应用场景是？UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。 UDP 协议真的非常简，头部只有 8 个字节（64 位）。 TCP 和 UDP 区别： 连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接。UDP 是不需要连接，即刻传输数据。 服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点。UDP 支持一对一、一对多、多对多的交互通信 可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？(opens new window) 拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 传输方式:TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。 分片不同:TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。 TCP 和 UDP 应用场景：由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于： FTP 文件传输；HTTP / HTTPS；由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于： 包总量较少的通信，如 DNS 、SNMP 等；视频、音频等多媒体通信；广播通信； TCP 连接建立，三次握手过程是怎样的？ 第三次握手是可以携带数据的，前两次握手是不可以携带数据的 TCP 断开连接，四次挥手过程是怎样的？ 在特定情况下，四次挥手是可以变成三次挥手的，具体情况可以看这篇：TCP 四次挥手，可以变成三次吗？ IP 概述在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。 IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。 而人类为了方便记忆采用了点分十进制的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 4 组，每组以「.」隔开，再将每组转换成十进制。 IP 地址的分类IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。 A、B、C 分类对应的地址范围、最大主机个数： DNSDNS 请求如何工作？正如我们所看到的，当你想在浏览器中展示一个网页的时候，输入域名比输入 IP 简单多了。让我们看一下这个过程： 在你的浏览器地址栏输入mozilla.org。 你的浏览器询问你的计算机是否已经识别此域名所确定的 IP 地址（使用本地 DNS 缓存）。如果是的话，这个域名被转换为 IP 地址，然后浏览器与网络服务器交换内容。结束。 如果你的电脑不知道 mozilla.org 域名背后的 IP, 它会询问一个 DNS 服务器，这个服务器的工作就是告诉你的电脑已经注册的域名所匹配的 IP。 现在电脑知道了要请求的 IP 地址，你的浏览器能够与网络服务器交换内容。","link":"/2019/09/29/408/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"分治法","slug":"分治法","link":"/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"},{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"pages":[{"title":"","text":"","link":"/about/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tages/index.html"},{"title":"","text":"","link":"/archives/index.html"}]}