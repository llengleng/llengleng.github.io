<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>CSS 布局 - 冷冷</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#f7f7f7"><meta name="application-name" content="Icaurs - Hexo Theme"><meta name="msapplication-TileImage" content="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"><meta name="msapplication-TileColor" content="#f7f7f7"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Icaurs - Hexo Theme"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="布局CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&amp;#x2F;窗口的位置。在这个模块中将涉及更多关于页面布局技术的细节："><meta property="og:type" content="blog"><meta property="og:title" content="CSS 布局"><meta property="og:url" content="http://example.com/2021/10/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E5%B8%83%E5%B1%80/"><meta property="og:site_name" content="冷冷"><meta property="og:description" content="布局CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&amp;#x2F;窗口的位置。在这个模块中将涉及更多关于页面布局技术的细节："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/%E5%89%8D%E7%AB%AF/css.png"><meta property="article:published_time" content="2021-10-09T13:10:43.000Z"><meta property="article:modified_time" content="2021-11-10T04:04:00.000Z"><meta property="article:author" content="冷冷"><meta property="article:tag" content="CSS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/%E5%89%8D%E7%AB%AF/css.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/10/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E5%B8%83%E5%B1%80/"},"headline":"CSS 布局","image":["http://example.com/img/%E5%89%8D%E7%AB%AF/css.png"],"datePublished":"2021-10-09T13:10:43.000Z","dateModified":"2021-11-10T04:04:00.000Z","author":{"@type":"Person","name":"冷冷"},"publisher":{"@type":"Organization","name":"冷冷","logo":{"@type":"ImageObject","url":"https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"}},"description":"布局CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&#x2F;窗口的位置。在这个模块中将涉及更多关于页面布局技术的细节："}</script><link rel="canonical" href="http://example.com/2021/10/09/%E5%89%8D%E7%AB%AF/CSS/CSS%20%E5%B8%83%E5%B1%80/"><link rel="icon" href="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-72437521-5" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-72437521-5');</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="冷冷" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/./img/%E5%89%8D%E7%AB%AF/css.png" alt="CSS 布局"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-09T13:10:43.000Z" title="2021/10/9 21:10:43">2021-10-09</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/CSS/">CSS</a></span><span class="level-item">1 小时读完 (大约13125个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">CSS 布局</h1><div class="content"><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>CSS 页面布局技术允许我们拾取网页中的元素，并且控制它们相对正常布局流、周边元素、父容器或者主视口&#x2F;窗口的位置。在这个模块中将涉及更多关于<strong>页面布局</strong>技术的细节：</p>
<span id="more"></span>

<ul>
<li>正常布局流</li>
<li>display属性</li>
<li>弹性盒子</li>
<li>网格</li>
<li>浮动</li>
<li>定位</li>
<li>CSS 表格布局</li>
<li>多列布局</li>
</ul>
<p>每种技术都有它们的用途，各有优缺点，相互辅助。通过<strong>理解各个布局方法的设计理念</strong>，你能够找到构建你想要的网页需要的布局方案。</p>
<h2 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h2><p>正常布局流（normal flow）是指在不对页面进行任何布局控制时，浏览器默认的 HTML 布局方式。</p>
<p>下列布局技术<strong>会覆盖默认的布局</strong>行为：</p>
<ul>
<li><strong>display 属性</strong> — 标准的 value，比如block, inline 或者 inline-block 元素在正常布局流中的表现形式。 接着是全新的布局方式，通过设置display的值，比如 CSS Grid 和 Flexbox.</li>
<li><strong>浮动</strong>——应用 float 值，诸如 left 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。</li>
<li><strong>position 属性</strong> — 允许你精准设置盒子中的盒子的位置，正常布局流中，默认为 static ，使用其他值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。</li>
<li><strong>表格布局</strong>— 表格的布局方式可以用在非表格内容上，可以使用display: table和相关属性在非表元素上使用。</li>
<li><strong>多列布局</strong>— 这个 Multi-column layout 属性可以让块按<strong>列布局</strong>，比如报纸的内容就是一列一列排布的。</li>
</ul>
<h2 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h2><p>在 css 中实现页面布局的主要方法是设定display属性的值。此属性允许我们更改默认的显示方式。正常流中的所有内容<strong>都有一个display的值</strong>，用作元素的默认行为方式。</p>
<p>在讨论布局时，对我们来说最重要的两个值是 display: flex 和 display: grid。</p>
<h3 id="弹性盒子"><a href="#弹性盒子" class="headerlink" title="弹性盒子"></a>弹性盒子</h3><p>Flexbox 是 CSS 弹性盒子布局模块（Flexible Box Layout Module）的缩写，它被专门设计出来用于创建横向或是纵向的一维页面布局。要使用 flexbox，你只需要在想要进行 flex 布局的<strong>父元素</strong>上应<strong>用display: flex</strong> ，所有直接子元素都将会按照 flex 进行布局。</p>
<p>当我们把display: flex添加到它的父元素时，元素就自动按列进行排列。这是由于它们变成了flex 项 (flex items)，按照 flex 容器（也就是它们的父元素）的一些 flex 相关的初值进行 flex 布局：它们整整齐齐排成一行，是因为父元素上<strong>flex-direction的初值是row</strong>。它们全都被拉伸至和最高的元素高度相同，是因为父元素上<strong>align-items属性的初值是stretch</strong>。</p>
<p><strong>flex 模型说明:</strong></p>
<p>当元素表现为 flex 框时，它们沿着两个轴来布局：<br><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Cflex.png"></p>
<ul>
<li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li>
<li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li>
<li>设置了 display: flex 的<strong>父元素</strong>被称之为 <strong>flex 容器（flex container）。</strong></li>
<li>在 flex 容器中表现为弹性的盒子的<strong>元素</strong>被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）。</li>
</ul>
<p>弹性盒子提供了 <strong>flex-direction</strong> 这样一个属性，它可以指定主轴的方向（弹性盒子子类放置的地方）——它<strong>默认值是</strong> <strong>row</strong>，这使得它们在按你浏览器的默认语言方向<strong>排成一排</strong>（在英语&#x2F;中文浏览器中是<strong>从左到右</strong>）。flex-direction:column是垂直排列。</p>
<blockquote>
<p>还可以使用 row-reverse 和 column-reverse 值反向排列 flex 项。</p>
</blockquote>
<p>换行：flex-wrap：wrap </p>
<p><strong>flex-flow 缩写:</strong></p>
<p>flex-direction 和 flex-wrap——的缩写 flex-flow</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row;</span><br><span class="line"><span class="attribute">flex-wrap</span>: wrap;</span><br><span class="line"></span><br><span class="line"><span class="attribute">flex-flow</span>: row wrap;</span><br></pre></td></tr></table></figure>

<p><strong>flex 项的动态尺寸:</strong></p>
<p>本例中，我们设置 <code>&lt;article&gt;</code> 元素的 flex 值为 1，这表示每个元素占用空间都是相等的，占用的空间是在设置 padding 和 margin 之后剩余的空间。因为它是一个比例，这意味着将每个 flex 项的设置为 400000 的效果和 1 的时候是完全一样的。</p>
<p>第三个 <code>&lt;article&gt;</code> 元素占用了两倍的可用宽度，剩下的一样——现在总共有四个比例单位可用。前两个 flex 项各有一个，因此它们占用每个可用空间的 1&#x2F;4。第三个有两个单位，所以它占用 2&#x2F;4 或者说是 1&#x2F;2 的可用空间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。</p>
<p>还可以指定 flex 的最小值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>水平和垂直对齐:</strong></p>
<p><strong>align-items</strong> 控制 flex 项在<strong>交叉轴</strong>上的位置。</p>
<ul>
<li>默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。</li>
<li>在上面规则中我们使用的 center 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。</li>
<li>你也可以设置诸如 flex-start 或 flex-end 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E5%AF%B9%E9%BD%901.png"></p>
<p>可以用 align-self 属性覆盖 align-items 的行为。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E5%AF%B9%E9%BD%902.png"></p>
<p><strong>justify-content</strong> 控制 flex 项在<strong>主轴</strong>上的位置。</p>
<ul>
<li>默认值是 flex-start，这会使所有 flex 项都位于主轴的开始处。</li>
<li>你也可以用 flex-end 来让 flex 项到结尾处。</li>
<li>center 在 justify-content 里也是可用的，可以让 flex 项在主轴居中。</li>
<li>而我们上面用到的值 space-around 是很有用的——它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。</li>
<li>还有一个值是 space-between，它和 space-around 非常相似，只是它不会在两端留下任何空间。</li>
</ul>
<p><strong>flex 项排序:</strong></p>
<p>弹性盒子也有可以<strong>改变 flex 项的布局位置</strong>的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Cflex%E6%8E%92%E5%BA%8F.png"></p>
<p>刷新下，然后你会看到“Smile”按钮移动到了主轴的末尾。下面我们谈下它实现的一些细节：</p>
<ul>
<li>所有 flex 项<strong>默认的</strong> <strong>order</strong> <strong>值是 0</strong>。</li>
<li>order 值大的 flex 项比 order 值小的在显示顺序中更靠后。</li>
<li>相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。</li>
<li>第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。</li>
</ul>
<p>你也可以给 order 设置<strong>负值</strong>使它们比值为 0 的元素<strong>排得更前面</strong>。比如，你可以设置“Blush”按钮排在主轴的最前面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button:last-child &#123;</span><br><span class="line">  order: -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Cflex%E6%8E%92%E5%BA%8F2.png"></p>
<p><strong>flex 嵌套:</strong></p>
<p>弹性盒子也能创建一些颇为复杂的布局。设置一个元素为 flex 项，那么他同样成为一个 flex 容器，它的孩子（直接子节点）也表现为弹性盒子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>First article<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Third article<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Cray food truck brunch, XOXO +1 keffiyeh pickled chambray waistcoat ennui. Organic small batch paleo 8-bit. Intelligentsia umami wayfarers pickled, asymmetrical kombucha letterpress kitsch leggings cold-pressed squid chartreuse put a bird on it. Listicle pickled man bun cornhole heirloom art party.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Tacos actually microdosing, pour-over semiotics banjo chicharrones retro fanny pack portland everyday carry vinyl typewriter. Tacos PBR&amp;B pork belly, everyday carry ennui pickled sriracha normcore hashtag polaroid single-origin coffee cold-pressed. PBR&amp;B tattooed trust fund twee, leggings salvia iPhone photo booth health goth gastropub hammock.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Grid-布局"><a href="#Grid-布局" class="headerlink" title="Grid 布局"></a>Grid 布局</h3><p>Flexbox 用于设计横向或纵向的布局，而 Grid 布局则被设计用于同时在<strong>两个维度</strong>上把元素按<strong>行和列</strong>排列整齐。</p>
<p>使用display:grid，分别使用 grid-template-rows 和 grid-template-columns 两个属性定义了一些行和列的轨道。</p>
<p>利用 grid-column 和 grid-row 两个属性来指定每一个子元素应该从哪一行&#x2F;列开始，并在哪一行&#x2F;列结束。这就能够让子元素在多个行&#x2F;列上展开。</p>
<p><strong>什么是网格布局？</strong></p>
<p>网格是由一系列水平及垂直的线构成的一种布局模式。根据网格，我们能够将设计元素进行排列，帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。</p>
<p>一个网格通常具有许多的<strong>列（column）与行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p>
<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5Cgrid.png"></p>
<p><strong>定义一个网格:</strong></p>
<p>默认情况下，子项按照正常布局流自顶而下排布。</p>
<p>通过把容器的 <strong>display 属性设置为</strong> <strong>grid</strong> ,来定义一个网格。</p>
<p>与弹性盒子一样，将父容器改为网格布局后，他的直接子项会变为网格项。</p>
<p>与弹性盒子不同的是，在定义网格后，网页并不会马上发生变化。因为 display: grid 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让我们的容器看起来更像一个网格，我们要给刚定义的网格加一些列。那就让我们加三个宽度为200px的列。当然，这里可以用任何长度单位，包括百分比。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BD%91%E6%A0%BC1.png"></p>
<h5 id="使用-fr-单位的灵活网格："><a href="#使用-fr-单位的灵活网格：" class="headerlink" title="使用 fr 单位的灵活网格："></a>使用 fr 单位的灵活网格：</h5><p>除了长度和百分比，我们也可以用 fr 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份。</p>
<p>将窗口调窄（由于示例中设定了max-width，可能需要很窄），你应该能看到每一列的宽度可以会随着可用空间变小而变小。fr 单位按比例划分了可用空间。</p>
<p>这个定义里，第一列被分配了 2fr 可用空间，余下的两列各被分配了 1fr 的可用空间，这会使得第一列的宽度更大。另外，fr可以与一般的长度单位混合使用。比如设置 grid-template-columns: 300px 2fr 1fr，那么第一列宽度是300px，剩下的两列会根据剩余的可用空间按比例分配。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BD%91%E6%A0%BC2.png"></p>
<blockquote>
<p>fr单位分配的是<em>可用</em>空间而非<em>所有</em>空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。</p>
</blockquote>
<p><strong>网格间隙:</strong></p>
<p>使用 grid-column-gap 属性来定义<strong>列间隙</strong>；使用 grid-row-gap来定义<strong>行间隙</strong>；使用 grid-gap 可以同时设定两者。</p>
<p>间隙距离可以用任何长度单位包括百分比来表示，但<strong>不能使用<strong><strong>fr</strong></strong>单位</strong>。</p>
<blockquote>
<p>gap属性曾经有一个grid-前缀，不过后来的标准进行了修改，目的是让他们能够在不同的布局方法中都能起作用。尽管现在这个前缀不会影响语义，但为了代码的健壮性，你可以把两个属性都写上。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重复构建轨道组:</strong></p>
<p>可以使用repeat来重复构建具有某些宽度配置的某些列。举个例子，如果要创建多个等宽轨道，可以用下面的方法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前一样，你仍然得到了 3 个 1fr 的列。第一个传入 repeat 函数的值<strong>（<strong><strong>3</strong></strong>）</strong>表明了后续列宽的配置要<strong>重复多少次</strong>，而第二个值<strong>（<strong><strong>1fr</strong></strong>）</strong>表示需要<strong>重复的构建配置</strong>，这个配置可以具<strong>有多个长度设定</strong>。例如repeat(2, 2fr 1fr)，这相当于填入了 2fr 1fr 2fr 1fr。</p>
<blockquote>
<p>关键字<strong>auto-fill</strong>可以确定的重复次数。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repeat(auto-fill, <span class="number">250px</span>)</span><br><span class="line">repeat(auto-fit, <span class="number">250px</span>)</span><br><span class="line">repeat(auto-fill, <span class="selector-attr">[col-start]</span> <span class="number">250px</span> <span class="selector-attr">[col-end]</span>)</span><br><span class="line">repeat(auto-fit, <span class="selector-attr">[col-start]</span> <span class="number">250px</span> <span class="selector-attr">[col-end]</span>)</span><br><span class="line">repeat(auto-fill, <span class="selector-attr">[col-start]</span> minmax(<span class="number">100px</span>, <span class="number">1</span>fr) <span class="selector-attr">[col-end]</span>)</span><br><span class="line">repeat(auto-fill, <span class="number">10px</span> <span class="selector-attr">[col-start]</span> <span class="number">30%</span> <span class="selector-attr">[col-middle]</span> <span class="number">400px</span> <span class="selector-attr">[col-end]</span>)</span><br></pre></td></tr></table></figure>

<p><strong>显式网格与隐式网格:</strong></p>
<p>到目前为止，我们定义过了列，但还没有管过行。但在这之前，我们要来理解一下显式网格和隐式网格。显式网格是我们用 grid-template-columns 或 grid-template-rows 属性创建的。而隐式网格则是当有内容被放到网格外时才会生成的。显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。</p>
<p>隐式网格中生成的行&#x2F;列大小是参数默认是 auto ，大小会根据放入的内容自动调整。当然，你也可以使用<strong>grid-auto-rows和grid-auto-columns</strong>属性<strong>手动设定隐式网格轨道的大小</strong>。下面的例子将grid-auto-rows设为了100px，然后你可以看到那些隐式网格中的行（因为这个例子里没有设定grid-template-rows，因此，所有行都位于隐式网格内）现在都是 100 像素高了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BD%91%E6%A0%BC3.png"></p>
<p><strong>minmax() 函数:</strong></p>
<p>很难知道网页上某个元素的尺寸在不同情况下会变成多少，一些额外的内容或者更大的字号就会导致许多能做到像素级精准的设计出现问题。所以，我们有了minmax()函数。</p>
<p>minmax() 函数为一个行&#x2F;列的尺寸设置了取值范围。比如设定为 minmax(100px, auto)，那么尺寸就<strong>至少</strong>为 100 像素，并且如果内容尺寸<strong>大于 100 像素</strong>则会根据<strong>内容自动调整</strong>。在这里试一下把 grid-auto-rows 属性设置为minmax函数。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(<span class="number">100px</span>, auto);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有网格内的内容均小于 100 像素，看起来不会有变化。</p>
<p>但如果在某一项中放入很长的内容或者图片，你可以看到这个格子所在的哪<strong>一行的高度变</strong>成能刚好容纳内容的高度了</p>
<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BD%91%E6%A0%BC4.png"></p>
<p><strong>自动使用多列填充:</strong></p>
<p>用到 repeat() 函数中的一个关键字<strong>auto-fill</strong>来替代确定的重复次数。而函数的第二个参数，我们使用minmax()函数来设定一个行&#x2F;列的最小值，以及最大值 1fr。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="built_in">minmax</span>(<span class="number">200px</span>, <span class="number">1</span>fr));</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(<span class="number">100px</span>, auto);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BD%91%E6%A0%BC5.png"></p>
<p>可以看到形成了一个包含了许多至少 200 像素宽的列的网格，<strong>将容器填满</strong>。随着容器<strong>宽度的改变</strong>，网格会<strong>自动根据容器宽度进行调整</strong>，每一列的宽度总是大于 200 像素，并且<strong>容器总会被列填满</strong>。</p>
<h4 id="基于线的元素放置"><a href="#基于线的元素放置" class="headerlink" title="基于线的元素放置"></a>基于线的元素放置</h4><p>在定义完了网格之后，我们要<strong>把元素放入网格中</strong>。我们的网格有许多分隔线，第一条线的起始点与文档书写模式相关。在<strong>英文中</strong>，<strong>第一条列分隔线</strong>（即网格边缘线）在网格的<strong>最左边</strong>而<strong>第一条行分隔线</strong>在网格的<strong>最上面</strong>。而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。</p>
<p>我们根据这些分隔线来放置元素，通过以下属性来指定从那条线开始到哪条线结束。</p>
<ul>
<li>grid-column-start(en-US)</li>
<li>grid-column-end(en-US)</li>
<li>grid-row-start(en-US)</li>
<li>grid-row-end(en-US)</li>
</ul>
<p>这些属性的值均为分隔线序号，你也可以用以下缩写形式来同时指定开始与结束的线。</p>
<ul>
<li>grid-column</li>
<li>grid-row</li>
</ul>
<p>注意开始与结束的线的序号要使用&#x2F;符号分开。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BA%BF%E5%AF%B9%E9%BD%901.png"></p>
<blockquote>
<p>也可以用 -1 来定位到最后一条列分隔线或是行分隔线，并且可以用负数来指定倒数的某一条分隔线。但是这只能用于<strong>显式网格</strong>，对于隐式网格-1不一定能定位到最后一条分隔线。</p>
</blockquote>
<p><strong>使用 grid-template-areas 属性放置元素:</strong></p>
<p>另一种往网格放元素的方式是用grid-template-areas属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">&quot;header header&quot;</span></span><br><span class="line">    <span class="string">&quot;sidebar content&quot;</span></span><br><span class="line">    <span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">3</span>fr;</span><br><span class="line">  <span class="attribute">gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E7%BA%BF%E5%AF%B9%E9%BD%902.png"></p>
<p>grid-template-areas属性的使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用.符号，让一个格子留空</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>把一个元素“浮动”(float) 起来，会改变该元素本身和在正常布局流（normal flow）中跟随它的其他元素的行为。这一元素会浮动到左侧或右侧，并且从正常布局流 (normal flow) 中移除，这时候其他的周围内容就会在这个被设置浮动 (float) 的元素周围环绕。</p>
<p>当一个元素被浮动后，它会像一个盒子一样，从文档流中移动到其容器的一边。其他元素会认为浮动的元素所占据的空间仍然存在，因此会在布局时避开这个空间。</p>
<p>float 属性有四个可能的值：</p>
<ul>
<li>left — 将元素浮动到左侧。</li>
<li>right — 将元素浮动到右侧。</li>
<li>none — 默认值，不浮动。</li>
<li>inherit — 继承父元素的浮动属性。</li>
</ul>
<p>例子当中，我们把一个<div>元素浮动到左侧，并且给了他一个右侧的margin，把文字推开。这给了我们文字环绕着这个<div>元素的效果，在现代网页设计当中，这是你唯一需要学会的事情。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Simple float example<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Float<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam</span><br><span class="line">  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus</span><br><span class="line">  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus</span><br><span class="line">  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,</span><br><span class="line">  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus</span><br><span class="line">  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat</span><br><span class="line">  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros</span><br><span class="line">  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec</span><br><span class="line">  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B5%AE%E5%8A%A8.png"></p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>如果不想让剩余元素也受到浮动元素的影响，我们需要停止它；这是通过添加 clear 属性实现的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cleared</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8.png"></p>
<p>应该看到，第二个段落已经停止了浮动，不会再跟随浮动元素排布了。clear 属性接受下列值：</p>
<ul>
<li>left：停止任何活动的左浮动</li>
<li>right：停止任何活动的右浮动</li>
<li>both：停止任何活动的左右浮动</li>
</ul>
<h3 id="清除浮动元素周围的盒子"><a href="#清除浮动元素周围的盒子" class="headerlink" title="清除浮动元素周围的盒子"></a>清除浮动元素周围的盒子</h3><p>当浮动元素脱离正常文档流时，它会不再占据文档流中的空间，而是漂浮在文档的特定位置。当你<strong>想要一个盒子（容器）包含浮动元素并与浮动元素后续内容产生正常的布局时</strong>，通常需要处理浮动元素的影响。这涉及到清除浮动。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>Float<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;hhh&quot;</span>&gt;</span></span><br><span class="line">  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam</span><br><span class="line">  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus</span><br><span class="line">  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus</span><br><span class="line">  laoreet sit amet.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet</span><br><span class="line">  orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare</span><br><span class="line">  ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse</span><br><span class="line">  ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis</span><br><span class="line">  ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et</span><br><span class="line">  a urna. Ut id ornare felis, eget fermentum sapien.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你给 <strong>.float-left</strong> 元素应用了 <strong>float: left;<strong>，它会脱离正常文档流，而 <strong>.container</strong> 的高度</strong>不会自动包含浮动元素</strong>。这可能导致 <strong>.container</strong> 的<strong>高度坍缩</strong>，从而影响下方紧随其后的内容。</p>
<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A82.png"></p>
<p>有三种方法可以处理这个问题:<br><strong>clearfix:</strong></p>
<p>先向包含浮动内容及其本身的盒子后方插入一些生成的内容，并将生成的内容清除浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A83.png"></p>
<p><strong>使用 overflow:</strong></p>
<p>一个替代的方案是将包裹元素的 overflow 属性设置为除 visible 外的其他值。在包裹元素上添加 overflow: auto 规则。现在，盒子应该再一次停止浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">79</span>, <span class="number">185</span>, <span class="number">227</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A84.png"></p>
<p>这个例子之所以能够生效，是因为创建了所谓的 <strong>块格式化上下文（BFC）</strong>。可以把它看作页面内部包含所需元素的一小块布局区域。如此设置可以<strong>让浮动元素包含在 BFC 及其背景之内</strong>。大部分情况下这种小技巧都可以奏效，但是可能会出现莫名其妙的<strong>滚动条或裁剪阴影</strong>，这是使用 overflow 带来的一些<strong>副作用</strong>。</p>
<p><strong>display: flow-root:</strong></p>
<p>一个较为现代的方案是使用 display 属性的 flow-root 值。它可以无需小技巧来创建块格式化上下文（BFC），在使用上没有副作用。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">79</span>, <span class="number">185</span>, <span class="number">227</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A85.png"></p>
<h2 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h2><p>定位 (positioning) 能够让我们把一个元素从它原本在正常布局流 (normal flow) 中应该在的位置移动到另一个位置。定位 (positioning) 并不是一种用来给你做主要页面布局的方式，它更像是让你去管理和微调页面中的一个特殊项的位置。</p>
<p>有一些非常有用的技术在特定的布局下依赖于position属性。同时，理解定位 (positioning) 也能够帮助你理解正常布局流 (normal flow)，理解把一个元素移出正常布局流 (normal flow) 是怎么一回事。</p>
<p>有<strong>五种</strong>主要的定位类型需要我们了解：</p>
<ul>
<li><strong>静态定位</strong>（Static positioning）是每个元素默认的属性——它表示“将元素放在文档布局流的默认位置——没有什么特殊的地方”。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.positioned</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: static;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>相对定位</strong>（Relative positioning）允许我们相对于元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于<strong>微调和精准设计</strong>（design pinpointing）非常有用。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E5%AE%9A%E4%BD%8D.png"></p>
<ul>
<li><strong>绝对定位</strong>（Absolute positioning）将元素完全从页面的正常布局流（normal layout flow）中移出，类似将它<strong>单独放在一个图层中</strong>。我们可以将元素<strong>相对于页面的 <html> 元素</strong>边缘固定，或者<strong>相对于该元素的</strong><em><strong>最近被定位祖先元素*<strong>（nearest positioned ancestor element）。绝对定位在创建</strong>复杂布局</strong>效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板。</em><em>将元素从文档流 (document flow) 当中移出了。</em>*</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br></pre></td></tr></table></figure>

<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E5%AE%9A%E4%BD%8D2.png"></p>
<p><strong>定位上下文：</strong>可以改变<strong>定位上下文</strong> —— 绝对定位的元素的相对位置元素。通过<strong>设置</strong>其中一个<strong>父元素的定位属性</strong> —— 也就是包含绝对定位元素的那个元素（如果要设置绝对定位元素的相对元素，那么这个元素一定要包含绝对定位元素）。</p>
<p><strong>z-index：</strong>可以更改堆叠顺序，网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。<strong>z-index</strong> 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。z-index 只接受无单位索引值，较高的值将高于较低的值。</p>
<ul>
<li><strong>固定定位</strong>（Fixed positioning）与<em>绝对定位</em>非常类似，但是它是将一个元素相对<strong>浏览器视口固定</strong>，而不是相对另外一个元素。这在创建类似在整个页面滚动过程中总是处于屏幕的某个位置的导航菜单时非常有用。<strong>将元素从文档流 (document flow) 当中移出了。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: fixed;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>粘性定位</strong>（Sticky positioning）是一种新的定位方式，它会让元素先保持和 position: static 一样的定位，当它的相对视口位置（offset from the viewport）<strong>达到某一个预设值时</strong>，它就会像 position: fixed 一样定位。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: sticky;</span><br></pre></td></tr></table></figure>

<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>一个<code>&lt;table&gt;</code>标签之所以能够像表格那样展示，是由于 css 默认给<code>&lt;table&gt;</code>标签设置了一组 table 布局属性。当这些属性被应用于排列非<code>&lt;table&gt;</code>元素时，这种用法被称为“使用 CSS 表格”。</p>
<p>表布局是不灵活的，繁重的标记，难以调试和语义上的错误。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: table;</span><br></pre></td></tr></table></figure>

<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><p>多列布局模组给了我们 一种把内容按列排序的方式，就像文本在报纸上排列那样。</p>
<p>要把一个块转变成多列容器 (multicol container)，我们可以使用 <strong>column-count</strong>属性来告诉浏览器我们需要多少列。也可以使用<strong>column-width</strong>来告诉浏览器以至少某个宽度的尽可能多的列来填充容器，任何剩余的空间之后会被现有的列平分。这意味着你可能无法期望得到你指定宽度，除非容器的宽度刚好可以被你指定的宽度除尽。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 column-gap 改变列间<strong>间隙</strong>。</li>
<li>用 column-rule 在列间加入一条<strong>分割线，</strong>column-rule 是 <strong>column-rule-color</strong> 和 <strong>column-rule-style</strong>的缩写，接受同 border 一样的单位。</li>
<li><strong>break-inside</strong>属性来控制 multicol 和多页媒体中的内容拆分、折断。</li>
</ul>
<h1 id="传统的布局方法"><a href="#传统的布局方法" class="headerlink" title="传统的布局方法"></a>传统的布局方法</h1><h2 id="CSS-网格布局之前的布局与网格系统"><a href="#CSS-网格布局之前的布局与网格系统" class="headerlink" title="CSS 网格布局之前的布局与网格系统"></a>CSS 网格布局之前的布局与网格系统</h2><p>可以了解到基于 float 和 flexbox 的网格系统和网格框架是如何工作的。它们里面没有哪个的建立方式是像通过 CSS 网格布局创建网格那样，真的建立一个网格。他们通过给目标一个大小，然后推动它们，让它们<strong>看起来</strong>像网格一样排列成一条线。</p>
<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><p>body 将会占据 90% 的视口宽度，直到达到 900 像素，在这种情况下，它将固定并保持在视口正中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望两个<code>&lt;div&gt;</code>，一个浮在窗口的一边，另一个浮动在另一边的话，需要将它们的宽度设置为其父元素的 100% 或者更小，以便他们可以并排放置。</p>
<p>这里我们将它们都设置为了父元素宽度的 48%——总共是 96%，在两栏之间留 4% 的空隙，为它们提供一些宽松的空间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">48%</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">48%</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在宽度的表示上都用的是百分比——这是一个很好的策略，这创建了一个<strong>流动布局（liquid layout）</strong>，能够适应不同的屏幕大小，在小一些的屏幕上也能使列保持一样的比例。</p>
</blockquote>
<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80.png"></p>
<h3 id="浮动网格的限制"><a href="#浮动网格的限制" class="headerlink" title="浮动网格的限制"></a>浮动网格的限制</h3><p>当你想用这个网格系统时，你得仔细看看你的总长是否正确，并且每行中的元素所横跨的列数不超过这一行可容纳的列数。由于浮动布局实现的方式，如果网格列的数目对与网格来说太大，在最后边的元素会跑到下一行去，<strong>搞坏了布局</strong>。</p>
<p>还要记住，如果元素内容比行宽，它会溢出，看起来一团糟。</p>
<p>这个系统的最大限制是，它本质上是<strong>一维</strong>的。我们在<strong>处理列</strong>、让元素跨越列，但是处理不了行。如果不设置一个确定的高度，用老方法很难控制元素高。这个方法很不灵活 —它只有在你确定你的内容有个明确的高的情况下有用。</p>
<h2 id="弹性盒网格"><a href="#弹性盒网格" class="headerlink" title="弹性盒网格"></a>弹性盒网格</h2><p>弹性布局不是为网格布局而设的，把它当网格布局来用也有新的挑战。</p>
<p>在顶行，我们有十二个整齐的盒子，它们在视口宽度改变时同等地放大缩小。可是在下一行，我们只有四个物件，它们也从六十像素的基础上变大变小。因为它们只有四个，它们可以长得比上一行的物件更快，结果是它们都占据了第二行的相同宽度。</p>
<p><img src="/%5Cimages%5C%E5%89%8D%E7%AB%AF%5C%E5%BC%B9%E6%80%A7%E7%9B%92%E7%BD%91%E6%A0%BC.png"></p>
<p>为了解决这个问题，我们仍然需要包含span类，以提供一个用于那个元素的，可以替换掉为 flex-basis所使用的值的宽度。</p>
<p>弹性盒设计上是<strong>一维</strong>。它处理单个维度，行的或者列的。我们不能创建一个对行列严格要求的网格，意即如果我们要在我们的网格上使用弹性盒的话，我们仍然需要计算浮动布局的百分比。</p>
<h2 id="第三方网格系统"><a href="#第三方网格系统" class="headerlink" title="第三方网格系统"></a>第三方网格系统</h2><p>流行的框架，例如Bootstrap和Foundation和Skeleton，就包含了网格系统。 </p>
<p>Skeleton（或者其他任何网格框架）正在做的所有事情是，设定一个<strong>预定义的类</strong>，可以通过把它们加到你的标记文件里面的方式使用这些框架，和你自己做计算这些百分数的工作完全是一样的。</p>
<p>正如你所看到的这样，使用 Skeleton 的时候，几乎不需要写多少 CSS。向标记文本里面<strong>加类</strong>的时候，替我们处理了所有的浮动。</p>
<h1 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h1><p>如果用户正在使用比设计者考虑到的更小或者更大的屏幕，那么结果从多余的滚动条，到过长的行和没有被合理利用的空间，不一而足。随着人们使用的屏幕尺寸的种类越来越多，出现了响应式网页设计的概念（<em>responsive web design，RWD</em>），RWD 指的是允许 Web 页面适应不同屏幕宽度因素等，进行布局和外观的调整的一系列实践。这是改变我们设计多设备网页的方式的思想。</p>
<p>响应式设计是将三种技术的混合使用：</p>
<ul>
<li>第一个是液态网格。</li>
<li>第二个是液态图像的理念，通过使用相当简单的将设置max-width属性设置为100%的技术，图像可以在包含它们的列变得比图像原始尺寸窄的时候，缩放得更小，但总不会变得更大。</li>
<li>第三个关键的组件是媒体查询，可以只使用 CSS 实现，和所有尺寸的屏幕都使用一种布局不同的是，布局是可以改变的：侧栏可以在小屏幕上重新布局，而替代用的导航栏也可以显示出来。</li>
</ul>
<h2 id="媒介查询"><a href="#媒介查询" class="headerlink" title="媒介查询"></a>媒介查询</h2><p><strong>CSS 媒体查询</strong>（media query）是响应式设计的关键组成部分，你可以根据各种设备特征和参数是否存在以及对应的值来应用 CSS 样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-feature-rule) &#123;</span><br><span class="line">  <span class="comment">/* CSS rules go here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它由以下部分组成：</p>
<ul>
<li><p>一个<strong>媒体类型</strong>，告诉浏览器这段代码是用在什么类型的媒体上的(例如印刷品或者屏幕)。可以指定的媒体类型为：</p>
</li>
<li><ul>
<li>all</li>
<li>print</li>
<li>screen</li>
<li>speech</li>
</ul>
</li>
<li><p>一个媒体表达式，是一个被包含的 CSS 生效所需的规则或者测试。</p>
</li>
<li><p>一组 CSS 规则，会在测试通过且媒体类型正确的时候应用。</p>
</li>
</ul>
<h3 id="媒体特征规则"><a href="#媒体特征规则" class="headerlink" title="媒体特征规则"></a>媒体特征规则</h3><p>在指定了类型以后，你可以用一条规则指向一种媒体特征。</p>
<p><strong>宽和高:</strong></p>
<p>使用<strong>最小值和最大值</strong>对响应式设计有很多的用处，所以你会很少见到width或height 单独使用的情况。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span> <span class="number">2em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>朝向:</strong></p>
<p>一个受到良好支持的媒体特征是orientation，我们可以用它测得竖放（portrait mode）和横放（landscape mode）模式。要在设备处于横向的时候改变 body 文本颜色的话，可使用下面的媒体查询。对朝向的测试可以帮你建立一个为<strong>竖</strong>放设备<strong>优化</strong>的布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用指点设备:</strong></p>
<p>作为四级规范的一部分，<strong>hover媒体特征</strong>被引入了进来。这种特征意味着你可以测试用户<strong>是否</strong>能在一个元素上<strong>悬浮</strong>，这也基本就是说他们正在使用某种指点设备，因为触摸屏和键盘导航是没法实现悬浮的。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">hover</span>: <span class="attribute">hover</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们知道用户<strong>不能悬浮</strong>的话，我们可以<strong>默认</strong>显示一些交互功能。对于<strong>能够悬浮</strong>的用户，我们可以选择在悬浮在链接上的时候，让这些功能可用。</p>
<blockquote>
<p>还是在四级规范中，出现了<strong>pointer媒体特征</strong>。它可取三个值：none、fine和coarse。fine指针是类似于鼠标或者触控板的东西，它让用户可以精确指向一片小区域。coarse指针是你在触摸屏上的手指。none值意味着，用户没有指点设备，也许是他们正只使用键盘导航，或者是语音命令。<br>使用pointer可以在用户使用屏幕时进行交互时，帮你更好地设计响应这种交互的界面。例如，如果你知道用户正在用触摸屏设备交互的时候，你可以建立更大的响应区域。</p>
</blockquote>
<h3 id="更复杂的媒体查询"><a href="#更复杂的媒体查询" class="headerlink" title="更复杂的媒体查询"></a>更复杂的媒体查询</h3><p>有了所有不同的可用的媒体查询，你可能想要把它们混合起来，或者建立查询列表——其中的任何一个都可以匹配生效。</p>
<p><strong>媒体查询中的“与”逻辑:</strong></p>
<p>为了混合媒体特征，你可以以与在上面使用<strong>and</strong>很相同的方式，用and来混合媒体类型和特征。</p>
<p>例如，我们可能会想要测得min-width和orientation，而 body 的文字只会在视口至少为 400 像素宽，且设备横放时变为蓝色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>) <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>媒体查询中的“或”逻辑:</strong></p>
<p>如果你有一组查询，且要其中的<strong>任何一个</strong>都可以匹配的话，那么你可以使用<strong>逗号分开</strong>这些查询。</p>
<p>在下面的示例中，文本会在视口至少为 400 像素宽的时候<strong>或者</strong>设备处于横放状态的时候变为蓝色。如果其中的任何一项成立，那么查询就匹配上了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">400px</span>), screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>媒体查询中的“非”逻辑:</strong></p>
<p>你可以用not操作符让整个媒体查询失效。这就直接反转了整个媒体查询的含义。因而在下面的例子中，文本只会在朝向为竖着的时候变成蓝色。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="怎么选择断点"><a href="#怎么选择断点" class="headerlink" title="怎么选择断点"></a>怎么选择断点</h3><p>可以在一张样式表上加入多条媒体查询，调整整个页面或者部分页面以达到<strong>适应各式屏幕尺寸</strong>的最佳效果。引入媒体查询，以及样式改变时的点，被叫做*<strong>断点</strong>（breakpoints）。</p>
<p>开发者工具中的<strong>响应式设计模式</strong>能很好地帮助弄清楚断点应该设置在哪里。你能容易就能让视口变大和变小，然后看下可以在哪里加入媒体查询、调整设计，从而改善内容。</p>
<h3 id="移动优先的响应式设计"><a href="#移动优先的响应式设计" class="headerlink" title="移动优先的响应式设计"></a>移动优先的响应式设计</h3><p>使用媒体查询时的一种通用方式是，为窄屏设备（例如移动设备）创建一个简单的单栏布局，然后检查是否是大些的屏幕，在你知道你有足够容纳的屏幕宽度的时候，开始采用一种多栏的布局。这经常被描述为<strong>移动优先</strong>设计。</p>
<h3 id="真的需要媒体查询吗？"><a href="#真的需要媒体查询吗？" class="headerlink" title="真的需要媒体查询吗？"></a>真的需要媒体查询吗？</h3><p>弹性盒、网格和多栏布局都给了你建立可伸缩的甚至是响应式组件的方式，而不需要媒体查询。</p>
<h2 id="灵活网格"><a href="#灵活网格" class="headerlink" title="灵活网格"></a>灵活网格</h2><p>使用灵活网格，你只需要加进去一个断点，在内容看起来不齐整的时候改变设计。例如如果一行随着屏幕大小增加而增长得不可读的长，或者是一个盒子在变窄时把每行的两个单词挤到一起。</p>
<p>早年间进行响应式设计的时候，我们唯一的实现布局的选项是使用float。灵活浮动布局是这样实现的，让每个元素都有一个作为宽度的百分数，而且确保整个布局的和不会超过 100%。在他对于液态网格文章的原文中，Marcotte 详细描述了一种布局的法则，通过使用像素并把布局转化为百分数的方式设计。</p>
<blockquote>
<p>target &#x2F; context &#x3D; result</p>
</blockquote>
<p>例如如果我们的预期栏尺寸为 60 像素，而且它所在的上下文（或者容器）为 960 像素，我们在将零点二的空间移动到右边以后，用 960 去除 60，得到我们能够使用在我们的 CSS 上的值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.col</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6.25%</span>; <span class="comment">/* 60 / 960 = 0.0625 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="现代布局技术"><a href="#现代布局技术" class="headerlink" title="现代布局技术"></a>现代布局技术</h2><p>现代布局方式，例如多栏布局、伸缩盒和网格默认是响应式的。</p>
<h3 id="多个列"><a href="#多个列" class="headerlink" title="多个列"></a>多个列</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">column-width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伸缩盒"><a href="#伸缩盒" class="headerlink" title="伸缩盒"></a>伸缩盒</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-网格"><a href="#CSS-网格" class="headerlink" title="CSS 网格"></a>CSS 网格</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式图像"><a href="#响应式图像" class="headerlink" title="响应式图像"></a>响应式图像</h2><p>响应式图像，使用了<code>&lt;picture&gt;</code>元素和<code>&lt;img&gt;</code> srcset和sizes 特性，可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。也可以给用于不同尺寸的图像做“艺术指导”，为不同的屏幕尺寸提供不同的图像裁切或者完全不同的图像。</p>
<h2 id="响应式排版"><a href="#响应式排版" class="headerlink" title="响应式排版"></a>响应式排版</h2><p>根据屏幕真实使用范围的多少，在媒体查询的同时改变字体大小。</p>
<p>在本例子中，想讲一级标题设置为4rem，也就是说它将会有基础字体的四倍大。但是只想在大些的屏幕上有这么个超大的标题，那先弄个小点的标题，再使用媒体查询，在知道用户使用至少1200px的屏幕的时候，拿大些的尺寸覆写它。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">4rem</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用视口单位实现响应式排版"><a href="#使用视口单位实现响应式排版" class="headerlink" title="使用视口单位实现响应式排版"></a>使用视口单位实现响应式排版</h3><p>一个有趣的方式是使用视口单位vw来实现响应式排版。1vw等同于视口宽度的百分之一，即如果你用vw来设定字体大小的话，字体的大小将总是随视口的大小进行改变。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">6vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于，当做上面的事情的时候，因为文本总是随着视口的大小改变大小，用户失去了放缩任何使用vw单位的文本的能力。<strong>所以你永远都不要只用 viewport 单位设定文本。</strong></p>
<p>这里有一个<strong>解决方法</strong>，它使用了calc()，如果你将vw单位加到了使用固定大小（例如em或者rem）的值组，那么文本仍然是可放缩的。基本来说，是vw加在了放缩后的值上。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">1.5rem</span> + <span class="number">3vw</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是说，只需要指定标题的字体大小一次，而不是为移动端设定它，然后再在媒介查询中重新定义它。字体会在你增加视口大小的时候逐渐增大。</p>
<h2 id="视口元标签"><a href="#视口元标签" class="headerlink" title="视口元标签"></a>视口元标签</h2><p>看一张响应式页面的 HTML 源代码，通常将会在文档的<code>&lt;head&gt;</code>看到下面的<code>&lt;meta&gt;</code>标签。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>,initial-scale=<span class="number">1</span>&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>这个元标签告诉移动端浏览器，它们应该将视口宽度设定为设备的宽度，将文档放大到其预期大小的 100%，在移动端以你所希望的为移动优化的大小展示文档。</p>
<p>如果你有个窄屏布局，在 480 像素及以下的视口宽度下生效，但是视口是按 960 像素设定的，你将不会在移动端看到你的窄屏布局。通过设定width&#x3D;device-width，你用设备的实际宽度覆写了苹果默认的width&#x3D;960px，然后你的媒介查询就会像预期那样生效。</p>
<p><strong>所以你应该在你的文档头部</strong><em><strong>总是</strong></em><strong>包含上面那行 <code>&lt;meta&gt;</code>。</strong></p>
<p>和视口元标签一起，你可以使用另外几个设定，但大体说来，上面那行就是你想要使用的。</p>
<ul>
<li>initial-scale：设定了页面的初始缩放，我们设定为 1。</li>
<li>height：特别为视口设定一个高度。</li>
<li>minimum-scale：设定最小缩放级别。</li>
<li>maximum-scale：设定最大缩放级别。</li>
<li>user-scalable：如果设为no的话阻止缩放。</li>
</ul>
<p>你应该<strong>避免使用</strong>minimum-scale、maximum-scale，尤其是将user-scalable设为no。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。</p>
<h1 id="支持旧浏览器"><a href="#支持旧浏览器" class="headerlink" title="支持旧浏览器"></a>支持旧浏览器</h1><p>需要查明使用旧浏览器浏览你的站点的用户的数量。</p>
<p>你应该同样考虑设备的类型和人们使用你的网站的方式。</p>
<p>无障碍和使用辅助性技术的人总应当被考虑，对于一些站点，这问题可能更加重要。</p>
<h2 id="在-CSS-中构建回滚"><a href="#在-CSS-中构建回滚" class="headerlink" title="在 CSS 中构建回滚"></a>在 CSS 中构建回滚</h2><p>CSS 规范包含了在一个物件上同时应用两种布局的时候，解释浏览器如何反应的信息。例如，规范定义如果一个浮动元素同时又是用 CSS 网格布局实现的网格元素（Grid Item）的时候会发生什么。结合浏览器会忽略掉它不会理解的 CSS 的特点组合起来，你就得到了使用我们已经提到的传统技术构建简单布局的方法，在可以理解你的网格布局的现代浏览器中，传统布局方法会被网格布局覆写掉。</p>
<p>如果浏览器器<strong>支持网格布局</strong>，它<strong>会显示网格视图</strong>，<strong>否则</strong>它会<strong>忽略****display: grid</strong>相关的属性，使用<strong>浮动布局</strong>。</p>
<h3 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h3><p>浮动和清除</p>
<ul>
<li>如果浮动和清除的物件变成了弹性或网格物件，浮动和清除属性不再影响布局。</li>
</ul>
<p>display: inline-block</p>
<ul>
<li>这种方式能被用来建立列布局，如果一个物件被设为display: inline-block，但是之后变成了弹性或者网格物件，inline-block 行为将会被忽略。</li>
</ul>
<p>display: table</p>
<ul>
<li>被设为 CSS 表格布局的物件将会在它们变为弹性或者网格物件的时候不再表现出这种行为。重要的是，被建立起来用于修复表格结构的匿名盒子没有被建立起来。</li>
</ul>
<p>Multiple-column Layout</p>
<ul>
<li>对于某些布局，你能用multi-col作为回滚。如果你的容器有任何一个column-*属性被定义，之后变成了网格容器，那么多列行为不会实现。</li>
</ul>
<p>作为网格的回滚的弹性盒</p>
<ul>
<li>弹性盒由于受到了 IE10 和 IE11 的支持，比网格有着更好的浏览器支持。不过，如果你把弹性容器做成了网格容器，任何应用到子元素的flex属性都会被忽略。</li>
</ul>
<blockquote>
<p>在浮动布局中，百分数是依照容器计算的——33.333% 是容器宽度的三分之一。但在网格中，这 33.333% 是根据物件所在的网格区域计算的，所以只要网格布局引入进来，物件的大小实际上变成了我们想要的大小的三分之一。</p>
</blockquote>
<p>为了处理这种问题，我们需要有能够探测网格是否受到支持的方法，也就是探测它是否会覆写宽度的方法。CSS 在这里为我们提供了一个解决方法。</p>
<h2 id="特性查询"><a href="#特性查询" class="headerlink" title="特性查询"></a>特性查询</h2><p>特性查询允许你测试一个浏览器是否支持任何特定的一个 CSS 特性。这就是说，你可以写一些面向不支持某项特性的浏览器的 CSS，然后检查以了解浏览器是否支持，如果支持的话就可以加进你的复杂布局了。</p>
<p>示例中加入了一条特征查询，要是我们知道网格受到支持的话，我们可以用它把我们的物件宽度设定回auto。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">207</span>, <span class="number">232</span>, <span class="number">220</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">33.333%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">display</span>: <span class="attribute">grid</span>) &#123;</span><br><span class="line">  <span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对特性查询的支持，在各现代浏览器中都是很好的。</p>
<p>先在任何特性查询以外，编写我们的旧 CSS。不支持网格也不支持特性查询的浏览器会使用这部分它们可以理解的布局信息，将其他东西全都忽略掉。支持特性查询和 CSS 网格等的浏览器会运行网格代码和特性查询之内的代码。</p>
<h2 id="弹性盒的旧版本"><a href="#弹性盒的旧版本" class="headerlink" title="弹性盒的旧版本"></a>弹性盒的旧版本</h2><p>在旧版浏览器中，你可以找到弹性盒规范的旧有修订版本。在编写这篇文章的时候，这大多数是 IE10 的问题，它在弹性盒上使用了-ms-前缀。这也意味着现在还存在着一些过时的文章和教程，<a target="_blank" rel="noopener" href="https://css-tricks.com/old-flexbox-and-new-flexbox/">这篇有用的指导</a>帮助你分辨你看到的信息；如果你需要在很旧的浏览器中需要 flex 支持的话，它也会帮到你。</p>
<h2 id="IE10-和-IE11-的带前缀版的网格"><a href="#IE10-和-IE11-的带前缀版的网格" class="headerlink" title="IE10 和 IE11 的带前缀版的网格"></a>IE10 和 IE11 的带前缀版的网格</h2><p>CSS 网格规范最初成形于 IE10，也就是说尽管 IE10 和 IE11 不支持<em>现代的</em>网格，虽然这种网格和本站记载的现代布局不同，它们还是有一个很堪用的网格布局版本。IE10 和 IE11 的实现是以-ms-为前缀的，也就是说你可以给这两个浏览器用，而在非微软浏览器上，这种属性会被忽略。不过 Edge 仍然能理解旧语法，所以小心点，让每个东西都安全地在你的现代网格 CSS 中覆写。</p>
<h2 id="测试旧浏览器"><a href="#测试旧浏览器" class="headerlink" title="测试旧浏览器"></a>测试旧浏览器</h2><p>由于大多数浏览器都支持弹性盒和网格，测试旧浏览器想想就很难。一种方式是使用在线的测试工具，例如 Sauce Labs，在跨浏览器测试模块里有详细说明。</p>
<p>你也可以下载安装虚拟机，在你的电脑的容器环境中运行旧版浏览器。能够使用旧版 IE 是很有用的，为此，微软已经制作了一些可以免费下载的虚拟机。这些对 Mac、Windows 和 Linux 操作系统都是可以用的，所以即使你没有 Windows 电脑，这也是一个测试旧的和现代 Windows 浏览器的绝佳办法。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>CSS 布局</p><p><a href="http://example.com/2021/10/09/前端/CSS/CSS 布局/">http://example.com/2021/10/09/前端/CSS/CSS 布局/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>冷冷</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-10-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-11-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CSS/">CSS</a></div><div class="sharethis-inline-share-buttons"></div><script src="//platform-api.sharethis.com/js/sharethis.js#property=5ab6f60ace89f00013641890&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">移动端适配</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/10/09/%E5%89%8D%E7%AB%AF/Vue/Vue/"><span class="level-item">Vue 相关知识</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="i呼啸冷冷"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">i呼啸冷冷</p><p class="is-size-6 is-block">Web Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Solar System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#布局"><span class="level-left"><span class="level-item">1</span><span class="level-item">布局</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#正常布局流"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">正常布局流</span></span></a></li><li><a class="level is-mobile" href="#display-属性"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">display 属性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#弹性盒子"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">弹性盒子</span></span></a></li><li><a class="level is-mobile" href="#Grid-布局"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">Grid 布局</span></span></a></li></ul></li><li><a class="level is-mobile" href="#浮动"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">浮动</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#清除浮动"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">清除浮动</span></span></a></li><li><a class="level is-mobile" href="#清除浮动元素周围的盒子"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">清除浮动元素周围的盒子</span></span></a></li></ul></li><li><a class="level is-mobile" href="#定位技术"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">定位技术</span></span></a></li><li><a class="level is-mobile" href="#表格布局"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">表格布局</span></span></a></li><li><a class="level is-mobile" href="#多列布局"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">多列布局</span></span></a></li></ul></li><li><a class="level is-mobile" href="#传统的布局方法"><span class="level-left"><span class="level-item">2</span><span class="level-item">传统的布局方法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#CSS-网格布局之前的布局与网格系统"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">CSS 网格布局之前的布局与网格系统</span></span></a></li><li><a class="level is-mobile" href="#两列布局"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">两列布局</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#浮动网格的限制"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">浮动网格的限制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#弹性盒网格"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">弹性盒网格</span></span></a></li><li><a class="level is-mobile" href="#第三方网格系统"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">第三方网格系统</span></span></a></li></ul></li><li><a class="level is-mobile" href="#响应式设计"><span class="level-left"><span class="level-item">3</span><span class="level-item">响应式设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#媒介查询"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">媒介查询</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#媒体特征规则"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">媒体特征规则</span></span></a></li><li><a class="level is-mobile" href="#更复杂的媒体查询"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">更复杂的媒体查询</span></span></a></li><li><a class="level is-mobile" href="#怎么选择断点"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">怎么选择断点</span></span></a></li><li><a class="level is-mobile" href="#移动优先的响应式设计"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">移动优先的响应式设计</span></span></a></li><li><a class="level is-mobile" href="#真的需要媒体查询吗？"><span class="level-left"><span class="level-item">3.1.5</span><span class="level-item">真的需要媒体查询吗？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#灵活网格"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">灵活网格</span></span></a></li><li><a class="level is-mobile" href="#现代布局技术"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">现代布局技术</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多个列"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">多个列</span></span></a></li><li><a class="level is-mobile" href="#伸缩盒"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">伸缩盒</span></span></a></li><li><a class="level is-mobile" href="#CSS-网格"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">CSS 网格</span></span></a></li></ul></li><li><a class="level is-mobile" href="#响应式图像"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">响应式图像</span></span></a></li><li><a class="level is-mobile" href="#响应式排版"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">响应式排版</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#使用视口单位实现响应式排版"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">使用视口单位实现响应式排版</span></span></a></li></ul></li><li><a class="level is-mobile" href="#视口元标签"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">视口元标签</span></span></a></li></ul></li><li><a class="level is-mobile" href="#支持旧浏览器"><span class="level-left"><span class="level-item">4</span><span class="level-item">支持旧浏览器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#在-CSS-中构建回滚"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">在 CSS 中构建回滚</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#回滚方式"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">回滚方式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#特性查询"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">特性查询</span></span></a></li><li><a class="level is-mobile" href="#弹性盒的旧版本"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">弹性盒的旧版本</span></span></a></li><li><a class="level is-mobile" href="#IE10-和-IE11-的带前缀版的网格"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">IE10 和 IE11 的带前缀版的网格</span></span></a></li><li><a class="level is-mobile" href="#测试旧浏览器"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">测试旧浏览器</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2023/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="设计模式"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-11-19T14:10:43.000Z">2023-11-19</time></p><p class="title"><a href="/2023/11/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/09/29/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="前端安全性"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-09-29T14:10:43.000Z">2023-09-29</time></p><p class="title"><a href="/2023/09/29/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7/">前端安全性</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/08/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="低代码设计器的实现原理"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-08-19T14:10:43.000Z">2023-08-19</time></p><p class="title"><a href="/2023/08/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">低代码设计器的实现原理</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/06/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="发布 npm 包"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-06-19T14:10:43.000Z">2023-06-19</time></p><p class="title"><a href="/2023/06/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85/">发布 npm 包</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2023/05/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/"><img src="/./img/%E5%89%8D%E7%AB%AF/web.png" alt="低代码简介"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-05-19T14:10:43.000Z">2023-05-19</time></p><p class="title"><a href="/2023/05/19/%E5%89%8D%E7%AB%AF/%E9%AB%98%E7%BA%A7/%E4%BD%8E%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B/">低代码简介</a></p><p class="categories"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://s2.loli.net/2022/04/18/JlfLcsOwU8myTbB.jpg" alt="冷冷" height="28"></a><p class="is-size-7"><span>&copy; 2024 冷冷</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Discuss on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus/discussions"><i class="fas fa-comments"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>